# Familiar Schemas Code Collection (Focused)

This document contains focused Rust, Cargo, Nickel, and JSON Schema code from the familiar-schemas crate.

**Focused selection to stay under 1M tokens:**
- **Rust:** `src/`, `packages/`, and `tests/` directories
- **Cargo:** Only `Cargo.toml` files
- **Nickel:** Only `versions/v1.1.0-alpha/` directory
- **JSON Schema:** Only `versions/v1.1.0-alpha/` directory
- **Excluded:** Older schema versions and unrelated directories

Generated automatically from the codebase.

## Cargo Configuration Files

### Cargo.toml

```toml
[workspace]
members = [
    "packages/familiar-schemas"
]
resolver = "2"

```

### packages/familiar-schemas/Cargo.toml

```toml
[package]
name = "familiar-schemas"
version = "0.1.0"
edition = "2021"
description = "Pure, immutable schema library for the Familiar platform"

[features]
default = []
metaschema-validation = ["jsonschema", "miette", "serde_yaml"]

[dependencies]
# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Versioning
semver = { version = "1.0", features = ["serde"] }

# Checksums for immutability
sha2 = "0.10"

# Date/time
chrono = { version = "0.4", features = ["serde"] }

# Error handling
thiserror = "1.0"

# Directory traversal for validation
walkdir = "2.4"

# Metaschema validation (optional feature)
jsonschema = { version = "0.38", optional = true }
miette = { version = "7.0", optional = true, features = ["fancy"] }
serde_yaml = { version = "0.9", optional = true }
petgraph = "0.8.3"

[dev-dependencies]
# Parameterized testing
rstest = "0.18"
tempfile = "3.0"

```

## JSON Schema Files

### versions/v1.1.0-alpha/json-schema/architecture/ecs/Component.meta.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://familiar.dev/schemas/ecs/Component.meta.schema.json",
  "title": "ECS Component Meta-Schema",
  "description": "Schema for defining ECS Components - resources/capabilities that can be composed into Nodes",
  "type": "object",
  "required": ["name", "version", "description", "rust_type"],
  "properties": {
    "$schema": {
      "type": "string",
      "const": "ecs/Component.meta.schema.json"
    },
    "name": {
      "type": "string",
      "pattern": "^[a-z][a-z0-9_]*$",
      "description": "Unique identifier for the component (snake_case)"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "Semantic version of the component"
    },
    "description": {
      "type": "string",
      "description": "Human-readable description of the component's purpose"
    },
    "depends_on": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "default": [],
      "description": "List of component names this component depends on (must be initialized first)"
    },
    "config": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["string", "integer", "number", "boolean", "array", "object"]
          },
          "default": {},
          "description": {
            "type": "string"
          },
          "required": {
            "type": "boolean",
            "default": true
          },
          "env_var": {
            "type": "string",
            "description": "Environment variable to read this config from"
          }
        },
        "required": ["type"]
      },
      "description": "Configuration options for initializing the component"
    },
    "rust_type": {
      "type": "string",
      "description": "The Rust type this component resolves to (e.g., Arc<DatabasePool>)"
    },
    "requires_llm": {
      "type": "boolean",
      "default": false,
      "description": "Whether this component requires LLM connectivity"
    },
    "singleton": {
      "type": "boolean",
      "default": true,
      "description": "Whether only one instance of this component can exist per Node"
    }
  },
  "additionalProperties": false
}


```

### versions/v1.1.0-alpha/json-schema/architecture/ecs/Node.meta.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://familiar.dev/schemas/ecs/Node.meta.schema.json",
  "title": "ECS Node Meta-Schema",
  "description": "Schema for defining ECS Nodes - service definitions that compose Systems and Components (e.g., familiar-daemon, familiar-worker)",
  "type": "object",
  "required": ["title", "x-familiar-kind", "x-familiar-queue", "x-familiar-resource-class"],
  "properties": {
    "$schema": {
      "type": "string",
      "const": "http://json-schema.org/draft-07/schema#"
    },
    "title": {
      "type": "string",
      "description": "Human-readable name for the node (e.g., FamiliarDaemon)"
    },
    "description": {
      "type": "string",
      "description": "Human-readable description of the node's purpose"
    },
    "x-familiar-kind": {
      "type": "string",
      "const": "node",
      "description": "Must be 'node' for node schemas"
    },
    "x-familiar-queue": {
      "type": "string",
      "description": "The Temporal task queue this node consumes from"
    },
    "x-familiar-resource-class": {
      "type": "string",
      "enum": ["llm", "io", "cpu", "batch"],
      "description": "Resource class for automatic scaling configuration"
    },
    "x-familiar-systems": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "$ref": {
            "type": "string",
            "pattern": "^(\\.\\./)*(systems/)?[A-Za-z]+\\.system\\.json$",
            "description": "Reference to a system schema"
          }
        },
        "required": ["$ref"]
      },
      "description": "List of systems this node executes"
    },
    "x-familiar-components": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "$ref": {
            "type": "string",
            "pattern": "^(\\.\\./)*(components/)?[A-Za-z]+\\.component\\.json$",
            "description": "Reference to a component schema"
          }
        },
        "required": ["$ref"]
      },
      "description": "List of components this node initializes"
    },
    "x-familiar-resources": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "$ref": {
            "type": "string",
            "pattern": "^(\\.\\./)*(resources/)?[a-z-]+\\.resource\\.json$",
            "description": "Reference to a resource schema"
          }
        },
        "required": ["$ref"]
      },
      "description": "List of external resources this node connects to"
    },
    "x-familiar-concurrency": {
      "type": "integer",
      "minimum": 1,
      "default": 10,
      "description": "Default concurrency for this node's worker"
    },
    "x-familiar-memory": {
      "type": "string",
      "pattern": "^\\d+(Mi|Gi)$",
      "description": "Memory allocation (e.g., '2Gi', '512Mi')"
    }
  },
  "additionalProperties": true
}


```

### versions/v1.1.0-alpha/json-schema/architecture/ecs/Queue.meta.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://familiar.dev/schemas/ecs/Queue.meta.schema.json",
  "title": "ECS Queue Meta-Schema",
  "description": "Schema for defining ECS Queues - Temporal task queues or Kafka topics that route work to nodes",
  "type": "object",
  "required": ["title", "x-familiar-kind", "x-familiar-queue-type"],
  "properties": {
    "$schema": {
      "type": "string",
      "const": "http://json-schema.org/draft-07/schema#"
    },
    "title": {
      "type": "string",
      "description": "Human-readable name for the queue (e.g., DaemonQueue)"
    },
    "description": {
      "type": "string",
      "description": "Human-readable description of the queue's purpose"
    },
    "x-familiar-kind": {
      "type": "string",
      "const": "queue",
      "description": "Must be 'queue' for queue schemas"
    },
    "x-familiar-queue-type": {
      "type": "string",
      "enum": ["temporal", "kafka", "redis", "sqs"],
      "description": "The underlying queue technology"
    },
    "x-familiar-resource-class": {
      "type": "string",
      "enum": ["llm", "io", "cpu", "batch"],
      "description": "Resource class for work routed through this queue"
    },
    "x-familiar-concurrency": {
      "type": "integer",
      "minimum": 1,
      "default": 10,
      "description": "Default worker concurrency for this queue"
    },
    "x-familiar-consumers": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "$ref": {
            "type": "string",
            "pattern": "^(\\.\\./)*(nodes/)?[a-z-]+\\.node\\.json$",
            "description": "Reference to a node that consumes from this queue"
          }
        },
        "required": ["$ref"]
      },
      "description": "List of nodes that consume work from this queue"
    },
    "x-familiar-producers": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "$ref": {
            "type": "string",
            "description": "Reference to a system or workflow that produces to this queue"
          }
        },
        "required": ["$ref"]
      },
      "description": "List of systems/workflows that produce work to this queue"
    },
    "x-familiar-dlq": {
      "type": "object",
      "properties": {
        "$ref": {
          "type": "string",
          "description": "Reference to dead letter queue"
        }
      },
      "description": "Dead letter queue for failed messages"
    },
    "x-familiar-retention": {
      "type": "string",
      "pattern": "^\\d+(h|d)$",
      "description": "Message retention period (e.g., '24h', '7d')"
    },
    "x-familiar-visibility-timeout": {
      "type": "string",
      "pattern": "^\\d+(s|m)$",
      "description": "Message visibility timeout"
    }
  },
  "additionalProperties": true
}


```

### versions/v1.1.0-alpha/json-schema/architecture/ecs/Resource.meta.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://familiar.dev/schemas/ecs/Resource.meta.schema.json",
  "title": "ECS Resource Meta-Schema",
  "description": "Schema for defining ECS Resources - external dependencies like databases and APIs. Resources can be internal (owned) or virtual (external APIs acting as proxy contracts)",
  "type": "object",
  "required": ["title", "x-familiar-kind", "x-familiar-resource-type"],
  "properties": {
    "$schema": {
      "type": "string",
      "const": "http://json-schema.org/draft-07/schema#"
    },
    "title": {
      "type": "string",
      "description": "Human-readable name for the resource (e.g., PostgresMain)"
    },
    "description": {
      "type": "string",
      "description": "Human-readable description of the resource's purpose"
    },
    "x-familiar-kind": {
      "type": "string",
      "const": "resource",
      "description": "Must be 'resource' for resource schemas"
    },
    "x-familiar-resource-type": {
      "type": "string",
      "enum": ["database", "cache", "llm-api", "http-api", "message-queue", "storage"],
      "description": "The type of external resource"
    },
    "x-familiar-virtual": {
      "type": "boolean",
      "default": false,
      "description": "True if this is a proxy schema for an external API you don't own (e.g., OpenAI)"
    },
    "x-familiar-config": {
      "type": "object",
      "properties": {
        "$ref": {
          "type": "string",
          "description": "Reference to the configuration schema for this resource"
        }
      },
      "description": "Reference to configuration schema (e.g., DbPoolConfig)"
    },
    "x-familiar-tables": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "description": "For databases: list of tables/collections this resource manages"
    },
    "x-familiar-endpoint": {
      "type": "string",
      "format": "uri",
      "description": "For APIs: the base endpoint URL"
    },
    "x-familiar-rate-limit": {
      "type": "integer",
      "minimum": 0,
      "description": "Requests per minute limit"
    },
    "x-familiar-models": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "description": "For LLM APIs: available model identifiers"
    },
    "x-familiar-connection-pool": {
      "type": "object",
      "properties": {
        "min": {
          "type": "integer",
          "minimum": 0,
          "default": 1
        },
        "max": {
          "type": "integer",
          "minimum": 1,
          "default": 10
        }
      },
      "description": "Connection pool configuration"
    },
    "x-familiar-health-check": {
      "type": "object",
      "properties": {
        "endpoint": {
          "type": "string",
          "description": "Health check endpoint path"
        },
        "interval": {
          "type": "string",
          "pattern": "^\\d+(s|m)$",
          "description": "Health check interval"
        }
      },
      "description": "Health check configuration"
    }
  },
  "additionalProperties": true
}


```

### versions/v1.1.0-alpha/json-schema/architecture/ecs/System.meta.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://familiar.dev/schemas/ecs/System.meta.schema.json",
  "title": "ECS System Meta-Schema",
  "description": "Schema for defining ECS Systems - Temporal activities / business logic units that read and write entities",
  "type": "object",
  "required": ["title", "x-familiar-kind"],
  "properties": {
    "$schema": {
      "type": "string",
      "const": "http://json-schema.org/draft-07/schema#"
    },
    "title": {
      "type": "string",
      "description": "Human-readable name for the system (e.g., FatesGate)"
    },
    "description": {
      "type": "string",
      "description": "Human-readable description of the system's purpose"
    },
    "x-familiar-kind": {
      "type": "string",
      "const": "system",
      "description": "Must be 'system' for system schemas"
    },
    "x-familiar-input": {
      "type": "object",
      "properties": {
        "$ref": {
          "type": "string",
          "description": "Reference to the input schema for this system"
        }
      },
      "required": ["$ref"],
      "description": "The input type this system accepts"
    },
    "x-familiar-output": {
      "type": "object",
      "properties": {
        "$ref": {
          "type": "string",
          "description": "Reference to the output schema for this system"
        }
      },
      "required": ["$ref"],
      "description": "The output type this system produces"
    },
    "x-familiar-reads": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "$ref": {
            "type": "string",
            "description": "Reference to an entity schema this system reads"
          }
        },
        "required": ["$ref"]
      },
      "description": "List of entity types this system reads from"
    },
    "x-familiar-writes": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "$ref": {
            "type": "string",
            "description": "Reference to an entity schema this system writes"
          }
        },
        "required": ["$ref"]
      },
      "description": "List of entity types this system writes to"
    },
    "x-familiar-depends": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "$ref": {
            "type": "string",
            "description": "Reference to a component this system depends on"
          }
        },
        "required": ["$ref"]
      },
      "description": "List of components this system requires"
    },
    "x-familiar-service": {
      "type": "object",
      "properties": {
        "$ref": {
          "type": "string",
          "pattern": "^(\\.\\./)*(nodes/)?[a-z-]+\\.node\\.json$",
          "description": "Reference to the node that runs this system"
        }
      },
      "required": ["$ref"],
      "description": "The node/service this system runs on"
    },
    "x-familiar-queue": {
      "type": "string",
      "description": "Override queue for this system (defaults to node's queue)"
    },
    "x-familiar-timeout": {
      "type": "string",
      "pattern": "^\\d+(s|m|h)$",
      "description": "Activity timeout (e.g., '30s', '5m')"
    },
    "x-familiar-retries": {
      "type": "integer",
      "minimum": 0,
      "default": 3,
      "description": "Number of retry attempts on failure"
    }
  },
  "additionalProperties": true
}


```

### versions/v1.1.0-alpha/json-schema/codegen/components/AnthropicMessage.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Anthropic message format (no system role in messages)",
  "properties": {
    "content": {
      "type": "string"
    },
    "role": {
      "type": "string"
    }
  },
  "required": [
    "content",
    "role"
  ],
  "title": "AnthropicMessage",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/BondPhysics.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Models the classical physics of a relationship Bond. Based on Spring-Damper mechanics (Hooke's Law).",
  "properties": {
    "bond_strength": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "The overall strength or health of the bond. 0.0 = Broken/Weak, 1.0 = Strong/Healthy"
    },
    "damping_coefficient": {
      "description": "The 'inertia' of the bond, representing how quickly it returns to equilibrium. Higher values = slower return to rest (lingering effects). Lower values = quick recovery (resilient).",
      "format": "double",
      "type": "number"
    },
    "spring_constant": {
      "description": "The 'stiffness' of the bond, representing its resistance to change. Higher values = more rigid relationship (breaks under stress). Lower values = more flexible relationship (stretches without breaking).",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "bond_strength",
    "damping_coefficient",
    "spring_constant"
  ],
  "title": "BondPhysics",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/ChatMessage.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A single message in a chat conversation",
  "properties": {
    "content": {
      "description": "The message content",
      "type": "string"
    },
    "role": {
      "allOf": [
        {
          "$ref": "../primitives/MessageRole.schema.json"
        }
      ],
      "description": "The role of the message sender"
    }
  },
  "required": [
    "content",
    "role"
  ],
  "title": "ChatMessage",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/ClassificationSuperposition.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "WeightedClassification": {
      "description": "A weighted classification representing the probability/confidence that a segment belongs to a specific entity type. Part of the Superposition model - a single thought can be multiple things.",
      "properties": {
        "entity_type": {
          "allOf": [
            {
              "$ref": "../primitives/HeddleEntityType.schema.json"
            }
          ],
          "description": "The entity type this classification refers to"
        },
        "weight": {
          "allOf": [
            {
              "$ref": "../primitives/NormalizedFloat.schema.json"
            }
          ],
          "description": "Confidence/Weight (0.0 to 1.0) If > Threshold during collapse, we instantiate this entity."
        }
      },
      "required": [
        "entity_type",
        "weight"
      ],
      "type": "object"
    }
  },
  "description": "A collection of weighted classifications representing the superposition of possible entity types for a single segment.",
  "properties": {
    "classifications": {
      "items": {
        "$ref": "#/definitions/WeightedClassification"
      },
      "type": "array"
    }
  },
  "required": [
    "classifications"
  ],
  "title": "ClassificationSuperposition",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/CognitiveDimensions.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Defines the \"personality\" of an entity using the Five-Factor Model (OCEAN). These dimensions directly modulate the physics constants of the simulation.",
  "properties": {
    "agreeableness": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Agreeableness** Physics: **Damping / Friction**. High: High damping (absorbs shocks/conflict), reduces system energy. Low: Low damping (elastic collisions), amplifies conflict."
    },
    "conscientiousness": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Conscientiousness** Physics: **Spring Stiffness / Rigidity**. High: Strong restorative forces, low drift, adheres to intent. Low: Loose coupling, high drift."
    },
    "extraversion": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Extraversion** Physics: **Social Gravity Mass**. High: Large attractive radius, radiates energy (Arousal) to neighbors. Low: Small radius, absorbs energy."
    },
    "neuroticism": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Neuroticism (Emotional Stability)** Physics: **Volatility / Reactivity**. High: Low inertia (easily moved by small forces), unstable equilibrium. Low: High inertia (stable), resilient to perturbations."
    },
    "openness": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Openness to Experience** Physics: **Simulation Temperature**. High: High exploration, high volatility, accepts new connections easily. Low: Rigid structure, low noise tolerance."
    }
  },
  "required": [
    "agreeableness",
    "conscientiousness",
    "extraversion",
    "neuroticism",
    "openness"
  ],
  "title": "CognitiveDimensions",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/CognitiveOptics.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "albedo": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Albedo (Reflectivity):** How well the object reflects the User's Attention. 1.0 = Mirror (Perfect Recall). 0.0 = Vantablack (Repressed/Forgotten)."
    },
    "emissivity": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Emissivity (Luminance):** The object's internal energy source. High: \"Stars\" (Trauma, Obsessions, Core Values). They glow in the dark. Low: \"Planets\" (Facts). They need external attention to be seen."
    },
    "occlusion": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Occlusion (Density):** How much this object blocks rays behind it. High: A massive trauma that hides childhood memories behind it."
    },
    "roughness": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Roughness (Scattering):** 0.0 = Smooth/Polished. Rays bounce predictably (Logical/Linear thought). 1.0 = Rough/Matte. Rays scatter randomly (Creative/Associative thought)."
    }
  },
  "required": [
    "albedo",
    "emissivity",
    "occlusion",
    "roughness"
  ],
  "title": "CognitiveOptics",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/ContentPayload.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "metadata": {
      "additionalProperties": {
        "type": "string"
      },
      "type": "object"
    },
    "text": {
      "type": "string"
    }
  },
  "required": [
    "metadata",
    "text"
  ],
  "title": "ContentPayload",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/ContractEnforcer.component.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "High-performance JSON Schema validation component using SIMD-JSON and compiled schemas.",
  "properties": {
    "compiled_schemas": {
      "description": "Pre-compiled JSON schemas for fast validation",
      "type": "object"
    },
    "version": {
      "description": "Schema version this enforcer is configured for",
      "type": "string"
    }
  },
  "title": "ContractEnforcer",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/Conversation.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ChatMessage": {
      "description": "A single message in a chat conversation",
      "properties": {
        "content": {
          "description": "The message content",
          "type": "string"
        },
        "role": {
          "allOf": [
            {
              "$ref": "../primitives/MessageRole.schema.json"
            }
          ],
          "description": "The role of the message sender"
        }
      },
      "required": [
        "content",
        "role"
      ],
      "type": "object"
    }
  },
  "description": "A conversation (sequence of messages)",
  "properties": {
    "messages": {
      "items": {
        "$ref": "#/definitions/ChatMessage"
      },
      "type": "array"
    }
  },
  "required": [
    "messages"
  ],
  "title": "Conversation",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/CourseDetails.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Workflow metadata for a Course",
  "properties": {
    "latency_ms": {
      "default": 0,
      "description": "Total processing time in milliseconds",
      "format": "uint64",
      "minimum": 0.0,
      "type": "integer"
    },
    "model": {
      "description": "Model used for classification",
      "type": [
        "string",
        "null"
      ]
    },
    "provider": {
      "description": "AI provider used for classification",
      "type": [
        "string",
        "null"
      ]
    },
    "spawn_count": {
      "default": 0,
      "description": "Number of entities spawned into the simulation",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "unit_count": {
      "default": 0,
      "description": "Number of weave units (segments)",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    }
  },
  "title": "CourseDetails",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/DatabasePool.component.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Generic database connection pool component for non-Tiger databases.",
  "properties": {
    "max_connections": {
      "default": 20,
      "type": "integer"
    },
    "min_connections": {
      "default": 5,
      "type": "integer"
    },
    "pool": {
      "description": "Connection pool instance",
      "type": "object"
    }
  },
  "title": "DatabasePool",
  "type": "object",
  "x-familiar-config": {
    "$ref": "DbPoolConfig.schema.json"
  },
  "x-familiar-kind": "component",
  "x-familiar-resources": [
    {
      "$ref": "../resources/postgres-main.resource.json"
    }
  ],
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/DbPoolConfig.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Database pool configuration",
  "properties": {
    "connect_timeout_secs": {
      "description": "Connection timeout in seconds",
      "format": "uint64",
      "minimum": 0.0,
      "type": "integer"
    },
    "connection": {
      "allOf": [
        {
          "$ref": "../primitives/DbConnectionString.schema.json"
        }
      ],
      "description": "Database connection string"
    },
    "idle_timeout_secs": {
      "description": "Idle timeout in seconds",
      "format": "uint64",
      "minimum": 0.0,
      "type": "integer"
    },
    "max_connections": {
      "allOf": [
        {
          "$ref": "../primitives/DbPoolSize.schema.json"
        }
      ],
      "description": "Maximum pool size"
    },
    "min_connections": {
      "allOf": [
        {
          "$ref": "../primitives/DbPoolSize.schema.json"
        }
      ],
      "description": "Minimum pool size"
    }
  },
  "required": [
    "connect_timeout_secs",
    "connection",
    "idle_timeout_secs",
    "max_connections",
    "min_connections"
  ],
  "title": "DbPoolConfig",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/EmotionalState.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Represents an emotional state using the PAD (Pleasure-Arousal-Dominance) Model. Scientific Basis: Mehrabian & Russell (1974).",
  "properties": {
    "arousal": {
      "allOf": [
        {
          "$ref": "../primitives/SignedNormalizedFloat.schema.json"
        }
      ],
      "description": "**Arousal (Activation)** -1.0: Sleep/Coma (Low Energy) 0.0: Alert +1.0: Panic/Frenzy (High Energy)"
    },
    "dominance": {
      "allOf": [
        {
          "$ref": "../primitives/SignedNormalizedFloat.schema.json"
        }
      ],
      "description": "**Dominance (Control)** -1.0: Submissive/Overwhelmed 0.0: Balanced +1.0: Dominant/In-Control"
    },
    "valence": {
      "allOf": [
        {
          "$ref": "../primitives/SignedNormalizedFloat.schema.json"
        }
      ],
      "description": "**Pleasure (Valence)** -1.0: Agony/Despair (Negative) 0.0: Neutral +1.0: Ecstasy/Joy (Positive)"
    }
  },
  "required": [
    "arousal",
    "dominance",
    "valence"
  ],
  "title": "EmotionalState",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/FieldExcitation.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Represents an excitation (ripple) in the Cognitive Field. In QFT, entities are not particles moving through space; they are temporary excitations of the field itself. A memory is a \"Symmetry Breaking\" event that freezes a ripple.\n\n## Simulation Workspace Pattern\n\nTo avoid numerical drift from repeated i64<->f64 conversions during simulation: 1. Call `hydrate()` after loading from DB - populates f64 workspace fields 2. Run simulation math using `position_f64()` and `velocity_f64()` 3. Call `dehydrate()` before persisting - flushes f64 back to quantized\n\n```rust,ignore let mut excitation = load_from_db()?; excitation.hydrate();\n\n// Simulation loop - use f64 workspace for _ in 0..1000 { let pos = excitation.position_f64().unwrap(); let vel = excitation.velocity_f64().unwrap(); // ... physics math in f64 ... excitation.set_position_f64([new_x, new_y, new_z]); }\n\nexcitation.dehydrate(); save_to_db(&excitation)?; ```",
  "properties": {
    "amplitude": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Amplitude (Mass):** The strength of the field excitation. High Amplitude: Core Beliefs, Long-term Memories. Hard to annihilate. Low Amplitude: Fleeting thoughts. Easily absorbed back into the vacuum."
    },
    "energy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Energy (Activation):** The current potential/kinetic energy of the excitation."
    },
    "position": {
      "description": "The location in the 3D VAE Manifold where the field is excited",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    },
    "temperature": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Temperature (Volatility):** Internal kinetic energy of the field at this point. High Temp: The field vibrates (High uncertainty/plasticity). Low Temp: The field is frozen (Crystallized/Immutable)."
    },
    "velocity": {
      "description": "The rate of change of the field amplitude at this location (Cognitive Drift)",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    }
  },
  "required": [
    "amplitude",
    "energy",
    "position",
    "temperature",
    "velocity"
  ],
  "title": "FieldExcitation",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/GoogleContent.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "GooglePart": {
      "description": "Google content part",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "type": "object"
    }
  },
  "description": "Google content (message)",
  "properties": {
    "parts": {
      "items": {
        "$ref": "#/definitions/GooglePart"
      },
      "type": "array"
    },
    "role": {
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "parts"
  ],
  "title": "GoogleContent",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/GooglePart.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Google content part",
  "properties": {
    "text": {
      "type": "string"
    }
  },
  "required": [
    "text"
  ],
  "title": "GooglePart",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/Identity.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Core identity component that all entities possess",
  "properties": {
    "created_at": {
      "allOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        }
      ],
      "description": "When this entity was created"
    },
    "id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Unique identifier for this entity"
    },
    "tenant_id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Tenant (family/user) this entity belongs to"
    }
  },
  "required": [
    "created_at",
    "id",
    "tenant_id"
  ],
  "title": "Identity",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/LlmRequestDebug.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Debug info about the LLM request",
  "properties": {
    "system_prompt": {
      "type": "string"
    },
    "user_prompt": {
      "type": "string"
    }
  },
  "required": [
    "system_prompt",
    "user_prompt"
  ],
  "title": "LlmRequestDebug",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/Metadata.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "AnyValue",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/ObservationRequest.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ModelConfig": {
      "description": "Model definition with all configuration",
      "properties": {
        "api_model_id": {
          "description": "The actual API model ID to send to the provider",
          "type": "string"
        },
        "context_window": {
          "description": "Context window size (tokens)",
          "format": "uint32",
          "minimum": 0.0,
          "type": "integer"
        },
        "deprecated": {
          "default": false,
          "description": "Whether this model is deprecated",
          "type": "boolean"
        },
        "id": {
          "description": "Unique identifier (e.g., \"gpt-4o\", \"claude-sonnet-4\")",
          "type": "string"
        },
        "name": {
          "description": "Human-readable name",
          "type": "string"
        },
        "notes": {
          "default": null,
          "description": "Notes about the model",
          "type": [
            "string",
            "null"
          ]
        },
        "provider": {
          "allOf": [
            {
              "$ref": "../primitives/AIProvider.schema.json"
            }
          ],
          "description": "The provider"
        },
        "supports_json_mode": {
          "description": "Whether the model supports JSON mode",
          "type": "boolean"
        }
      },
      "required": [
        "api_model_id",
        "context_window",
        "id",
        "name",
        "provider",
        "supports_json_mode"
      ],
      "type": "object"
    },
    "RequestConfig": {
      "description": "Configuration for an AI completion request",
      "properties": {
        "json_mode": {
          "type": "boolean"
        },
        "max_tokens": {
          "$ref": "../primitives/MaxTokens.schema.json"
        },
        "model": {
          "$ref": "#/definitions/ModelConfig"
        },
        "retry": {
          "$ref": "../primitives/RetryConfig.schema.json"
        },
        "temperature": {
          "$ref": "../primitives/Temperature.schema.json"
        },
        "timeout_ms": {
          "format": "uint64",
          "minimum": 0.0,
          "type": "integer"
        }
      },
      "required": [
        "json_mode",
        "max_tokens",
        "model",
        "retry",
        "temperature",
        "timeout_ms"
      ],
      "type": "object"
    }
  },
  "description": "A complete Heddle observation request",
  "properties": {
    "config": {
      "$ref": "#/definitions/RequestConfig"
    },
    "context": {
      "type": "string"
    },
    "segment": {
      "type": "string"
    }
  },
  "required": [
    "config",
    "context",
    "segment"
  ],
  "title": "ObservationRequest",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/ObservationResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ClassificationPhysics": {
      "description": "Physics hints extracted during classification",
      "properties": {
        "arousal": {
          "default": null,
          "description": "Activation level: 0.0 (calm) to 1.0 (activated)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "clarity": {
          "default": null,
          "description": "How clear/specific: 0.0 (vague) to 1.0 (clear)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "significance": {
          "default": null,
          "description": "How significant/important: 0.0 to 1.0",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "valence": {
          "default": null,
          "description": "Emotional valence: -1.0 (negative) to 1.0 (positive)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "LlmRequestDebug": {
      "description": "Debug info about the LLM request",
      "properties": {
        "system_prompt": {
          "type": "string"
        },
        "user_prompt": {
          "type": "string"
        }
      },
      "required": [
        "system_prompt",
        "user_prompt"
      ],
      "type": "object"
    },
    "RawMessageIntent": {
      "description": "Raw message intent classification from LLM",
      "properties": {
        "confidence": {
          "default": 1.0,
          "description": "Confidence in classification (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "intent": {
          "allOf": [
            {
              "$ref": "../primitives/MessageIntent.schema.json"
            }
          ],
          "description": "Primary intent (LOG, QUERY, INFER, REFERENCE, REFLECT, COMMAND, SOCIAL)"
        },
        "query_target": {
          "anyOf": [
            {
              "$ref": "../primitives/QueryTarget.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "description": "If QUERY: what entities/threads are being queried"
        },
        "query_type": {
          "anyOf": [
            {
              "$ref": "../primitives/QueryType.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "description": "If QUERY: what type of query"
        }
      },
      "required": [
        "intent"
      ],
      "type": "object"
    },
    "RawPhysicsHint": {
      "description": "Raw physics hints from LLM (will be applied to spawned entities)",
      "properties": {
        "arousal": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "clarity": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "intrusiveness": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "significance": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "valence": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "volatility": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "RawSegment": {
      "description": "A raw segment from Phase 1 - NO classification, just text",
      "properties": {
        "content": {
          "description": "The extracted semantic content",
          "type": "string"
        },
        "mentions": {
          "default": [],
          "description": "Other entities/things mentioned",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "subject": {
          "default": null,
          "description": "Who/what is the primary subject? (for context, not classification)",
          "type": [
            "string",
            "null"
          ]
        },
        "temporal": {
          "default": null,
          "description": "Any temporal reference found",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "content"
      ],
      "type": "object"
    },
    "ResponseMetadata": {
      "description": "Metadata about an AI completion response",
      "properties": {
        "latency_ms": {
          "format": "uint64",
          "minimum": 0.0,
          "type": "integer"
        },
        "model_id": {
          "type": "string"
        },
        "model_name": {
          "type": "string"
        },
        "provider": {
          "$ref": "../primitives/AIProvider.schema.json"
        },
        "request_id": {
          "type": [
            "string",
            "null"
          ]
        },
        "usage": {
          "anyOf": [
            {
              "$ref": "../primitives/TokenUsage.schema.json"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "required": [
        "latency_ms",
        "model_id",
        "model_name",
        "provider"
      ],
      "type": "object"
    },
    "SegmentClassification": {
      "description": "Classification for a single segment",
      "properties": {
        "entity_type": {
          "allOf": [
            {
              "$ref": "../primitives/HeddleEntityType.schema.json"
            }
          ],
          "description": "The entity type (MOMENT, PULSE, INTENT) - relevant for LOG purpose"
        },
        "physics": {
          "anyOf": [
            {
              "$ref": "#/definitions/ClassificationPhysics"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Physics hints for entity spawning (only for LOG purpose)"
        },
        "purpose": {
          "allOf": [
            {
              "$ref": "../primitives/MessageIntent.schema.json"
            }
          ],
          "default": "LOG",
          "description": "Purpose of this specific segment (LOG, QUERY, COMMAND, etc.) Only LOG segments spawn entities"
        },
        "segment_index": {
          "description": "Index of the segment being classified",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "weight": {
          "default": 1.0,
          "description": "Confidence weight (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "entity_type",
        "segment_index"
      ],
      "type": "object"
    },
    "WeaveUnit": {
      "description": "A WeaveUnit is a single segment extracted from a Weave. It's a transient container used for classification routing. Physics are extracted by the LLM but passed directly to spawned entities, not stored on the WeaveUnit itself.",
      "properties": {
        "classifications": {
          "default": [],
          "description": "Classifications in superposition (determines which entity types to spawn)",
          "items": {
            "$ref": "#/definitions/WeaveUnitClassification"
          },
          "type": "array"
        },
        "content": {
          "description": "The extracted/cleaned text content for this segment",
          "type": "string"
        },
        "index": {
          "description": "Index of this unit within the shuttle (0-based)",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "primary_thread": {
          "description": "Primary thread: the main subject/actor of this unit Used for entity resolution (Stitch) downstream",
          "type": [
            "string",
            "null"
          ]
        },
        "purpose": {
          "allOf": [
            {
              "$ref": "../primitives/MessageIntent.schema.json"
            }
          ],
          "default": "LOG",
          "description": "Purpose of this specific unit (LOG, QUERY, COMMAND, INFER, REFERENCE) Determines how this unit is processed - only LOG units spawn entities"
        },
        "secondary_threads": {
          "description": "Secondary threads: other people/places/things mentioned Allows capturing companions, locations, etc.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "spawned_entity_ids": {
          "default": [],
          "description": "IDs of entities spawned from this unit (the actual simulation objects)",
          "items": {
            "format": "uuid",
            "type": "string"
          },
          "type": "array"
        },
        "temporal_marker": {
          "description": "Temporal marker: when this event/state occurred Can be absolute (\"6pm\"), relative (\"today\"), or frequency (\"once per hour\")",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "content",
        "index"
      ],
      "type": "object"
    },
    "WeaveUnitClassification": {
      "description": "Classification result for a weave unit (determines which entity type to spawn)",
      "properties": {
        "entity_type": {
          "allOf": [
            {
              "$ref": "../primitives/HeddleEntityType.schema.json"
            }
          ],
          "description": "The entity type this unit may become"
        },
        "weight": {
          "allOf": [
            {
              "$ref": "../primitives/NormalizedFloat.schema.json"
            }
          ],
          "description": "Confidence weight (0.0 to 1.0)"
        }
      },
      "required": [
        "entity_type",
        "weight"
      ],
      "type": "object"
    }
  },
  "description": "A complete observation response with 3-phase pipeline support",
  "properties": {
    "classifications": {
      "default": [],
      "description": "Classifications for each segment (only populated if LOG intent)",
      "items": {
        "$ref": "#/definitions/SegmentClassification"
      },
      "type": "array"
    },
    "llm_request": {
      "anyOf": [
        {
          "$ref": "#/definitions/LlmRequestDebug"
        },
        {
          "type": "null"
        }
      ],
      "description": "Debug: what was sent to the LLM"
    },
    "message_intent": {
      "allOf": [
        {
          "$ref": "#/definitions/RawMessageIntent"
        }
      ],
      "description": "Classified intent of the message (LOG, QUERY, INFER, etc.)"
    },
    "metadata": {
      "$ref": "#/definitions/ResponseMetadata"
    },
    "physics_hints": {
      "default": [],
      "description": "Physics hints for spawned entities",
      "items": {
        "anyOf": [
          {
            "$ref": "#/definitions/RawPhysicsHint"
          },
          {
            "type": "null"
          }
        ]
      },
      "type": "array"
    },
    "raw_llm_response": {
      "description": "Raw JSON response from LLM (exactly what came back)",
      "type": [
        "string",
        "null"
      ]
    },
    "segments": {
      "default": [],
      "description": "Raw segments from Phase 1 (no classification)",
      "items": {
        "$ref": "#/definitions/RawSegment"
      },
      "type": "array"
    },
    "weave_units": {
      "default": [],
      "description": "Hydrated weave units (segments + classifications combined)",
      "items": {
        "$ref": "#/definitions/WeaveUnit"
      },
      "type": "array"
    }
  },
  "required": [
    "message_intent",
    "metadata"
  ],
  "title": "ObservationResponse",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/OpenAIMessage.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "OpenAI message format",
  "properties": {
    "content": {
      "type": "string"
    },
    "role": {
      "type": "string"
    }
  },
  "required": [
    "content",
    "role"
  ],
  "title": "OpenAIMessage",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/PhysicsHint.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Sparse container for physics hints extracted from text by the LLM. All fields are Option<f64>. If None, the system applies Vacuum State defaults. This is the \"raw\" output from classification before collapse.",
  "properties": {
    "arousal": {
      "description": "Energy/Activation: 0.0 (Calm) to 1.0 (Excited) Maps to: VAE Arousal axis",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "clarity": {
      "description": "Specificity/Coherence: 0.0 (Vague) to 1.0 (Factual) Maps to: QuantumState.coherence and VAE Epistemic axis",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "intrusiveness": {
      "description": "Intrusiveness: 0.0 (Passive) to 1.0 (Demanding attention) Maps to: CognitiveOptics.emissivity",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "significance": {
      "description": "Importance/Mass: 0.0 (Mundane) to 1.0 (Critical) Maps to: FieldExcitation.amplitude",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "valence": {
      "description": "Emotional polarity: -1.0 (Negative) to 1.0 (Positive) Maps to: VAE Valence axis",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "volatility": {
      "description": "Volatility: 0.0 (Stable) to 1.0 (Fluctuating) Maps to: FieldExcitation.temperature",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    }
  },
  "title": "PhysicsHint",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/ProviderConfig.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Configuration for an AI provider connection",
  "properties": {
    "api_key": {
      "anyOf": [
        {
          "$ref": "../primitives/ApiKey.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "writeOnly": true
    },
    "api_version": {
      "type": [
        "string",
        "null"
      ]
    },
    "base_url": {
      "type": [
        "string",
        "null"
      ]
    },
    "organization_id": {
      "type": [
        "string",
        "null"
      ]
    },
    "provider": {
      "$ref": "../primitives/AIProvider.schema.json"
    }
  },
  "required": [
    "provider"
  ],
  "title": "ProviderConfig",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/QuantumState.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Represents the wave-nature of an entity. Instead of a full qubit simulation (O(2^N)), we use Complex Vectors (O(N)). This supports Interference, Phase, and Resonance natively in Vector DBs.",
  "properties": {
    "amplitudes": {
      "description": "The \"Wavefunction\" or \"Hologram\" of the entity. Stored as a list of (Real, Imaginary) tuples. This represents Amplitude (Magnitude) and Phase (Angle).\n\nIn a Vector DB, this is flattened to [Re1, Im1, Re2, Im2...].",
      "items": {
        "items": [
          {
            "format": "double",
            "type": "number"
          },
          {
            "format": "double",
            "type": "number"
          }
        ],
        "maxItems": 2,
        "minItems": 2,
        "type": "array"
      },
      "type": "array"
    },
    "coherence": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "How \"sharp\" the wave is (0.0 = Cloud/Vague, 1.0 = Particle/Fact). Low coherence allows for \"Tunneling\" (associative leaps)."
    },
    "frequency": {
      "description": "The dominant frequency of the pattern (for Holonomic resonance).",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    }
  },
  "required": [
    "amplitudes",
    "coherence"
  ],
  "title": "QuantumState",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/RelationalDynamics.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "formalism": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Formalism (Transactionalism / Spring Stiffness):** 1.0 = Rigid/Brittle (High k). Hard to move, snaps if stretched. 0.0 = Fluid/Elastic (Low k). Easy to stretch, adapts to change."
    },
    "intimacy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Intimacy (Communal Strength / Rest Length):** 1.0 = Fusion (Rest Length 0). The entities want to occupy the same space. 0.0 = Estrangement (Max Rest Length)."
    },
    "power_dynamic": {
      "allOf": [
        {
          "$ref": "../primitives/SignedNormalizedFloat.schema.json"
        }
      ],
      "description": "**Power Dynamic (Authority Gradient / Mass Bias):** -1.0 = Target is the Anchor (Infinite Mass relative to Source). 0.0 = Equal Mass (Both move equally). +1.0 = Source is the Anchor."
    },
    "primary_label": {
      "type": [
        "string",
        "null"
      ]
    },
    "spectral_signature": {
      "description": "**Color Filter (Spectral Gating):** If set, this bond only \"lights up\" under specific emotional light. e.g., A \"Work Friend\" bond might only reflect \"Professional\" (Blue) light. Stored as a hex code or vector for the shader.",
      "items": {
        "format": "float",
        "type": "number"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": [
        "array",
        "null"
      ]
    },
    "transparency": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Transparency (Refractive Index):** 1.0 = Clear. Looking at the Source reveals the Target (e.g., \"Honest\"). 0.0 = Opaque. The relationship hides the Target (e.g., \"Secretive\")."
    }
  },
  "required": [
    "formalism",
    "intimacy",
    "power_dynamic",
    "transparency"
  ],
  "title": "RelationalDynamics",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/RequestConfig.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ModelConfig": {
      "description": "Model definition with all configuration",
      "properties": {
        "api_model_id": {
          "description": "The actual API model ID to send to the provider",
          "type": "string"
        },
        "context_window": {
          "description": "Context window size (tokens)",
          "format": "uint32",
          "minimum": 0.0,
          "type": "integer"
        },
        "deprecated": {
          "default": false,
          "description": "Whether this model is deprecated",
          "type": "boolean"
        },
        "id": {
          "description": "Unique identifier (e.g., \"gpt-4o\", \"claude-sonnet-4\")",
          "type": "string"
        },
        "name": {
          "description": "Human-readable name",
          "type": "string"
        },
        "notes": {
          "default": null,
          "description": "Notes about the model",
          "type": [
            "string",
            "null"
          ]
        },
        "provider": {
          "allOf": [
            {
              "$ref": "../primitives/AIProvider.schema.json"
            }
          ],
          "description": "The provider"
        },
        "supports_json_mode": {
          "description": "Whether the model supports JSON mode",
          "type": "boolean"
        }
      },
      "required": [
        "api_model_id",
        "context_window",
        "id",
        "name",
        "provider",
        "supports_json_mode"
      ],
      "type": "object"
    }
  },
  "description": "Configuration for an AI completion request",
  "properties": {
    "json_mode": {
      "type": "boolean"
    },
    "max_tokens": {
      "$ref": "../primitives/MaxTokens.schema.json"
    },
    "model": {
      "$ref": "#/definitions/ModelConfig"
    },
    "retry": {
      "$ref": "../primitives/RetryConfig.schema.json"
    },
    "temperature": {
      "$ref": "../primitives/Temperature.schema.json"
    },
    "timeout_ms": {
      "format": "uint64",
      "minimum": 0.0,
      "type": "integer"
    }
  },
  "required": [
    "json_mode",
    "max_tokens",
    "model",
    "retry",
    "temperature",
    "timeout_ms"
  ],
  "title": "RequestConfig",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/RequestContext.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "HTTP request context for audit/logging\n\nCaptures metadata about the HTTP request that triggered an action. Used for security auditing, rate limiting, and debugging.\n\n## Usage\n\nEmbed in types that need request tracking: ```rust,ignore pub struct AuditLogEntry { // ... other fields #[serde(flatten)] pub request_context: RequestContext, } ```\n\n## Fields Replaced\n\nThis component replaces the common pattern of: - `pub ip_address: Option<String>` - `pub user_agent: Option<String>`",
  "properties": {
    "ip_address": {
      "description": "Client IP address (may be from X-Forwarded-For in proxied environments)",
      "type": [
        "string",
        "null"
      ]
    },
    "user_agent": {
      "description": "Client User-Agent header",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "title": "RequestContext",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/ResponseMetadata.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Metadata about an AI completion response",
  "properties": {
    "latency_ms": {
      "format": "uint64",
      "minimum": 0.0,
      "type": "integer"
    },
    "model_id": {
      "type": "string"
    },
    "model_name": {
      "type": "string"
    },
    "provider": {
      "$ref": "../primitives/AIProvider.schema.json"
    },
    "request_id": {
      "type": [
        "string",
        "null"
      ]
    },
    "usage": {
      "anyOf": [
        {
          "$ref": "../primitives/TokenUsage.schema.json"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "latency_ms",
    "model_id",
    "model_name",
    "provider"
  ],
  "title": "ResponseMetadata",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/SimLOD.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "SimulationTier": {
      "enum": [
        "conscious",
        "subconscious",
        "deep_storage"
      ],
      "type": "string"
    }
  },
  "properties": {
    "last_update": {
      "format": "uint64",
      "minimum": 0.0,
      "type": "integer"
    },
    "tier": {
      "$ref": "#/definitions/SimulationTier"
    }
  },
  "required": [
    "last_update",
    "tier"
  ],
  "title": "SimLOD",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/SimulationTier.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "conscious",
    "subconscious",
    "deep_storage"
  ],
  "title": "SimulationTier",
  "type": "string",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/TaskDynamics.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Models the state of a Task/Intent using Cybernetics and Thermodynamics principles.",
  "properties": {
    "activation_energy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Activation Energy (Invested Work)** Thermodynamics: The cumulative work performed on the system. Used to calculate \"Sunk Cost\" gravity."
    },
    "completion": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Completion (Inverse Discrepancy)** Cybernetics: 1.0 - Error Signal. How close the system is to the Goal State."
    },
    "entropy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Entropy (Disorder)** Information Theory: The uncertainty or \"noise\" in the process. High Entropy: Exploring, Brainstorming, Chaotic. Low Entropy: Executing, Refined, Linear."
    },
    "primary_status_label": {
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "activation_energy",
    "completion",
    "entropy"
  ],
  "title": "TaskDynamics",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/TigerDataStore.component.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Tiger physics engine data store component. Provides access to moments, pulses, bonds, and filaments.",
  "properties": {
    "pool": {
      "description": "Database connection pool",
      "type": "object"
    },
    "schema_enforcer": {
      "description": "Contract enforcer for validating data against schemas",
      "type": "object"
    }
  },
  "title": "TigerDataStore",
  "type": "object",
  "x-familiar-config": {
    "$ref": "DbPoolConfig.schema.json"
  },
  "x-familiar-kind": "component",
  "x-familiar-resources": [
    {
      "$ref": "../resources/postgres-tiger.resource.json"
    }
  ],
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/Timestamps.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Common timestamps for all persistent entities\n\nThis component captures: - `created_at`: When the entity was first created - `updated_at`: When the entity was last modified\n\nUse `#[serde(flatten)]` to embed directly into entity structs: ```rust,ignore pub struct MyEntity { pub id: MyId, #[serde(flatten)] pub timestamps: Timestamps, // ... other fields } ```",
  "properties": {
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "updated_at": {
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "created_at",
    "updated_at"
  ],
  "title": "Timestamps",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/Weave.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A Weave is the raw user input - their message to Familiar",
  "properties": {
    "context": {
      "description": "Optional context provided with the message",
      "type": [
        "string",
        "null"
      ]
    },
    "raw_content": {
      "description": "The raw text content from the user",
      "type": "string"
    }
  },
  "required": [
    "raw_content"
  ],
  "title": "Weave",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/WeaveUnit.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "WeaveUnitClassification": {
      "description": "Classification result for a weave unit (determines which entity type to spawn)",
      "properties": {
        "entity_type": {
          "allOf": [
            {
              "$ref": "../primitives/HeddleEntityType.schema.json"
            }
          ],
          "description": "The entity type this unit may become"
        },
        "weight": {
          "allOf": [
            {
              "$ref": "../primitives/NormalizedFloat.schema.json"
            }
          ],
          "description": "Confidence weight (0.0 to 1.0)"
        }
      },
      "required": [
        "entity_type",
        "weight"
      ],
      "type": "object"
    }
  },
  "description": "A WeaveUnit is a single segment extracted from a Weave. It's a transient container used for classification routing. Physics are extracted by the LLM but passed directly to spawned entities, not stored on the WeaveUnit itself.",
  "properties": {
    "classifications": {
      "default": [],
      "description": "Classifications in superposition (determines which entity types to spawn)",
      "items": {
        "$ref": "#/definitions/WeaveUnitClassification"
      },
      "type": "array"
    },
    "content": {
      "description": "The extracted/cleaned text content for this segment",
      "type": "string"
    },
    "index": {
      "description": "Index of this unit within the shuttle (0-based)",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "primary_thread": {
      "description": "Primary thread: the main subject/actor of this unit Used for entity resolution (Stitch) downstream",
      "type": [
        "string",
        "null"
      ]
    },
    "purpose": {
      "allOf": [
        {
          "$ref": "../primitives/MessageIntent.schema.json"
        }
      ],
      "default": "LOG",
      "description": "Purpose of this specific unit (LOG, QUERY, COMMAND, INFER, REFERENCE) Determines how this unit is processed - only LOG units spawn entities"
    },
    "secondary_threads": {
      "description": "Secondary threads: other people/places/things mentioned Allows capturing companions, locations, etc.",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "spawned_entity_ids": {
      "default": [],
      "description": "IDs of entities spawned from this unit (the actual simulation objects)",
      "items": {
        "$ref": "../primitives/UUID.schema.json"
      },
      "type": "array"
    },
    "temporal_marker": {
      "description": "Temporal marker: when this event/state occurred Can be absolute (\"6pm\"), relative (\"today\"), or frequency (\"once per hour\")",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "content",
    "index"
  ],
  "title": "WeaveUnit",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/WeaveUnitClassification.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Classification result for a weave unit (determines which entity type to spawn)",
  "properties": {
    "entity_type": {
      "allOf": [
        {
          "$ref": "../primitives/HeddleEntityType.schema.json"
        }
      ],
      "description": "The entity type this unit may become"
    },
    "weight": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "Confidence weight (0.0 to 1.0)"
    }
  },
  "required": [
    "entity_type",
    "weight"
  ],
  "title": "WeaveUnitClassification",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/components/WeightedClassification.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A weighted classification representing the probability/confidence that a segment belongs to a specific entity type. Part of the Superposition model - a single thought can be multiple things.",
  "properties": {
    "entity_type": {
      "allOf": [
        {
          "$ref": "../primitives/HeddleEntityType.schema.json"
        }
      ],
      "description": "The entity type this classification refers to"
    },
    "weight": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "Confidence/Weight (0.0 to 1.0) If > Threshold during collapse, we instantiate this entity."
    }
  },
  "required": [
    "entity_type",
    "weight"
  ],
  "title": "WeightedClassification",
  "type": "object",
  "x-familiar-kind": "component",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/Bond.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Core identity component that all entities possess",
  "properties": {
    "amplitude": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Amplitude (Mass):** The strength of the field excitation. High Amplitude: Core Beliefs, Long-term Memories. Hard to annihilate. Low Amplitude: Fleeting thoughts. Easily absorbed back into the vacuum."
    },
    "bond_strength": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "The overall strength or health of the bond. 0.0 = Broken/Weak, 1.0 = Strong/Healthy"
    },
    "created_at": {
      "allOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        }
      ],
      "description": "When this entity was created"
    },
    "damping_coefficient": {
      "description": "The 'inertia' of the bond, representing how quickly it returns to equilibrium. Higher values = slower return to rest (lingering effects). Lower values = quick recovery (resilient).",
      "format": "double",
      "type": "number"
    },
    "energy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Energy (Activation):** The current potential/kinetic energy of the excitation."
    },
    "formalism": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Formalism (Transactionalism / Spring Stiffness):** 1.0 = Rigid/Brittle (High k). Hard to move, snaps if stretched. 0.0 = Fluid/Elastic (Low k). Easy to stretch, adapts to change."
    },
    "head_thread_id": {
      "$ref": "../primitives/UUID.schema.json"
    },
    "id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Unique identifier for this entity"
    },
    "intimacy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Intimacy (Communal Strength / Rest Length):** 1.0 = Fusion (Rest Length 0). The entities want to occupy the same space. 0.0 = Estrangement (Max Rest Length)."
    },
    "metadata": {
      "additionalProperties": {
        "type": "string"
      },
      "type": "object"
    },
    "position": {
      "description": "The location in the 3D VAE Manifold where the field is excited",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    },
    "power_dynamic": {
      "allOf": [
        {
          "$ref": "../primitives/SignedNormalizedFloat.schema.json"
        }
      ],
      "description": "**Power Dynamic (Authority Gradient / Mass Bias):** -1.0 = Target is the Anchor (Infinite Mass relative to Source). 0.0 = Equal Mass (Both move equally). +1.0 = Source is the Anchor."
    },
    "primary_label": {
      "type": [
        "string",
        "null"
      ]
    },
    "spectral_signature": {
      "description": "**Color Filter (Spectral Gating):** If set, this bond only \"lights up\" under specific emotional light. e.g., A \"Work Friend\" bond might only reflect \"Professional\" (Blue) light. Stored as a hex code or vector for the shader.",
      "items": {
        "format": "float",
        "type": "number"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": [
        "array",
        "null"
      ]
    },
    "spring_constant": {
      "description": "The 'stiffness' of the bond, representing its resistance to change. Higher values = more rigid relationship (breaks under stress). Lower values = more flexible relationship (stretches without breaking).",
      "format": "double",
      "type": "number"
    },
    "tail_thread_id": {
      "$ref": "../primitives/UUID.schema.json"
    },
    "temperature": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Temperature (Volatility):** Internal kinetic energy of the field at this point. High Temp: The field vibrates (High uncertainty/plasticity). Low Temp: The field is frozen (Crystallized/Immutable)."
    },
    "tenant_id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Tenant (family/user) this entity belongs to"
    },
    "text": {
      "type": "string"
    },
    "transparency": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Transparency (Refractive Index):** 1.0 = Clear. Looking at the Source reveals the Target (e.g., \"Honest\"). 0.0 = Opaque. The relationship hides the Target (e.g., \"Secretive\")."
    },
    "velocity": {
      "description": "The rate of change of the field amplitude at this location (Cognitive Drift)",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    }
  },
  "required": [
    "amplitude",
    "bond_strength",
    "created_at",
    "damping_coefficient",
    "energy",
    "formalism",
    "head_thread_id",
    "id",
    "intimacy",
    "metadata",
    "position",
    "power_dynamic",
    "spring_constant",
    "tail_thread_id",
    "temperature",
    "tenant_id",
    "text",
    "transparency",
    "velocity"
  ],
  "title": "Bond",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/ChannelType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "Personal",
    "Family",
    "Shared"
  ],
  "title": "ChannelType",
  "type": "string",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/ConsentType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "TermsOfService",
    "PrivacyPolicy",
    "MarketingEmails",
    "AiProcessing",
    "DataSharing",
    "Analytics"
  ],
  "title": "ConsentType",
  "type": "string",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/ConversationThread.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AgentMessageType": {
      "description": "Agent message types for different response formats\n\nThe agentic system can produce various types of responses depending on what the agent is doing. This enum captures all possible message types.",
      "oneOf": [
        {
          "description": "A log message from the agent (debugging, status updates)",
          "properties": {
            "content": {
              "type": "string"
            },
            "level": {
              "$ref": "#/definitions/LogLevel"
            },
            "message_type": {
              "enum": [
                "log"
              ],
              "type": "string"
            }
          },
          "required": [
            "content",
            "level",
            "message_type"
          ],
          "type": "object"
        },
        {
          "description": "A question the agent is asking the user",
          "properties": {
            "message_type": {
              "enum": [
                "question"
              ],
              "type": "string"
            },
            "options": {
              "default": null,
              "items": {
                "type": "string"
              },
              "type": [
                "array",
                "null"
              ]
            },
            "prompt": {
              "type": "string"
            }
          },
          "required": [
            "message_type",
            "prompt"
          ],
          "type": "object"
        },
        {
          "description": "An insight derived by the agent",
          "properties": {
            "confidence": {
              "format": "double",
              "type": "number"
            },
            "domain": {
              "default": null,
              "type": [
                "string",
                "null"
              ]
            },
            "message_type": {
              "enum": [
                "insight"
              ],
              "type": "string"
            },
            "summary": {
              "type": "string"
            }
          },
          "required": [
            "confidence",
            "message_type",
            "summary"
          ],
          "type": "object"
        },
        {
          "description": "A detailed analysis result",
          "properties": {
            "domain": {
              "type": "string"
            },
            "findings": {
              "items": {
                "$ref": "#/definitions/Finding"
              },
              "type": "array"
            },
            "message_type": {
              "enum": [
                "analysis"
              ],
              "type": "string"
            }
          },
          "required": [
            "domain",
            "findings",
            "message_type"
          ],
          "type": "object"
        },
        {
          "description": "A command/action the agent wants to execute",
          "properties": {
            "action": {
              "type": "string"
            },
            "message_type": {
              "enum": [
                "command"
              ],
              "type": "string"
            },
            "parameters": true
          },
          "required": [
            "action",
            "message_type",
            "parameters"
          ],
          "type": "object"
        },
        {
          "description": "A simple text response",
          "properties": {
            "content": {
              "type": "string"
            },
            "message_type": {
              "enum": [
                "text"
              ],
              "type": "string"
            }
          },
          "required": [
            "content",
            "message_type"
          ],
          "type": "object"
        },
        {
          "description": "Progress update during long-running tasks",
          "properties": {
            "message": {
              "type": "string"
            },
            "message_type": {
              "enum": [
                "progress"
              ],
              "type": "string"
            },
            "percent_complete": {
              "default": null,
              "format": "double",
              "type": [
                "number",
                "null"
              ]
            }
          },
          "required": [
            "message",
            "message_type"
          ],
          "type": "object"
        }
      ]
    },
    "Finding": {
      "description": "A finding from an analysis agent",
      "properties": {
        "confidence": {
          "default": null,
          "description": "Confidence score (0.0 to 1.0)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "description": {
          "description": "Detailed description",
          "type": "string"
        },
        "related_entities": {
          "default": [],
          "description": "Related entity IDs",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "title": {
          "description": "Title or label of the finding",
          "type": "string"
        }
      },
      "required": [
        "description",
        "title"
      ],
      "type": "object"
    },
    "LogLevel": {
      "description": "Log level for agent log messages",
      "enum": [
        "debug",
        "info",
        "warning",
        "error"
      ],
      "type": "string"
    },
    "ThreadMessage": {
      "description": "A single message within a conversation thread",
      "properties": {
        "agent_speaker": {
          "default": null,
          "description": "Which agent sent this message (if role is Assistant)",
          "type": [
            "string",
            "null"
          ]
        },
        "content": {
          "default": null,
          "description": "Text content of the message",
          "type": [
            "string",
            "null"
          ]
        },
        "id": {
          "description": "Unique message ID",
          "format": "uuid",
          "type": "string"
        },
        "message_type": {
          "anyOf": [
            {
              "$ref": "#/definitions/AgentMessageType"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Structured message type (for agent messages)"
        },
        "metadata": {
          "default": null,
          "description": "Optional metadata"
        },
        "role": {
          "allOf": [
            {
              "$ref": "../primitives/MessageRole.schema.json"
            }
          ],
          "description": "Role of the message sender"
        },
        "thread_id": {
          "description": "ID of the thread this message belongs to",
          "format": "uuid",
          "type": "string"
        },
        "timestamp": {
          "description": "When the message was created",
          "format": "date-time",
          "type": "string"
        }
      },
      "required": [
        "id",
        "role",
        "thread_id",
        "timestamp"
      ],
      "type": "object"
    }
  },
  "description": "A conversation thread (Slack-like linear threading)\n\nEach thread starts with a user message and contains all responses and follow-up messages in a linear sequence.",
  "properties": {
    "created_at": {
      "description": "When the thread was created",
      "format": "date-time",
      "type": "string"
    },
    "id": {
      "$ref": "../primitives/ThreadId.schema.json"
    },
    "is_open": {
      "description": "Whether the thread is still active/open",
      "type": "boolean"
    },
    "messages": {
      "description": "All messages in the thread (in chronological order)",
      "items": {
        "$ref": "#/definitions/ThreadMessage"
      },
      "type": "array"
    },
    "metadata": {
      "default": null,
      "description": "Optional metadata"
    },
    "parent_message_id": {
      "description": "ID of the original user message that started the thread",
      "format": "uuid",
      "type": "string"
    },
    "summary": {
      "default": null,
      "description": "Summary of the thread (for display in lists)",
      "type": [
        "string",
        "null"
      ]
    },
    "tenant_id": {
      "$ref": "../primitives/TenantId.schema.json"
    },
    "updated_at": {
      "description": "When the thread was last updated",
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "created_at",
    "id",
    "is_open",
    "messages",
    "parent_message_id",
    "tenant_id",
    "updated_at"
  ],
  "title": "ConversationThread",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/Course.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "CourseMessage": {
      "description": "A single message within a Course's history\n\nThis is an immutable record of what was said. The Course history is append-only - messages are never modified or deleted.",
      "properties": {
        "agent_speaker": {
          "default": null,
          "description": "Which agent sent this message (if role is Assistant)",
          "type": [
            "string",
            "null"
          ]
        },
        "content": {
          "default": null,
          "description": "Text content of the message",
          "type": [
            "string",
            "null"
          ]
        },
        "course_id": {
          "allOf": [
            {
              "$ref": "../primitives/UUID.schema.json"
            }
          ],
          "description": "ID of the course this message belongs to"
        },
        "id": {
          "allOf": [
            {
              "$ref": "../primitives/UUID.schema.json"
            }
          ],
          "description": "Unique message ID"
        },
        "metadata": {
          "default": null,
          "description": "Optional metadata"
        },
        "role": {
          "allOf": [
            {
              "$ref": "../primitives/MessageRole.schema.json"
            }
          ],
          "description": "Role of the message sender"
        },
        "shuttle_id": {
          "anyOf": [
            {
              "$ref": "../primitives/UUID.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ID of the Shuttle that processed this message (for tracing)"
        },
        "timestamp": {
          "allOf": [
            {
              "$ref": "../primitives/Timestamp.schema.json"
            }
          ],
          "description": "When the message was created"
        }
      },
      "required": [
        "course_id",
        "id",
        "role",
        "timestamp"
      ],
      "type": "object"
    },
    "CourseMetadata": {
      "description": "Session-level metadata for a Course\n\nThis is for persistent, session-scoped information. Processing metadata (provider, model, latency) belongs on the Shuttle.",
      "properties": {
        "custom": {
          "description": "Custom user metadata"
        },
        "is_pinned": {
          "default": false,
          "description": "Whether this course is pinned/starred",
          "type": "boolean"
        },
        "preferred_language": {
          "description": "User's preferred language",
          "type": [
            "string",
            "null"
          ]
        },
        "tags": {
          "description": "Tags for organization",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "tokenizer_hint": {
          "description": "Model-specific tokenizer hint (e.g., \"cl100k_base\" for Claude/GPT-4) Used to select the appropriate token counter",
          "type": [
            "string",
            "null"
          ]
        },
        "total_history_tokens": {
          "default": 0,
          "description": "Total tokens in history (cached for fast pruning decisions) Updated on each commit_message() call",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "ui_theme": {
          "description": "UI theme preference",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "CourseStatus": {
      "description": "Session status for a Course\n\nThe Course is a persistent session/history bucket. Processing states (Segmenting, Classifying, etc.) belong on the Shuttle.\n\nCourse status reflects whether the session is: - Idle: No active processing - Active: Currently being processed by a Shuttle - Archived: Closed/completed, read-only",
      "oneOf": [
        {
          "description": "Session is idle, no active processing",
          "enum": [
            "idle"
          ],
          "type": "string"
        },
        {
          "description": "Session is active, a Shuttle is processing",
          "enum": [
            "active"
          ],
          "type": "string"
        },
        {
          "description": "Session is archived/closed",
          "enum": [
            "archived"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "A Course is a persistent session tracking conversation history\n\nThe Course is the \"history bucket\" in the Loom Pattern. It: - Owns the conversation history (append-only) - Tracks session status (idle, active, archived) - Survives across Shuttle processing cycles - Has a 1:N relationship with Shuttles\n\nThe Course does NOT contain: - Transient processing state (that's on Shuttle) - Current weave/input (that's on Shuttle) - Processing metadata like provider/model (that's on Shuttle)",
  "properties": {
    "created_at": {
      "allOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        }
      ],
      "description": "When this course was created"
    },
    "history": {
      "default": [],
      "description": "Message history (append-only, immutable during processing)",
      "items": {
        "$ref": "#/definitions/CourseMessage"
      },
      "type": "array"
    },
    "id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Unique identifier for this course"
    },
    "metadata": {
      "allOf": [
        {
          "$ref": "#/definitions/CourseMetadata"
        }
      ],
      "default": {
        "is_pinned": false,
        "total_history_tokens": 0
      },
      "description": "Session-level metadata"
    },
    "status": {
      "allOf": [
        {
          "$ref": "#/definitions/CourseStatus"
        }
      ],
      "description": "Session status (Idle, Active, Archived)"
    },
    "summary": {
      "description": "AI-generated summary",
      "type": [
        "string",
        "null"
      ]
    },
    "tenant_id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Tenant (family/user) this course belongs to"
    },
    "title": {
      "description": "Optional title for the course",
      "type": [
        "string",
        "null"
      ]
    },
    "updated_at": {
      "allOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        }
      ],
      "description": "When this course was last updated (message added)"
    }
  },
  "required": [
    "created_at",
    "id",
    "status",
    "tenant_id",
    "updated_at"
  ],
  "title": "Course",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/EntityStatus.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "Pending",
    "Approved",
    "Rejected",
    "AutoSpawned"
  ],
  "title": "EntityStatus",
  "type": "string",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/FamiliarEntityType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "Moment",
    "Pulse",
    "Intent",
    "Thread",
    "Bond",
    "Motif",
    "Filament",
    "Focus"
  ],
  "title": "FamiliarEntityType",
  "type": "string",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/Filament.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A recurring internal pattern (Self/Identity). The continuous phase trajectory of the user through the manifold.",
  "properties": {
    "amplitude": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Amplitude (Mass):** The strength of the field excitation. High Amplitude: Core Beliefs, Long-term Memories. Hard to annihilate. Low Amplitude: Fleeting thoughts. Easily absorbed back into the vacuum."
    },
    "amplitudes": {
      "description": "The \"Wavefunction\" or \"Hologram\" of the entity. Stored as a list of (Real, Imaginary) tuples. This represents Amplitude (Magnitude) and Phase (Angle).\n\nIn a Vector DB, this is flattened to [Re1, Im1, Re2, Im2...].",
      "items": {
        "items": [
          {
            "format": "double",
            "type": "number"
          },
          {
            "format": "double",
            "type": "number"
          }
        ],
        "maxItems": 2,
        "minItems": 2,
        "type": "array"
      },
      "type": "array"
    },
    "coherence": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "How \"sharp\" the wave is (0.0 = Cloud/Vague, 1.0 = Particle/Fact). Low coherence allows for \"Tunneling\" (associative leaps)."
    },
    "created_at": {
      "allOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        }
      ],
      "description": "When this entity was created"
    },
    "energy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Energy (Activation):** The current potential/kinetic energy of the excitation."
    },
    "frequency": {
      "description": "The dominant frequency of the pattern (for Holonomic resonance).",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Unique identifier for this entity"
    },
    "metadata": {
      "additionalProperties": {
        "type": "string"
      },
      "type": "object"
    },
    "position": {
      "description": "The location in the 3D VAE Manifold where the field is excited",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    },
    "source_pulses": {
      "description": "The source pulses (internal states) that form this strand.",
      "items": {
        "$ref": "../primitives/UUID.schema.json"
      },
      "type": "array"
    },
    "temperature": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Temperature (Volatility):** Internal kinetic energy of the field at this point. High Temp: The field vibrates (High uncertainty/plasticity). Low Temp: The field is frozen (Crystallized/Immutable)."
    },
    "tenant_id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Tenant (family/user) this entity belongs to"
    },
    "text": {
      "type": "string"
    },
    "velocity": {
      "description": "The rate of change of the field amplitude at this location (Cognitive Drift)",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    }
  },
  "required": [
    "amplitude",
    "amplitudes",
    "coherence",
    "created_at",
    "energy",
    "id",
    "metadata",
    "position",
    "source_pulses",
    "temperature",
    "tenant_id",
    "text",
    "velocity"
  ],
  "title": "Filament",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/Focus.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A user-declared thematic goal or life chapter. Acts as a \"Attractor Basin\" in the VAE manifold.",
  "properties": {
    "active_since": {
      "$ref": "../primitives/Timestamp.schema.json"
    },
    "amplitude": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Amplitude (Mass):** The strength of the field excitation. High Amplitude: Core Beliefs, Long-term Memories. Hard to annihilate. Low Amplitude: Fleeting thoughts. Easily absorbed back into the vacuum."
    },
    "amplitudes": {
      "description": "The \"Wavefunction\" or \"Hologram\" of the entity. Stored as a list of (Real, Imaginary) tuples. This represents Amplitude (Magnitude) and Phase (Angle).\n\nIn a Vector DB, this is flattened to [Re1, Im1, Re2, Im2...].",
      "items": {
        "items": [
          {
            "format": "double",
            "type": "number"
          },
          {
            "format": "double",
            "type": "number"
          }
        ],
        "maxItems": 2,
        "minItems": 2,
        "type": "array"
      },
      "type": "array"
    },
    "coherence": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "How \"sharp\" the wave is (0.0 = Cloud/Vague, 1.0 = Particle/Fact). Low coherence allows for \"Tunneling\" (associative leaps)."
    },
    "created_at": {
      "allOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        }
      ],
      "description": "When this entity was created"
    },
    "energy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Energy (Activation):** The current potential/kinetic energy of the excitation."
    },
    "frequency": {
      "description": "The dominant frequency of the pattern (for Holonomic resonance).",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Unique identifier for this entity"
    },
    "metadata": {
      "additionalProperties": {
        "type": "string"
      },
      "type": "object"
    },
    "position": {
      "description": "The location in the 3D VAE Manifold where the field is excited",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    },
    "temperature": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Temperature (Volatility):** Internal kinetic energy of the field at this point. High Temp: The field vibrates (High uncertainty/plasticity). Low Temp: The field is frozen (Crystallized/Immutable)."
    },
    "tenant_id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Tenant (family/user) this entity belongs to"
    },
    "text": {
      "type": "string"
    },
    "velocity": {
      "description": "The rate of change of the field amplitude at this location (Cognitive Drift)",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    }
  },
  "required": [
    "active_since",
    "amplitude",
    "amplitudes",
    "coherence",
    "created_at",
    "energy",
    "id",
    "metadata",
    "position",
    "temperature",
    "tenant_id",
    "text",
    "velocity"
  ],
  "title": "Focus",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/Intent.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A specific, bounded future action with potential energy.",
  "properties": {
    "activation_energy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Activation Energy (Invested Work)** Thermodynamics: The cumulative work performed on the system. Used to calculate \"Sunk Cost\" gravity."
    },
    "amplitude": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Amplitude (Mass):** The strength of the field excitation. High Amplitude: Core Beliefs, Long-term Memories. Hard to annihilate. Low Amplitude: Fleeting thoughts. Easily absorbed back into the vacuum."
    },
    "completion": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Completion (Inverse Discrepancy)** Cybernetics: 1.0 - Error Signal. How close the system is to the Goal State."
    },
    "created_at": {
      "allOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        }
      ],
      "description": "When this entity was created"
    },
    "energy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Energy (Activation):** The current potential/kinetic energy of the excitation."
    },
    "entropy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Entropy (Disorder)** Information Theory: The uncertainty or \"noise\" in the process. High Entropy: Exploring, Brainstorming, Chaotic. Low Entropy: Executing, Refined, Linear."
    },
    "id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Unique identifier for this entity"
    },
    "metadata": {
      "additionalProperties": {
        "type": "string"
      },
      "type": "object"
    },
    "position": {
      "description": "The location in the 3D VAE Manifold where the field is excited",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    },
    "primary_status_label": {
      "type": [
        "string",
        "null"
      ]
    },
    "target_date": {
      "anyOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        },
        {
          "type": "null"
        }
      ]
    },
    "temperature": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Temperature (Volatility):** Internal kinetic energy of the field at this point. High Temp: The field vibrates (High uncertainty/plasticity). Low Temp: The field is frozen (Crystallized/Immutable)."
    },
    "tenant_id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Tenant (family/user) this entity belongs to"
    },
    "text": {
      "type": "string"
    },
    "velocity": {
      "description": "The rate of change of the field amplitude at this location (Cognitive Drift)",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    }
  },
  "required": [
    "activation_energy",
    "amplitude",
    "completion",
    "created_at",
    "energy",
    "entropy",
    "id",
    "metadata",
    "position",
    "temperature",
    "tenant_id",
    "text",
    "velocity"
  ],
  "title": "Intent",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/InviteRole.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "Admin",
    "Member",
    "Guest"
  ],
  "title": "InviteRole",
  "type": "string",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/InviteType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "Email",
    "Code"
  ],
  "title": "InviteType",
  "type": "string",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/JoinRequestStatus.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "Pending",
    "Approved",
    "Rejected"
  ],
  "title": "JoinRequestStatus",
  "type": "string",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/MagicLinkPurpose.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "Login",
    "Signup",
    "VerifyEmail",
    "PasswordReset"
  ],
  "title": "MagicLinkPurpose",
  "type": "string",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/MemberRole.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "Admin",
    "Member",
    "Guest"
  ],
  "title": "MemberRole",
  "type": "string",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/MessageRole.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "User",
    "Assistant",
    "System"
  ],
  "title": "MessageRole",
  "type": "string",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/Model.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ChannelType": {
      "enum": [
        "Personal",
        "Family",
        "Shared"
      ],
      "type": "string"
    }
  },
  "properties": {
    "channel_type": {
      "$ref": "#/definitions/ChannelType"
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "description": {
      "type": [
        "string",
        "null"
      ]
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "name": {
      "type": "string"
    },
    "owner_id": {
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "settings": true,
    "tenant_id": {
      "$ref": "../primitives/TenantId.schema.json"
    },
    "updated_at": {
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "channel_type",
    "created_at",
    "id",
    "name",
    "settings",
    "tenant_id",
    "updated_at"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/Moment.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "MomentType": {
      "enum": [
        "Event",
        "Realization",
        "Interaction",
        "Observation"
      ],
      "type": "string"
    }
  },
  "description": "A classical entity representing a specific, objective event in the past. This is the atomic unit of episodic memory (The Particle).",
  "properties": {
    "amplitude": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Amplitude (Mass):** The strength of the field excitation. High Amplitude: Core Beliefs, Long-term Memories. Hard to annihilate. Low Amplitude: Fleeting thoughts. Easily absorbed back into the vacuum."
    },
    "amplitudes": {
      "description": "The \"Wavefunction\" or \"Hologram\" of the entity. Stored as a list of (Real, Imaginary) tuples. This represents Amplitude (Magnitude) and Phase (Angle).\n\nIn a Vector DB, this is flattened to [Re1, Im1, Re2, Im2...].",
      "items": {
        "items": [
          {
            "format": "double",
            "type": "number"
          },
          {
            "format": "double",
            "type": "number"
          }
        ],
        "maxItems": 2,
        "minItems": 2,
        "type": "array"
      },
      "type": "array"
    },
    "coherence": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "How \"sharp\" the wave is (0.0 = Cloud/Vague, 1.0 = Particle/Fact). Low coherence allows for \"Tunneling\" (associative leaps)."
    },
    "created_at": {
      "allOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        }
      ],
      "description": "When this entity was created"
    },
    "energy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Energy (Activation):** The current potential/kinetic energy of the excitation."
    },
    "frequency": {
      "description": "The dominant frequency of the pattern (for Holonomic resonance).",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Unique identifier for this entity"
    },
    "metadata": {
      "additionalProperties": {
        "type": "string"
      },
      "type": "object"
    },
    "moment_type": {
      "$ref": "#/definitions/MomentType"
    },
    "position": {
      "description": "The location in the 3D VAE Manifold where the field is excited",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    },
    "temperature": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Temperature (Volatility):** Internal kinetic energy of the field at this point. High Temp: The field vibrates (High uncertainty/plasticity). Low Temp: The field is frozen (Crystallized/Immutable)."
    },
    "tenant_id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Tenant (family/user) this entity belongs to"
    },
    "text": {
      "type": "string"
    },
    "velocity": {
      "description": "The rate of change of the field amplitude at this location (Cognitive Drift)",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    }
  },
  "required": [
    "amplitude",
    "amplitudes",
    "coherence",
    "created_at",
    "energy",
    "id",
    "metadata",
    "moment_type",
    "position",
    "temperature",
    "tenant_id",
    "text",
    "velocity"
  ],
  "title": "Moment",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/Motif.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A recurring pattern of subjective experiences (External Wave). Formed by the constructive interference of many Moments.",
  "properties": {
    "amplitude": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Amplitude (Mass):** The strength of the field excitation. High Amplitude: Core Beliefs, Long-term Memories. Hard to annihilate. Low Amplitude: Fleeting thoughts. Easily absorbed back into the vacuum."
    },
    "amplitudes": {
      "description": "The \"Wavefunction\" or \"Hologram\" of the entity. Stored as a list of (Real, Imaginary) tuples. This represents Amplitude (Magnitude) and Phase (Angle).\n\nIn a Vector DB, this is flattened to [Re1, Im1, Re2, Im2...].",
      "items": {
        "items": [
          {
            "format": "double",
            "type": "number"
          },
          {
            "format": "double",
            "type": "number"
          }
        ],
        "maxItems": 2,
        "minItems": 2,
        "type": "array"
      },
      "type": "array"
    },
    "coherence": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "How \"sharp\" the wave is (0.0 = Cloud/Vague, 1.0 = Particle/Fact). Low coherence allows for \"Tunneling\" (associative leaps)."
    },
    "created_at": {
      "allOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        }
      ],
      "description": "When this entity was created"
    },
    "energy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Energy (Activation):** The current potential/kinetic energy of the excitation."
    },
    "frequency": {
      "description": "The dominant frequency of the pattern (for Holonomic resonance).",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Unique identifier for this entity"
    },
    "metadata": {
      "additionalProperties": {
        "type": "string"
      },
      "type": "object"
    },
    "position": {
      "description": "The location in the 3D VAE Manifold where the field is excited",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    },
    "source_moments": {
      "description": "The source moments that collapsed into this pattern.",
      "items": {
        "$ref": "../primitives/UUID.schema.json"
      },
      "type": "array"
    },
    "temperature": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Temperature (Volatility):** Internal kinetic energy of the field at this point. High Temp: The field vibrates (High uncertainty/plasticity). Low Temp: The field is frozen (Crystallized/Immutable)."
    },
    "tenant_id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Tenant (family/user) this entity belongs to"
    },
    "text": {
      "type": "string"
    },
    "velocity": {
      "description": "The rate of change of the field amplitude at this location (Cognitive Drift)",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    }
  },
  "required": [
    "amplitude",
    "amplitudes",
    "coherence",
    "created_at",
    "energy",
    "id",
    "metadata",
    "position",
    "source_moments",
    "temperature",
    "tenant_id",
    "text",
    "velocity"
  ],
  "title": "Motif",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/Pulse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "InternalStateType": {
      "enum": [
        "emotional_shift",
        "realization",
        "reflection",
        "observation",
        "reaction"
      ],
      "type": "string"
    }
  },
  "description": "Core identity component that all entities possess",
  "properties": {
    "amplitude": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Amplitude (Mass):** The strength of the field excitation. High Amplitude: Core Beliefs, Long-term Memories. Hard to annihilate. Low Amplitude: Fleeting thoughts. Easily absorbed back into the vacuum."
    },
    "created_at": {
      "allOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        }
      ],
      "description": "When this entity was created"
    },
    "energy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Energy (Activation):** The current potential/kinetic energy of the excitation."
    },
    "id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Unique identifier for this entity"
    },
    "metadata": {
      "additionalProperties": {
        "type": "string"
      },
      "type": "object"
    },
    "position": {
      "description": "The location in the 3D VAE Manifold where the field is excited",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    },
    "state_type": {
      "$ref": "#/definitions/InternalStateType"
    },
    "temperature": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Temperature (Volatility):** Internal kinetic energy of the field at this point. High Temp: The field vibrates (High uncertainty/plasticity). Low Temp: The field is frozen (Crystallized/Immutable)."
    },
    "tenant_id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Tenant (family/user) this entity belongs to"
    },
    "text": {
      "type": "string"
    },
    "velocity": {
      "description": "The rate of change of the field amplitude at this location (Cognitive Drift)",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    }
  },
  "required": [
    "amplitude",
    "created_at",
    "energy",
    "id",
    "metadata",
    "position",
    "state_type",
    "temperature",
    "tenant_id",
    "text",
    "velocity"
  ],
  "title": "Pulse",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/Shuttle.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ShuttleDetails": {
      "description": "Processing metadata for a Shuttle\n\nThese are transient concerns - each Shuttle may use different providers, models, or have different latencies. This info belongs on the Shuttle, not the Course.",
      "properties": {
        "latency_ms": {
          "description": "Latency in milliseconds",
          "format": "uint64",
          "minimum": 0.0,
          "type": [
            "integer",
            "null"
          ]
        },
        "model": {
          "description": "Model used (e.g., \"claude-sonnet-4\", \"gpt-4o\")",
          "type": [
            "string",
            "null"
          ]
        },
        "provider": {
          "description": "LLM provider (e.g., \"anthropic\", \"openai\")",
          "type": [
            "string",
            "null"
          ]
        },
        "spawn_count": {
          "default": 0,
          "description": "Number of entities spawned",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "tokens_used": {
          "description": "Token usage",
          "format": "uint32",
          "minimum": 0.0,
          "type": [
            "integer",
            "null"
          ]
        },
        "unit_count": {
          "default": 0,
          "description": "Number of weave units processed",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        }
      },
      "type": "object"
    },
    "ShuttleStatus": {
      "description": "Processing status for a Shuttle",
      "oneOf": [
        {
          "description": "Segment received, not yet processed",
          "enum": [
            "pending"
          ],
          "type": "string"
        },
        {
          "description": "Currently being classified by LLM",
          "enum": [
            "classifying"
          ],
          "type": "string"
        },
        {
          "description": "Classification complete, spawning entities",
          "enum": [
            "spawning"
          ],
          "type": "string"
        },
        {
          "description": "All processing complete",
          "enum": [
            "complete"
          ],
          "type": "string"
        },
        {
          "description": "Processing failed",
          "enum": [
            "failed"
          ],
          "type": "string"
        }
      ]
    },
    "Weave": {
      "description": "A Weave is the raw user input - their message to Familiar",
      "properties": {
        "context": {
          "description": "Optional context provided with the message",
          "type": [
            "string",
            "null"
          ]
        },
        "raw_content": {
          "description": "The raw text content from the user",
          "type": "string"
        }
      },
      "required": [
        "raw_content"
      ],
      "type": "object"
    },
    "WeaveUnit": {
      "description": "A WeaveUnit is a single segment extracted from a Weave. It's a transient container used for classification routing. Physics are extracted by the LLM but passed directly to spawned entities, not stored on the WeaveUnit itself.",
      "properties": {
        "classifications": {
          "default": [],
          "description": "Classifications in superposition (determines which entity types to spawn)",
          "items": {
            "$ref": "#/definitions/WeaveUnitClassification"
          },
          "type": "array"
        },
        "content": {
          "description": "The extracted/cleaned text content for this segment",
          "type": "string"
        },
        "index": {
          "description": "Index of this unit within the shuttle (0-based)",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "primary_thread": {
          "description": "Primary thread: the main subject/actor of this unit Used for entity resolution (Stitch) downstream",
          "type": [
            "string",
            "null"
          ]
        },
        "purpose": {
          "allOf": [
            {
              "$ref": "../primitives/MessageIntent.schema.json"
            }
          ],
          "default": "LOG",
          "description": "Purpose of this specific unit (LOG, QUERY, COMMAND, INFER, REFERENCE) Determines how this unit is processed - only LOG units spawn entities"
        },
        "secondary_threads": {
          "description": "Secondary threads: other people/places/things mentioned Allows capturing companions, locations, etc.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "spawned_entity_ids": {
          "default": [],
          "description": "IDs of entities spawned from this unit (the actual simulation objects)",
          "items": {
            "$ref": "../primitives/UUID.schema.json"
          },
          "type": "array"
        },
        "temporal_marker": {
          "description": "Temporal marker: when this event/state occurred Can be absolute (\"6pm\"), relative (\"today\"), or frequency (\"once per hour\")",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "content",
        "index"
      ],
      "type": "object"
    },
    "WeaveUnitClassification": {
      "description": "Classification result for a weave unit (determines which entity type to spawn)",
      "properties": {
        "entity_type": {
          "allOf": [
            {
              "$ref": "../primitives/HeddleEntityType.schema.json"
            }
          ],
          "description": "The entity type this unit may become"
        },
        "weight": {
          "allOf": [
            {
              "$ref": "../primitives/NormalizedFloat.schema.json"
            }
          ],
          "description": "Confidence weight (0.0 to 1.0)"
        }
      },
      "required": [
        "entity_type",
        "weight"
      ],
      "type": "object"
    }
  },
  "description": "A Shuttle is the transient unit of work in the Loom Pattern\n\nEach user message creates a new Shuttle: 1. Shuttle receives the Weave (user input) 2. Shuttle segments the Weave into WeaveUnits 3. Shuttle processes through the Fates pipeline 4. Shuttle commits results to Course history 5. Shuttle is marked complete (persisted only for debugging)\n\nThe Course (history) is immutable during processing. Only the Shuttle state changes as work progresses.",
  "properties": {
    "completed_at": {
      "anyOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "description": "When processing completed (or failed)"
    },
    "course_id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Reference to the parent Course (the tether to history)"
    },
    "created_at": {
      "allOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        }
      ],
      "description": "When this shuttle was created"
    },
    "details": {
      "allOf": [
        {
          "$ref": "#/definitions/ShuttleDetails"
        }
      ],
      "description": "Processing metadata (provider, model, latency)"
    },
    "error": {
      "description": "Error message if shuttle failed",
      "type": [
        "string",
        "null"
      ]
    },
    "id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Unique identifier for this shuttle"
    },
    "response": {
      "description": "The final response (before committing to Course)",
      "type": [
        "string",
        "null"
      ]
    },
    "started_at": {
      "anyOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "description": "When this shuttle started processing"
    },
    "status": {
      "allOf": [
        {
          "$ref": "#/definitions/ShuttleStatus"
        }
      ],
      "description": "Processing status"
    },
    "units": {
      "default": [],
      "description": "The weave units (segments) being carried",
      "items": {
        "$ref": "#/definitions/WeaveUnit"
      },
      "type": "array"
    },
    "weave": {
      "allOf": [
        {
          "$ref": "#/definitions/Weave"
        }
      ],
      "description": "The specific message being processed (the \"cargo\")"
    }
  },
  "required": [
    "course_id",
    "created_at",
    "details",
    "id",
    "status",
    "weave"
  ],
  "title": "Shuttle",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/Thread.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ThreadType": {
      "enum": [
        "Person",
        "Place",
        "Concept",
        "GenericObject"
      ],
      "type": "string"
    }
  },
  "description": "Core identity component that all entities possess",
  "properties": {
    "amplitude": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Amplitude (Mass):** The strength of the field excitation. High Amplitude: Core Beliefs, Long-term Memories. Hard to annihilate. Low Amplitude: Fleeting thoughts. Easily absorbed back into the vacuum."
    },
    "amplitudes": {
      "description": "The \"Wavefunction\" or \"Hologram\" of the entity. Stored as a list of (Real, Imaginary) tuples. This represents Amplitude (Magnitude) and Phase (Angle).\n\nIn a Vector DB, this is flattened to [Re1, Im1, Re2, Im2...].",
      "items": {
        "items": [
          {
            "format": "double",
            "type": "number"
          },
          {
            "format": "double",
            "type": "number"
          }
        ],
        "maxItems": 2,
        "minItems": 2,
        "type": "array"
      },
      "type": "array"
    },
    "coherence": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "How \"sharp\" the wave is (0.0 = Cloud/Vague, 1.0 = Particle/Fact). Low coherence allows for \"Tunneling\" (associative leaps)."
    },
    "created_at": {
      "allOf": [
        {
          "$ref": "../primitives/Timestamp.schema.json"
        }
      ],
      "description": "When this entity was created"
    },
    "energy": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Energy (Activation):** The current potential/kinetic energy of the excitation."
    },
    "frequency": {
      "description": "The dominant frequency of the pattern (for Holonomic resonance).",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Unique identifier for this entity"
    },
    "metadata": {
      "additionalProperties": {
        "type": "string"
      },
      "type": "object"
    },
    "position": {
      "description": "The location in the 3D VAE Manifold where the field is excited",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    },
    "temperature": {
      "allOf": [
        {
          "$ref": "../primitives/NormalizedFloat.schema.json"
        }
      ],
      "description": "**Temperature (Volatility):** Internal kinetic energy of the field at this point. High Temp: The field vibrates (High uncertainty/plasticity). Low Temp: The field is frozen (Crystallized/Immutable)."
    },
    "tenant_id": {
      "allOf": [
        {
          "$ref": "../primitives/UUID.schema.json"
        }
      ],
      "description": "Tenant (family/user) this entity belongs to"
    },
    "text": {
      "type": "string"
    },
    "thread_type": {
      "$ref": "#/definitions/ThreadType"
    },
    "velocity": {
      "description": "The rate of change of the field amplitude at this location (Cognitive Drift)",
      "items": {
        "$ref": "../primitives/QuantizedCoord.schema.json"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    }
  },
  "required": [
    "amplitude",
    "amplitudes",
    "coherence",
    "created_at",
    "energy",
    "id",
    "metadata",
    "position",
    "temperature",
    "tenant_id",
    "text",
    "thread_type",
    "velocity"
  ],
  "title": "Thread",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/ThreadMessage.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AgentMessageType": {
      "description": "Agent message types for different response formats\n\nThe agentic system can produce various types of responses depending on what the agent is doing. This enum captures all possible message types.",
      "oneOf": [
        {
          "description": "A log message from the agent (debugging, status updates)",
          "properties": {
            "content": {
              "type": "string"
            },
            "level": {
              "$ref": "#/definitions/LogLevel"
            },
            "message_type": {
              "enum": [
                "log"
              ],
              "type": "string"
            }
          },
          "required": [
            "content",
            "level",
            "message_type"
          ],
          "type": "object"
        },
        {
          "description": "A question the agent is asking the user",
          "properties": {
            "message_type": {
              "enum": [
                "question"
              ],
              "type": "string"
            },
            "options": {
              "default": null,
              "items": {
                "type": "string"
              },
              "type": [
                "array",
                "null"
              ]
            },
            "prompt": {
              "type": "string"
            }
          },
          "required": [
            "message_type",
            "prompt"
          ],
          "type": "object"
        },
        {
          "description": "An insight derived by the agent",
          "properties": {
            "confidence": {
              "format": "double",
              "type": "number"
            },
            "domain": {
              "default": null,
              "type": [
                "string",
                "null"
              ]
            },
            "message_type": {
              "enum": [
                "insight"
              ],
              "type": "string"
            },
            "summary": {
              "type": "string"
            }
          },
          "required": [
            "confidence",
            "message_type",
            "summary"
          ],
          "type": "object"
        },
        {
          "description": "A detailed analysis result",
          "properties": {
            "domain": {
              "type": "string"
            },
            "findings": {
              "items": {
                "$ref": "#/definitions/Finding"
              },
              "type": "array"
            },
            "message_type": {
              "enum": [
                "analysis"
              ],
              "type": "string"
            }
          },
          "required": [
            "domain",
            "findings",
            "message_type"
          ],
          "type": "object"
        },
        {
          "description": "A command/action the agent wants to execute",
          "properties": {
            "action": {
              "type": "string"
            },
            "message_type": {
              "enum": [
                "command"
              ],
              "type": "string"
            },
            "parameters": true
          },
          "required": [
            "action",
            "message_type",
            "parameters"
          ],
          "type": "object"
        },
        {
          "description": "A simple text response",
          "properties": {
            "content": {
              "type": "string"
            },
            "message_type": {
              "enum": [
                "text"
              ],
              "type": "string"
            }
          },
          "required": [
            "content",
            "message_type"
          ],
          "type": "object"
        },
        {
          "description": "Progress update during long-running tasks",
          "properties": {
            "message": {
              "type": "string"
            },
            "message_type": {
              "enum": [
                "progress"
              ],
              "type": "string"
            },
            "percent_complete": {
              "default": null,
              "format": "double",
              "type": [
                "number",
                "null"
              ]
            }
          },
          "required": [
            "message",
            "message_type"
          ],
          "type": "object"
        }
      ]
    },
    "Finding": {
      "description": "A finding from an analysis agent",
      "properties": {
        "confidence": {
          "default": null,
          "description": "Confidence score (0.0 to 1.0)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "description": {
          "description": "Detailed description",
          "type": "string"
        },
        "related_entities": {
          "default": [],
          "description": "Related entity IDs",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "title": {
          "description": "Title or label of the finding",
          "type": "string"
        }
      },
      "required": [
        "description",
        "title"
      ],
      "type": "object"
    },
    "LogLevel": {
      "description": "Log level for agent log messages",
      "enum": [
        "debug",
        "info",
        "warning",
        "error"
      ],
      "type": "string"
    }
  },
  "description": "A single message within a conversation thread",
  "properties": {
    "agent_speaker": {
      "default": null,
      "description": "Which agent sent this message (if role is Assistant)",
      "type": [
        "string",
        "null"
      ]
    },
    "content": {
      "default": null,
      "description": "Text content of the message",
      "type": [
        "string",
        "null"
      ]
    },
    "id": {
      "$ref": "../primitives/ThreadId.schema.json"
    },
    "message_type": {
      "anyOf": [
        {
          "$ref": "#/definitions/AgentMessageType"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Structured message type (for agent messages)"
    },
    "metadata": {
      "default": null,
      "description": "Optional metadata"
    },
    "role": {
      "allOf": [
        {
          "$ref": "../primitives/MessageRole.schema.json"
        }
      ],
      "description": "Role of the message sender"
    },
    "thread_id": {
      "$ref": "../primitives/ThreadId.schema.json"
    },
    "timestamp": {
      "description": "When the message was created",
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "id",
    "role",
    "thread_id",
    "timestamp"
  ],
  "title": "ThreadMessage",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/entities/ThreadSummary.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Summary of a thread for list views",
  "properties": {
    "id": {
      "$ref": "../primitives/ThreadId.schema.json"
    },
    "is_open": {
      "description": "Whether thread is open",
      "type": "boolean"
    },
    "message_count": {
      "description": "Number of messages",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "preview": {
      "description": "Preview text (truncated first message)",
      "type": "string"
    },
    "updated_at": {
      "description": "Last updated timestamp",
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "id",
    "is_open",
    "message_count",
    "preview",
    "updated_at"
  ],
  "title": "ThreadSummary",
  "type": "object",
  "x-familiar-kind": "entity",
  "x-familiar-persistence": "postgres",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/AIProvider.schema.json

```json
{
  "$id": "primitives/AIProvider.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "AI Provider enumeration",
  "enum": [
    "openai",
    "anthropic",
    "google",
    "mock"
  ],
  "title": "AIProvider",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ApiKey.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A secure wrapper for API keys that prevents accidental logging.",
  "title": "ApiKey",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/AuditLogId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A unique identifier for audit log entries",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "AuditLogId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/BindingType.schema.json

```json
{
  "$id": "primitives/BindingType.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of cognitive binding",
  "oneOf": [
    {
      "description": "Cause leads to effect",
      "enum": [
        "causal"
      ],
      "type": "string"
    },
    {
      "description": "Temporal sequence (before/after)",
      "enum": [
        "temporal"
      ],
      "type": "string"
    },
    {
      "description": "Associated by proximity/context",
      "enum": [
        "associative"
      ],
      "type": "string"
    },
    {
      "description": "Part-whole relationship",
      "enum": [
        "compositional"
      ],
      "type": "string"
    },
    {
      "description": "Contrast/opposition",
      "enum": [
        "contrastive"
      ],
      "type": "string"
    },
    {
      "description": "Similarity/analogy",
      "enum": [
        "analogical"
      ],
      "type": "string"
    },
    {
      "description": "Enables/prerequisite",
      "enum": [
        "enabling"
      ],
      "type": "string"
    },
    {
      "description": "Thematic connection",
      "enum": [
        "thematic"
      ],
      "type": "string"
    }
  ],
  "title": "BindingType",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/BlockElement.schema.json

```json
{
  "$id": "primitives/BlockElement.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "oneOf": [
    {
      "properties": {
        "action_id": {
          "type": "string"
        },
        "style": {
          "anyOf": [
            {
              "$ref": "#/definitions/ButtonStyle"
            },
            {
              "type": "null"
            }
          ]
        },
        "text": {
          "$ref": "#/definitions/PlainTextObject"
        },
        "type": {
          "enum": [
            "button"
          ],
          "type": "string"
        },
        "url": {
          "type": [
            "string",
            "null"
          ]
        },
        "value": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "action_id",
        "text",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "alt_text": {
          "type": "string"
        },
        "image_url": {
          "type": "string"
        },
        "type": {
          "enum": [
            "image"
          ],
          "type": "string"
        }
      },
      "required": [
        "alt_text",
        "image_url",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "action_id": {
          "type": "string"
        },
        "options": {
          "items": {
            "$ref": "#/definitions/OptionObject"
          },
          "type": "array"
        },
        "type": {
          "enum": [
            "overflow"
          ],
          "type": "string"
        }
      },
      "required": [
        "action_id",
        "options",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "action_id": {
          "type": "string"
        },
        "initial_value": {
          "type": [
            "string",
            "null"
          ]
        },
        "multiline": {
          "default": false,
          "type": "boolean"
        },
        "placeholder": {
          "anyOf": [
            {
              "$ref": "#/definitions/PlainTextObject"
            },
            {
              "type": "null"
            }
          ]
        },
        "type": {
          "enum": [
            "plain_text_input"
          ],
          "type": "string"
        }
      },
      "required": [
        "action_id",
        "type"
      ],
      "type": "object"
    }
  ],
  "title": "BlockElement",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ButtonStyle.schema.json

```json
{
  "$id": "primitives/ButtonStyle.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "primary",
    "danger"
  ],
  "title": "ButtonStyle",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ChannelId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A channel's unique identifier",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "ChannelId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ConsentRecordId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A unique identifier for consent records",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "ConsentRecordId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ContextElement.schema.json

```json
{
  "$id": "primitives/ContextElement.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "oneOf": [
    {
      "properties": {
        "alt_text": {
          "type": "string"
        },
        "image_url": {
          "type": "string"
        },
        "type": {
          "enum": [
            "image"
          ],
          "type": "string"
        }
      },
      "required": [
        "alt_text",
        "image_url",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "text": {
          "type": "string"
        },
        "type": {
          "enum": [
            "mrkdwn"
          ],
          "type": "string"
        },
        "verbatim": {
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "text",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "emoji": {
          "default": false,
          "type": "boolean"
        },
        "text": {
          "type": "string"
        },
        "type": {
          "enum": [
            "plain_text"
          ],
          "type": "string"
        }
      },
      "required": [
        "text",
        "type"
      ],
      "type": "object"
    }
  ],
  "title": "ContextElement",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ConversationTurn.schema.json

```json
{
  "$id": "primitives/ConversationTurn.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A single turn in a conversation (for context tracking)",
  "properties": {
    "content": {
      "description": "Content of the message",
      "type": "string"
    },
    "role": {
      "description": "Role of the speaker (user, assistant, system)",
      "type": "string"
    },
    "speaker": {
      "default": null,
      "description": "Optional speaker identifier (for multi-agent)",
      "type": [
        "string",
        "null"
      ]
    },
    "timestamp": {
      "default": null,
      "description": "Timestamp of the turn",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "content",
    "role"
  ],
  "title": "ConversationTurn",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/CourseId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A course (workflow instance) unique identifier",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "CourseId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/DbConnectionString.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A validated PostgreSQL/TimescaleDB connection string",
  "title": "DbConnectionString",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/DbPoolSize.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Connection pool size configuration",
  "format": "uint32",
  "minimum": 0.0,
  "title": "DbPoolSize",
  "type": "integer",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/DeletionRequestId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A unique identifier for data deletion requests",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "DeletionRequestId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/Directionality.schema.json

```json
{
  "$id": "primitives/Directionality.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Directionality of binding",
  "oneOf": [
    {
      "description": "Only source  target",
      "enum": [
        "unidirectional"
      ],
      "type": "string"
    },
    {
      "description": "Both directions",
      "enum": [
        "bidirectional"
      ],
      "type": "string"
    },
    {
      "description": "No inherent direction",
      "enum": [
        "undirected"
      ],
      "type": "string"
    }
  ],
  "title": "Directionality",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/Email.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "String",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/EmotionalTone.schema.json

```json
{
  "$id": "primitives/EmotionalTone.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Emotional tone detected in segment",
  "properties": {
    "arousal": {
      "description": "Arousal (0.0 calm to 1.0 excited)",
      "format": "double",
      "type": "number"
    },
    "confidence": {
      "description": "Confidence in detection",
      "format": "double",
      "type": "number"
    },
    "primary": {
      "description": "Primary emotion",
      "type": "string"
    },
    "valence": {
      "description": "Valence (-1.0 negative to 1.0 positive)",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "arousal",
    "confidence",
    "primary",
    "valence"
  ],
  "title": "EmotionalTone",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/EntityId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A unique identifier for entities",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "EntityId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/EntityMention.schema.json

```json
{
  "$id": "primitives/EntityMention.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "An entity mention within a segment",
  "properties": {
    "confidence": {
      "description": "Confidence in detection",
      "format": "double",
      "type": "number"
    },
    "end": {
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "entity_type": {
      "allOf": [
        {
          "$ref": "#/definitions/EntityMentionType"
        }
      ],
      "description": "Type of entity mentioned"
    },
    "resolved_id": {
      "default": null,
      "description": "Resolved entity ID (if matched to known entity)",
      "type": [
        "string",
        "null"
      ]
    },
    "start": {
      "description": "Position in segment",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "text": {
      "description": "The text of the mention",
      "type": "string"
    }
  },
  "required": [
    "confidence",
    "end",
    "entity_type",
    "start",
    "text"
  ],
  "title": "EntityMention",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/EntityMentionType.schema.json

```json
{
  "$id": "primitives/EntityMentionType.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of entity mentions",
  "enum": [
    "PERSON",
    "PLACE",
    "ORGANIZATION",
    "DATE_TIME",
    "EVENT",
    "CONCEPT",
    "OBJECT",
    "ACTIVITY"
  ],
  "title": "EntityMentionType",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/EntityType.schema.json

```json
{
  "$id": "primitives/EntityType.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Entity types from the Symmetric Seven ontology",
  "oneOf": [
    {
      "description": "A specific event/action that happened (Narrative/External Particle) Linguistic marker: Action verbs (went, did, met, called)",
      "enum": [
        "MOMENT"
      ],
      "type": "string"
    },
    {
      "description": "Internal state/feeling/emotion (Internal Particle) Linguistic marker: State verbs + evaluative language (felt, was nice)",
      "enum": [
        "PULSE"
      ],
      "type": "string"
    },
    {
      "description": "Definition of person, place, or concept (Definitional/Object)",
      "enum": [
        "THREAD"
      ],
      "type": "string"
    },
    {
      "description": "Relationship between entities (Relational/Connection)",
      "enum": [
        "BOND"
      ],
      "type": "string"
    },
    {
      "description": "A recurring external pattern (External Wave)",
      "enum": [
        "MOTIF"
      ],
      "type": "string"
    },
    {
      "description": "A recurring internal pattern (Internal Wave)",
      "enum": [
        "FILAMENT"
      ],
      "type": "string"
    },
    {
      "description": "An active thematic goal (Intentional Wave)",
      "enum": [
        "FOCUS"
      ],
      "type": "string"
    },
    {
      "description": "A task or goal for the future (Operational/Intentional Particle)",
      "enum": [
        "INTENT"
      ],
      "type": "string"
    }
  ],
  "title": "EntityType",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ExportRequestId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A unique identifier for data export requests",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "ExportRequestId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/HeddleEntityType.schema.json

```json
{
  "$id": "primitives/HeddleEntityType.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "The fundamental Entity Types recognized by The Heddle Classification Engine. These map to the Symmetric Seven ontology.",
  "oneOf": [
    {
      "description": "A specific event that happened in the past (Narrative/External Particle)",
      "enum": [
        "MOMENT"
      ],
      "type": "string"
    },
    {
      "description": "A task or goal for the future (Operational/Intentional Particle)",
      "enum": [
        "INTENT"
      ],
      "type": "string"
    },
    {
      "description": "A definition of a person, place, or concept (Definitional/Object)",
      "enum": [
        "THREAD"
      ],
      "type": "string"
    },
    {
      "description": "A statement about the quality of a relationship (Relational/Connection)",
      "enum": [
        "BOND"
      ],
      "type": "string"
    },
    {
      "description": "A recurring external pattern (External Wave)",
      "enum": [
        "MOTIF"
      ],
      "type": "string"
    },
    {
      "description": "A recurring internal pattern (Internal Wave)",
      "enum": [
        "FILAMENT"
      ],
      "type": "string"
    },
    {
      "description": "An active thematic goal (Intentional Wave)",
      "enum": [
        "FOCUS"
      ],
      "type": "string"
    },
    {
      "description": "An internal state snapshot (Internal Particle)",
      "enum": [
        "PULSE"
      ],
      "type": "string"
    }
  ],
  "title": "HeddleEntityType",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/InvitationId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A unique identifier for family invitations",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "InvitationId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/InviteCode.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "String",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/InviteRole.schema.json

```json
{
  "$id": "primitives/InviteRole.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Role to assign when invitation is accepted",
  "enum": [
    "admin",
    "member",
    "guest"
  ],
  "title": "InviteRole",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/JoinRequestId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A unique identifier for join requests",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "JoinRequestId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/MagicLinkId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A unique identifier for magic links",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "MagicLinkId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/MaxTokens.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Maximum number of tokens for input/output",
  "format": "uint32",
  "minimum": 0.0,
  "title": "MaxTokens",
  "type": "integer",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/MessageId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A message's unique identifier",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "MessageId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/MessageIntent.schema.json

```json
{
  "$id": "primitives/MessageIntent.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "The primary intent of the user's message",
  "oneOf": [
    {
      "description": "Recording something - events, states, observations (current default)",
      "enum": [
        "LOG"
      ],
      "type": "string"
    },
    {
      "description": "Asking a question - wants information back",
      "enum": [
        "QUERY"
      ],
      "type": "string"
    },
    {
      "description": "Requesting system to make connections or derive insights",
      "enum": [
        "INFER"
      ],
      "type": "string"
    },
    {
      "description": "Looking up specific entities, threads, or past entries",
      "enum": [
        "REFERENCE"
      ],
      "type": "string"
    },
    {
      "description": "Requesting analysis, patterns, or reflection on data",
      "enum": [
        "REFLECT"
      ],
      "type": "string"
    },
    {
      "description": "Giving a command/instruction to the system",
      "enum": [
        "COMMAND"
      ],
      "type": "string"
    },
    {
      "description": "Conversational/social - greetings, acknowledgments",
      "enum": [
        "SOCIAL"
      ],
      "type": "string"
    }
  ],
  "title": "MessageIntent",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/MessageRole.schema.json

```json
{
  "$id": "primitives/MessageRole.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Role in a chat conversation",
  "oneOf": [
    {
      "description": "System instructions",
      "enum": [
        "system"
      ],
      "type": "string"
    },
    {
      "description": "User input",
      "enum": [
        "user"
      ],
      "type": "string"
    },
    {
      "description": "Assistant response",
      "enum": [
        "assistant"
      ],
      "type": "string"
    }
  ],
  "title": "MessageRole",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/Modality.schema.json

```json
{
  "$id": "primitives/Modality.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Supported input modalities",
  "enum": [
    "text",
    "audio",
    "vision",
    "video"
  ],
  "title": "Modality",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/NormalizedFloat.schema.json

```json
{
  "$id": "primitives/NormalizedFloat.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A float value normalized to [0.0, 1.0]",
  "format": "double",
  "title": "NormalizedFloat",
  "type": "number",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/OptionObject.schema.json

```json
{
  "$id": "primitives/OptionObject.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "description": {
      "anyOf": [
        {
          "$ref": "#/definitions/PlainTextObject"
        },
        {
          "type": "null"
        }
      ]
    },
    "text": {
      "$ref": "#/definitions/PlainTextObject"
    },
    "url": {
      "type": [
        "string",
        "null"
      ]
    },
    "value": {
      "type": "string"
    }
  },
  "required": [
    "text",
    "value"
  ],
  "title": "OptionObject",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ParsedTemporal.schema.json

```json
{
  "$id": "primitives/ParsedTemporal.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Parsed temporal information",
  "properties": {
    "date": {
      "default": null,
      "description": "ISO 8601 date if specific",
      "type": [
        "string",
        "null"
      ]
    },
    "relative_days": {
      "default": null,
      "description": "Relative offset (e.g., -1 for \"yesterday\")",
      "format": "int32",
      "type": [
        "integer",
        "null"
      ]
    },
    "time_of_day": {
      "default": null,
      "description": "Time of day if mentioned",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "title": "ParsedTemporal",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/PasswordHash.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "String",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/PlainTextObject.schema.json

```json
{
  "$id": "primitives/PlainTextObject.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "emoji": {
      "default": false,
      "type": "boolean"
    },
    "text": {
      "type": "string"
    }
  },
  "required": [
    "text"
  ],
  "title": "PlainTextObject",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/QuantizedCoord.schema.json

```json
{
  "$id": "primitives/QuantizedCoord.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A quantized coordinate in the 3D VAE Manifold Uses i64 for precision in physics calculations",
  "format": "int64",
  "title": "QuantizedCoord",
  "type": "integer",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/QueryTarget.schema.json

```json
{
  "$id": "primitives/QueryTarget.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Query target - what data is the query looking for?",
  "properties": {
    "entity_types": {
      "default": [],
      "description": "The entity/thread types being queried (e.g., \"moments\", \"threads\", \"pulses\")",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "keywords": {
      "default": [],
      "description": "Keywords extracted from the query",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "temporal_scope": {
      "default": null,
      "description": "Temporal scope (e.g., \"today\", \"last week\", \"all time\")",
      "type": [
        "string",
        "null"
      ]
    },
    "thread_hints": {
      "default": [],
      "description": "Specific thread hints (names, concepts) to search for",
      "items": {
        "type": "string"
      },
      "type": "array"
    }
  },
  "title": "QueryTarget",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/QueryType.schema.json

```json
{
  "$id": "primitives/QueryType.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "The type of query (when MessageIntent is QUERY)",
  "oneOf": [
    {
      "description": "When did X happen? Time-based lookup",
      "enum": [
        "TEMPORAL"
      ],
      "type": "string"
    },
    {
      "description": "Who/what questions - entity lookup",
      "enum": [
        "ENTITY"
      ],
      "type": "string"
    },
    {
      "description": "How often? Pattern/frequency questions",
      "enum": [
        "PATTERN"
      ],
      "type": "string"
    },
    {
      "description": "Compare X and Y",
      "enum": [
        "COMPARISON"
      ],
      "type": "string"
    },
    {
      "description": "Give me a summary/overview",
      "enum": [
        "SUMMARY"
      ],
      "type": "string"
    },
    {
      "description": "Count/quantity questions (how many?)",
      "enum": [
        "QUANTITATIVE"
      ],
      "type": "string"
    },
    {
      "description": "Yes/no questions (did X happen?)",
      "enum": [
        "BOOLEAN"
      ],
      "type": "string"
    },
    {
      "description": "Why questions - causation",
      "enum": [
        "CAUSAL"
      ],
      "type": "string"
    },
    {
      "description": "Location-based questions",
      "enum": [
        "SPATIAL"
      ],
      "type": "string"
    },
    {
      "description": "Open-ended/exploratory",
      "enum": [
        "EXPLORATORY"
      ],
      "type": "string"
    }
  ],
  "title": "QueryType",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/RelationshipType.schema.json

```json
{
  "$id": "primitives/RelationshipType.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of relationships",
  "enum": [
    "family",
    "friend",
    "close_friend",
    "best_friend",
    "romantic",
    "ex_romantic",
    "spouse",
    "parent",
    "child",
    "sibling",
    "colleague",
    "manager",
    "direct_report",
    "mentor",
    "mentee",
    "client",
    "vendor",
    "partner",
    "acquaintance",
    "neighbor",
    "classmate",
    "teammate",
    "adversary",
    "rival",
    "service_provider",
    "other"
  ],
  "title": "RelationshipType",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/RetryConfig.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Configuration for retry behavior on transient failures",
  "properties": {
    "backoff_factor": {
      "format": "double",
      "type": "number"
    },
    "initial_delay_ms": {
      "format": "uint64",
      "minimum": 0.0,
      "type": "integer"
    },
    "max_delay_ms": {
      "format": "uint64",
      "minimum": 0.0,
      "type": "integer"
    },
    "max_retries": {
      "format": "uint32",
      "minimum": 0.0,
      "type": "integer"
    }
  },
  "required": [
    "backoff_factor",
    "initial_delay_ms",
    "max_delay_ms",
    "max_retries"
  ],
  "title": "RetryConfig",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/Segment.schema.json

```json
{
  "$id": "primitives/Segment.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A segmented unit of content",
  "properties": {
    "boundaries": {
      "allOf": [
        {
          "$ref": "#/definitions/SegmentBoundaries"
        }
      ],
      "description": "Segment boundaries"
    },
    "confidence": {
      "description": "Confidence in segmentation decision",
      "format": "double",
      "type": "number"
    },
    "content": {
      "description": "The segmented content",
      "type": "string"
    },
    "features": {
      "allOf": [
        {
          "$ref": "#/definitions/SegmentFeatures"
        }
      ],
      "description": "Extracted features"
    },
    "id": {
      "description": "Unique segment ID",
      "type": "string"
    },
    "index": {
      "description": "Index in the sequence",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "modality": {
      "allOf": [
        {
          "$ref": "#/definitions/Modality"
        }
      ],
      "description": "Original modality"
    }
  },
  "required": [
    "boundaries",
    "confidence",
    "content",
    "features",
    "id",
    "index",
    "modality"
  ],
  "title": "Segment",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/SegmentBoundaries.schema.json

```json
{
  "$id": "primitives/SegmentBoundaries.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Boundaries of a segment within the original input",
  "properties": {
    "end": {
      "description": "End position",
      "format": "uint64",
      "minimum": 0.0,
      "type": "integer"
    },
    "speaker_id": {
      "default": null,
      "description": "For audio/video: speaker ID if detected",
      "type": [
        "string",
        "null"
      ]
    },
    "start": {
      "description": "Start position (char index for text, milliseconds for audio/video)",
      "format": "uint64",
      "minimum": 0.0,
      "type": "integer"
    }
  },
  "required": [
    "end",
    "start"
  ],
  "title": "SegmentBoundaries",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/SegmentFeatures.schema.json

```json
{
  "$id": "primitives/SegmentFeatures.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Extracted features from a segment",
  "properties": {
    "emotional_tone": {
      "anyOf": [
        {
          "$ref": "#/definitions/EmotionalTone"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Emotional tone (if detectable)"
    },
    "keywords": {
      "default": [],
      "description": "Keywords extracted",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "language": {
      "default": null,
      "description": "Language detected",
      "type": [
        "string",
        "null"
      ]
    },
    "mentions": {
      "default": [],
      "description": "Entity mentions found",
      "items": {
        "$ref": "#/definitions/EntityMention"
      },
      "type": "array"
    },
    "subject": {
      "default": null,
      "description": "Primary subject/actor mentioned",
      "type": [
        "string",
        "null"
      ]
    },
    "temporal_markers": {
      "default": [],
      "description": "Temporal markers detected",
      "items": {
        "$ref": "#/definitions/TemporalMarker"
      },
      "type": "array"
    }
  },
  "title": "SegmentFeatures",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/SessionId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A session's unique identifier",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "SessionId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/SessionToken.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "String",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ShuttleId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A unique identifier for shuttles (response containers)",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "ShuttleId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/SignedNormalizedFloat.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A floating-point value normalized between -1.0 and 1.0. Used for polarity (Valence), alignment (Phase), and gradients.",
  "format": "double",
  "title": "SignedNormalizedFloat",
  "type": "number",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/TaskId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A unique identifier for async tasks",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "TaskId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/Temperature.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Temperature controls randomness in LLM outputs. Range: 0.0 (deterministic) to 2.0 (very random)",
  "format": "float",
  "title": "Temperature",
  "type": "number",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/TemporalMarker.schema.json

```json
{
  "$id": "primitives/TemporalMarker.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A temporal marker in the segment",
  "properties": {
    "marker_type": {
      "allOf": [
        {
          "$ref": "#/definitions/TemporalMarkerType"
        }
      ],
      "description": "Type of temporal reference"
    },
    "parsed": {
      "anyOf": [
        {
          "$ref": "#/definitions/ParsedTemporal"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Parsed temporal value (if parseable)"
    },
    "text": {
      "description": "The text of the marker",
      "type": "string"
    }
  },
  "required": [
    "marker_type",
    "text"
  ],
  "title": "TemporalMarker",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/TemporalMarkerType.schema.json

```json
{
  "$id": "primitives/TemporalMarkerType.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of temporal markers",
  "oneOf": [
    {
      "description": "Specific date (January 5th)",
      "enum": [
        "absolute"
      ],
      "type": "string"
    },
    {
      "description": "Relative reference (yesterday, last week)",
      "enum": [
        "relative"
      ],
      "type": "string"
    },
    {
      "description": "Duration (for 2 hours)",
      "enum": [
        "duration"
      ],
      "type": "string"
    },
    {
      "description": "Frequency (every day, weekly)",
      "enum": [
        "frequency"
      ],
      "type": "string"
    },
    {
      "description": "Time of day (in the morning)",
      "enum": [
        "time_of_day"
      ],
      "type": "string"
    }
  ],
  "title": "TemporalMarkerType",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/TemporalRelation.schema.json

```json
{
  "$id": "primitives/TemporalRelation.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Temporal relationships",
  "enum": [
    "before",
    "after",
    "during",
    "simultaneous",
    "overlapping"
  ],
  "title": "TemporalRelation",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/TenantId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A tenant (family) unique identifier",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "TenantId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/TextObject.schema.json

```json
{
  "$id": "primitives/TextObject.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "oneOf": [
    {
      "properties": {
        "emoji": {
          "default": false,
          "type": "boolean"
        },
        "text": {
          "type": "string"
        },
        "type": {
          "enum": [
            "plain_text"
          ],
          "type": "string"
        }
      },
      "required": [
        "text",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "text": {
          "type": "string"
        },
        "type": {
          "enum": [
            "mrkdwn"
          ],
          "type": "string"
        },
        "verbatim": {
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "text",
        "type"
      ],
      "type": "object"
    }
  ],
  "title": "TextObject",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ThreadId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A conversation thread's unique identifier",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "ThreadId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ThreadReference.schema.json

```json
{
  "$id": "primitives/ThreadReference.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Reference to an existing thread",
  "properties": {
    "aliases": {
      "default": [],
      "description": "Aliases for matching",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "id": {
      "description": "Thread ID",
      "type": "string"
    },
    "name": {
      "description": "Thread name/label",
      "type": "string"
    },
    "thread_type": {
      "description": "Thread type (person, place, concept, etc.)",
      "type": "string"
    }
  },
  "required": [
    "id",
    "name",
    "thread_type"
  ],
  "title": "ThreadReference",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ThreadRole.schema.json

```json
{
  "$id": "primitives/ThreadRole.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Role of entity relative to threads",
  "oneOf": [
    {
      "description": "Entity is the actor/doer",
      "enum": [
        "actor"
      ],
      "type": "string"
    },
    {
      "description": "Entity is the subject being discussed",
      "enum": [
        "subject"
      ],
      "type": "string"
    },
    {
      "description": "Entity is observing/witnessing",
      "enum": [
        "observer"
      ],
      "type": "string"
    },
    {
      "description": "Entity is the target of action",
      "enum": [
        "target"
      ],
      "type": "string"
    },
    {
      "description": "Entity is setting/location",
      "enum": [
        "setting"
      ],
      "type": "string"
    },
    {
      "description": "Entity is an instrument/tool",
      "enum": [
        "instrument"
      ],
      "type": "string"
    }
  ],
  "title": "ThreadRole",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/TimeGap.schema.json

```json
{
  "$id": "primitives/TimeGap.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Time gap between entities",
  "properties": {
    "approximate": {
      "description": "Is this approximate?",
      "type": "boolean"
    },
    "unit": {
      "allOf": [
        {
          "$ref": "#/definitions/TimeUnit"
        }
      ],
      "description": "Duration unit"
    },
    "value": {
      "description": "Duration value",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "approximate",
    "unit",
    "value"
  ],
  "title": "TimeGap",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/TimeUnit.schema.json

```json
{
  "$id": "primitives/TimeUnit.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Time units",
  "enum": [
    "seconds",
    "minutes",
    "hours",
    "days",
    "weeks",
    "months",
    "years"
  ],
  "title": "TimeUnit",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/Timestamp.schema.json

```json
{
  "$id": "primitives/Timestamp.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "An ISO 8601 timestamp (serialized as string)",
  "format": "date-time",
  "title": "Timestamp",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/TokenUsage.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Token usage statistics from a completion",
  "properties": {
    "completion_tokens": {
      "format": "uint32",
      "minimum": 0.0,
      "type": "integer"
    },
    "prompt_tokens": {
      "format": "uint32",
      "minimum": 0.0,
      "type": "integer"
    },
    "total_tokens": {
      "format": "uint32",
      "minimum": 0.0,
      "type": "integer"
    }
  },
  "required": [
    "completion_tokens",
    "prompt_tokens",
    "total_tokens"
  ],
  "title": "TokenUsage",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ToolCallStatus.schema.json

```json
{
  "$id": "primitives/ToolCallStatus.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Status of a tool call during execution",
  "enum": [
    "pending",
    "running",
    "complete",
    "error"
  ],
  "title": "ToolCallStatus",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/ToolPurpose.schema.json

```json
{
  "$id": "primitives/ToolPurpose.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Primary purpose of user's message",
  "oneOf": [
    {
      "description": "Recording memories, events, observations - wants to store",
      "enum": [
        "LOG"
      ],
      "type": "string"
    },
    {
      "description": "Asking a question - wants information returned",
      "enum": [
        "QUERY"
      ],
      "type": "string"
    },
    {
      "description": "Making connections, deriving insights - wants system to infer",
      "enum": [
        "INFER"
      ],
      "type": "string"
    },
    {
      "description": "Looking up specific entities - wants existing data",
      "enum": [
        "REFERENCE"
      ],
      "type": "string"
    },
    {
      "description": "Requesting analysis or reflection - wants patterns identified",
      "enum": [
        "REFLECT"
      ],
      "type": "string"
    },
    {
      "description": "System command/instruction - wants action taken",
      "enum": [
        "COMMAND"
      ],
      "type": "string"
    },
    {
      "description": "Social/conversational - greeting, acknowledgment",
      "enum": [
        "SOCIAL"
      ],
      "type": "string"
    },
    {
      "description": "Clarifying or continuing previous message",
      "enum": [
        "CONTINUATION"
      ],
      "type": "string"
    },
    {
      "description": "Editing or correcting previous input",
      "enum": [
        "CORRECTION"
      ],
      "type": "string"
    }
  ],
  "title": "ToolPurpose",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/UIClassification.schema.json

```json
{
  "$id": "primitives/UIClassification.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A classification result",
  "properties": {
    "confidence": {
      "format": "double",
      "type": "number"
    },
    "entity_type": {
      "type": "string"
    }
  },
  "required": [
    "confidence",
    "entity_type"
  ],
  "title": "UIClassification",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/UIHeddleSegment.schema.json

```json
{
  "$id": "primitives/UIHeddleSegment.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A segment from Heddle",
  "properties": {
    "content": {
      "type": "string"
    },
    "subject": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "content"
  ],
  "title": "UIHeddleSegment",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/UIPhysicsResult.schema.json

```json
{
  "$id": "primitives/UIPhysicsResult.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Physics simulation result",
  "properties": {
    "energy": {
      "format": "double",
      "type": "number"
    },
    "position": {
      "items": {
        "format": "double",
        "type": "number"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    },
    "temperature": {
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "energy",
    "position",
    "temperature"
  ],
  "title": "UIPhysicsResult",
  "type": "object",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/UUID.schema.json

```json
{
  "$id": "primitives/UUID.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A UUID (serialized as string)",
  "format": "uuid",
  "title": "UUID",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/UserId.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "A user's unique identifier",
  "examples": [
    "550e8400-e29b-41d4-a716-446655440000"
  ],
  "format": "uuid",
  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  "title": "UserId",
  "type": "string",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/primitives/VerbCategory.schema.json

```json
{
  "$id": "primitives/VerbCategory.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Categories of verbs for classification",
  "oneOf": [
    {
      "description": "Action verbs (went, did, called)  MOMENT",
      "enum": [
        "action"
      ],
      "type": "string"
    },
    {
      "description": "State verbs (was, felt, is)  often PULSE",
      "enum": [
        "state"
      ],
      "type": "string"
    },
    {
      "description": "Stative + evaluative (was nice, felt good)  PULSE",
      "enum": [
        "evaluative"
      ],
      "type": "string"
    },
    {
      "description": "Relational verbs (met, talked with)  may indicate BOND",
      "enum": [
        "relational"
      ],
      "type": "string"
    },
    {
      "description": "Habitual (always, usually does)  may indicate MOTIF/FILAMENT",
      "enum": [
        "habitual"
      ],
      "type": "string"
    },
    {
      "description": "Intentional (want to, plan to)  INTENT",
      "enum": [
        "intentional"
      ],
      "type": "string"
    }
  ],
  "title": "VerbCategory",
  "x-familiar-kind": "primitive"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/AgenticCommand.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ConversationHistoryItem": {
      "description": "A single item in conversation history",
      "properties": {
        "content": {
          "description": "Content of the message",
          "type": "string"
        },
        "role": {
          "description": "Role: \"user\" or \"assistant\"",
          "type": "string"
        }
      },
      "required": [
        "content",
        "role"
      ],
      "type": "object"
    },
    "WeaveBlock": {
      "description": "Input block types for multimodal weave requests",
      "oneOf": [
        {
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "enum": [
                "text"
              ],
              "type": "string"
            }
          },
          "required": [
            "content",
            "type"
          ],
          "type": "object"
        },
        {
          "properties": {
            "alt_text": {
              "type": [
                "string",
                "null"
              ]
            },
            "analyze": {
              "default": true,
              "description": "Request vision analysis",
              "type": "boolean"
            },
            "source": {
              "description": "base64 data URI or URL",
              "type": "string"
            },
            "type": {
              "enum": [
                "image"
              ],
              "type": "string"
            }
          },
          "required": [
            "source",
            "type"
          ],
          "type": "object"
        },
        {
          "properties": {
            "duration_secs": {
              "format": "double",
              "type": [
                "number",
                "null"
              ]
            },
            "source": {
              "type": "string"
            },
            "transcript": {
              "description": "Pre-transcribed (skip Whisper)",
              "type": [
                "string",
                "null"
              ]
            },
            "type": {
              "enum": [
                "audio"
              ],
              "type": "string"
            }
          },
          "required": [
            "source",
            "type"
          ],
          "type": "object"
        },
        {
          "properties": {
            "filename": {
              "type": [
                "string",
                "null"
              ]
            },
            "mime_type": {
              "type": [
                "string",
                "null"
              ]
            },
            "source": {
              "type": "string"
            },
            "type": {
              "enum": [
                "document"
              ],
              "type": "string"
            }
          },
          "required": [
            "source",
            "type"
          ],
          "type": "object"
        },
        {
          "properties": {
            "extract_images": {
              "default": false,
              "description": "Whether to extract images from the page",
              "type": "boolean"
            },
            "selector": {
              "description": "Optional CSS selector to extract specific content",
              "type": [
                "string",
                "null"
              ]
            },
            "type": {
              "enum": [
                "webpage"
              ],
              "type": "string"
            },
            "url": {
              "description": "URL to scrape",
              "type": "string"
            }
          },
          "required": [
            "type",
            "url"
          ],
          "type": "object"
        }
      ]
    }
  },
  "description": "Commands that can be sent to the agentic system\n\nThese commands are the primary interface for interacting with the multi-agent orchestration system. They can be sent directly via HTTP or published to a message broker.",
  "oneOf": [
    {
      "description": "Send a new message to the agentic system",
      "properties": {
        "blocks": {
          "default": null,
          "description": "Optional multimodal blocks (images, audio, etc.)",
          "items": {
            "$ref": "#/definitions/WeaveBlock"
          },
          "type": [
            "array",
            "null"
          ]
        },
        "command_type": {
          "enum": [
            "send_message"
          ],
          "type": "string"
        },
        "content": {
          "description": "Text content of the message",
          "type": "string"
        },
        "conversation_history": {
          "default": null,
          "description": "Conversation history for context",
          "items": {
            "$ref": "#/definitions/ConversationHistoryItem"
          },
          "type": [
            "array",
            "null"
          ]
        },
        "flow_path": {
          "default": null,
          "description": "Override the default flow path (e.g., \"u/phaiel/loom\")",
          "type": [
            "string",
            "null"
          ]
        },
        "request_id": {
          "description": "Request ID for tracing",
          "type": "string"
        },
        "tenant_id": {
          "description": "Tenant ID",
          "type": "string"
        },
        "thread_id": {
          "default": null,
          "description": "Thread ID (None = start new thread)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "command_type",
        "content",
        "request_id",
        "tenant_id"
      ],
      "type": "object"
    },
    {
      "description": "Continue processing in an existing thread",
      "properties": {
        "command_type": {
          "enum": [
            "continue_thread"
          ],
          "type": "string"
        },
        "request_id": {
          "description": "Request ID for tracing",
          "type": "string"
        },
        "thread_id": {
          "description": "ID of the thread to continue",
          "type": "string"
        }
      },
      "required": [
        "command_type",
        "request_id",
        "thread_id"
      ],
      "type": "object"
    },
    {
      "description": "Cancel a running task",
      "properties": {
        "command_type": {
          "enum": [
            "cancel_task"
          ],
          "type": "string"
        },
        "reason": {
          "default": null,
          "description": "Reason for cancellation",
          "type": [
            "string",
            "null"
          ]
        },
        "task_id": {
          "description": "ID of the task to cancel",
          "type": "string"
        }
      },
      "required": [
        "command_type",
        "task_id"
      ],
      "type": "object"
    },
    {
      "description": "Request thread history",
      "properties": {
        "command_type": {
          "enum": [
            "get_thread_history"
          ],
          "type": "string"
        },
        "limit": {
          "default": null,
          "description": "Maximum number of messages to return",
          "format": "uint",
          "minimum": 0.0,
          "type": [
            "integer",
            "null"
          ]
        },
        "thread_id": {
          "description": "ID of the thread",
          "type": "string"
        }
      },
      "required": [
        "command_type",
        "thread_id"
      ],
      "type": "object"
    }
  ],
  "title": "AgenticCommand",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/AgenticEvent.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AgentMessageType": {
      "description": "Agent message types for different response formats\n\nThe agentic system can produce various types of responses depending on what the agent is doing. This enum captures all possible message types.",
      "oneOf": [
        {
          "description": "A log message from the agent (debugging, status updates)",
          "properties": {
            "content": {
              "type": "string"
            },
            "level": {
              "$ref": "#/definitions/LogLevel"
            },
            "message_type": {
              "enum": [
                "log"
              ],
              "type": "string"
            }
          },
          "required": [
            "content",
            "level",
            "message_type"
          ],
          "type": "object"
        },
        {
          "description": "A question the agent is asking the user",
          "properties": {
            "message_type": {
              "enum": [
                "question"
              ],
              "type": "string"
            },
            "options": {
              "default": null,
              "items": {
                "type": "string"
              },
              "type": [
                "array",
                "null"
              ]
            },
            "prompt": {
              "type": "string"
            }
          },
          "required": [
            "message_type",
            "prompt"
          ],
          "type": "object"
        },
        {
          "description": "An insight derived by the agent",
          "properties": {
            "confidence": {
              "format": "double",
              "type": "number"
            },
            "domain": {
              "default": null,
              "type": [
                "string",
                "null"
              ]
            },
            "message_type": {
              "enum": [
                "insight"
              ],
              "type": "string"
            },
            "summary": {
              "type": "string"
            }
          },
          "required": [
            "confidence",
            "message_type",
            "summary"
          ],
          "type": "object"
        },
        {
          "description": "A detailed analysis result",
          "properties": {
            "domain": {
              "type": "string"
            },
            "findings": {
              "items": {
                "$ref": "#/definitions/Finding"
              },
              "type": "array"
            },
            "message_type": {
              "enum": [
                "analysis"
              ],
              "type": "string"
            }
          },
          "required": [
            "domain",
            "findings",
            "message_type"
          ],
          "type": "object"
        },
        {
          "description": "A command/action the agent wants to execute",
          "properties": {
            "action": {
              "type": "string"
            },
            "message_type": {
              "enum": [
                "command"
              ],
              "type": "string"
            },
            "parameters": true
          },
          "required": [
            "action",
            "message_type",
            "parameters"
          ],
          "type": "object"
        },
        {
          "description": "A simple text response",
          "properties": {
            "content": {
              "type": "string"
            },
            "message_type": {
              "enum": [
                "text"
              ],
              "type": "string"
            }
          },
          "required": [
            "content",
            "message_type"
          ],
          "type": "object"
        },
        {
          "description": "Progress update during long-running tasks",
          "properties": {
            "message": {
              "type": "string"
            },
            "message_type": {
              "enum": [
                "progress"
              ],
              "type": "string"
            },
            "percent_complete": {
              "default": null,
              "format": "double",
              "type": [
                "number",
                "null"
              ]
            }
          },
          "required": [
            "message",
            "message_type"
          ],
          "type": "object"
        }
      ]
    },
    "AgentState": {
      "description": "Global state shared across all agents in the orchestration loop\n\nThis state is passed between agents and maintains context about the current conversation, authentication status, and which agent is currently \"speaking\".",
      "properties": {
        "conversation_context": {
          "default": [],
          "description": "Conversation history for context",
          "items": {
            "$ref": "../primitives/ConversationTurn.schema.json"
          },
          "type": "array"
        },
        "current_speaker": {
          "default": null,
          "description": "Currently active speaker (None means orchestrator decides)",
          "type": [
            "string",
            "null"
          ]
        },
        "is_authenticated": {
          "default": false,
          "description": "Whether the user is authenticated",
          "type": "boolean"
        },
        "just_finished": {
          "default": false,
          "description": "Whether the current agent just finished its task",
          "type": "boolean"
        },
        "metadata": {
          "default": null,
          "description": "Custom metadata for extensibility"
        },
        "tenant_id": {
          "description": "Tenant ID for multi-tenancy",
          "type": "string"
        },
        "thread_id": {
          "default": null,
          "description": "Current thread ID (if in a thread)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "tenant_id"
      ],
      "type": "object"
    },
    "Finding": {
      "description": "A finding from an analysis agent",
      "properties": {
        "confidence": {
          "default": null,
          "description": "Confidence score (0.0 to 1.0)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "description": {
          "description": "Detailed description",
          "type": "string"
        },
        "related_entities": {
          "default": [],
          "description": "Related entity IDs",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "title": {
          "description": "Title or label of the finding",
          "type": "string"
        }
      },
      "required": [
        "description",
        "title"
      ],
      "type": "object"
    },
    "LogLevel": {
      "description": "Log level for agent log messages",
      "enum": [
        "debug",
        "info",
        "warning",
        "error"
      ],
      "type": "string"
    }
  },
  "description": "Events emitted by the agentic system\n\nThese events notify clients about state changes and results from the multi-agent system. They can be delivered via WebSocket, SSE, or consumed from a message broker.",
  "oneOf": [
    {
      "description": "A new message was received/generated",
      "properties": {
        "agent": {
          "default": null,
          "description": "Which agent sent this",
          "type": [
            "string",
            "null"
          ]
        },
        "content": {
          "default": null,
          "description": "Message content",
          "type": [
            "string",
            "null"
          ]
        },
        "event_type": {
          "enum": [
            "message_received"
          ],
          "type": "string"
        },
        "message_id": {
          "description": "Message ID",
          "type": "string"
        },
        "message_type": {
          "anyOf": [
            {
              "$ref": "#/definitions/AgentMessageType"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Structured message type"
        },
        "role": {
          "description": "Role (user, assistant, system)",
          "type": "string"
        },
        "thread_id": {
          "description": "Thread ID",
          "type": "string"
        },
        "timestamp": {
          "description": "Timestamp",
          "type": "string"
        }
      },
      "required": [
        "event_type",
        "message_id",
        "role",
        "thread_id",
        "timestamp"
      ],
      "type": "object"
    },
    {
      "description": "An agent is now speaking/processing",
      "properties": {
        "agent": {
          "description": "Which agent is speaking",
          "type": "string"
        },
        "event_type": {
          "enum": [
            "agent_speaking"
          ],
          "type": "string"
        },
        "status": {
          "default": null,
          "description": "Optional status message",
          "type": [
            "string",
            "null"
          ]
        },
        "thread_id": {
          "description": "Thread ID",
          "type": "string"
        }
      },
      "required": [
        "agent",
        "event_type",
        "thread_id"
      ],
      "type": "object"
    },
    {
      "description": "A task was completed successfully",
      "properties": {
        "event_type": {
          "enum": [
            "task_completed"
          ],
          "type": "string"
        },
        "result": {
          "description": "Result data"
        },
        "task_id": {
          "description": "Task ID (same as request_id)",
          "type": "string"
        },
        "thread_id": {
          "description": "Thread ID",
          "type": "string"
        }
      },
      "required": [
        "event_type",
        "result",
        "task_id",
        "thread_id"
      ],
      "type": "object"
    },
    {
      "description": "An error occurred",
      "properties": {
        "code": {
          "description": "Error code",
          "type": "string"
        },
        "details": {
          "default": null,
          "description": "Additional details"
        },
        "error": {
          "description": "Error message",
          "type": "string"
        },
        "event_type": {
          "enum": [
            "error"
          ],
          "type": "string"
        },
        "thread_id": {
          "default": null,
          "description": "Thread ID (if applicable)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "code",
        "error",
        "event_type"
      ],
      "type": "object"
    },
    {
      "description": "Thread state was updated",
      "properties": {
        "event_type": {
          "enum": [
            "thread_state_changed"
          ],
          "type": "string"
        },
        "state": {
          "allOf": [
            {
              "$ref": "#/definitions/AgentState"
            }
          ],
          "description": "Updated agent state"
        },
        "thread_id": {
          "description": "Thread ID",
          "type": "string"
        }
      },
      "required": [
        "event_type",
        "state",
        "thread_id"
      ],
      "type": "object"
    },
    {
      "description": "Progress update for long-running operations",
      "properties": {
        "event_type": {
          "enum": [
            "progress"
          ],
          "type": "string"
        },
        "message": {
          "description": "Progress message",
          "type": "string"
        },
        "percent": {
          "default": null,
          "description": "Percent complete (0-100)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "task_id": {
          "description": "Task ID",
          "type": "string"
        },
        "thread_id": {
          "description": "Thread ID",
          "type": "string"
        }
      },
      "required": [
        "event_type",
        "message",
        "task_id",
        "thread_id"
      ],
      "type": "object"
    }
  ],
  "title": "AgenticEvent",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/AgenticFlowResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "UIHeddleResult": {
      "description": "Structured result from the Heddle classification pipeline",
      "properties": {
        "classifications": {
          "default": [],
          "description": "Classification results",
          "items": {
            "$ref": "../primitives/UIClassification.schema.json"
          },
          "type": "array"
        },
        "physics": {
          "anyOf": [
            {
              "$ref": "../primitives/UIPhysicsResult.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Physics hints"
        },
        "purpose": {
          "default": null,
          "description": "Detected purpose/intent",
          "type": [
            "string",
            "null"
          ]
        },
        "segments": {
          "default": [],
          "description": "Segmented content",
          "items": {
            "$ref": "../primitives/UIHeddleSegment.schema.json"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "UIThinkingStep": {
      "description": "A thinking/reasoning step for chain-of-thought visibility",
      "properties": {
        "agent": {
          "description": "Which agent produced this thought",
          "type": "string"
        },
        "id": {
          "description": "Unique ID",
          "type": "string"
        },
        "thought": {
          "description": "The thought/reasoning content",
          "type": "string"
        },
        "timestamp": {
          "default": null,
          "description": "Timestamp",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "agent",
        "id",
        "thought"
      ],
      "type": "object"
    },
    "UIToolCall": {
      "description": "A tool call with real-time status updates for UI display",
      "properties": {
        "arguments": {
          "default": null,
          "description": "Arguments passed to the tool"
        },
        "id": {
          "description": "Unique ID for this tool call",
          "type": "string"
        },
        "result": {
          "default": null,
          "description": "Result from the tool"
        },
        "status": {
          "allOf": [
            {
              "$ref": "../primitives/ToolCallStatus.schema.json"
            }
          ],
          "description": "Current status"
        },
        "tool": {
          "description": "Name of the tool",
          "type": "string"
        }
      },
      "required": [
        "id",
        "status",
        "tool"
      ],
      "type": "object"
    }
  },
  "description": "Full response from the agentic Windmill flow This is what the API returns to the UI",
  "properties": {
    "agent": {
      "description": "Which agent responded",
      "type": "string"
    },
    "has_more_tasks": {
      "default": false,
      "description": "Whether there are more tasks",
      "type": "boolean"
    },
    "heddle_result": {
      "anyOf": [
        {
          "$ref": "#/definitions/UIHeddleResult"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Heddle classification result (if applicable)"
    },
    "next_request": {
      "default": null,
      "description": "Next request (if continuation needed)",
      "type": [
        "string",
        "null"
      ]
    },
    "request_id": {
      "description": "Request ID for tracing",
      "type": "string"
    },
    "response": {
      "description": "The conversational response text",
      "type": "string"
    },
    "state": {
      "default": null,
      "description": "Updated agent state"
    },
    "thinking_steps": {
      "default": [],
      "description": "Thinking steps (for chain-of-thought visibility)",
      "items": {
        "$ref": "#/definitions/UIThinkingStep"
      },
      "type": "array"
    },
    "thread_id": {
      "description": "Thread ID",
      "type": "string"
    },
    "tool_calls": {
      "default": [],
      "description": "Tool calls made",
      "items": {
        "$ref": "#/definitions/UIToolCall"
      },
      "type": "array"
    }
  },
  "required": [
    "agent",
    "request_id",
    "response",
    "thread_id"
  ],
  "title": "AgenticFlowResponse",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/ClassificationPhysics.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Physics hints extracted during classification",
  "properties": {
    "arousal": {
      "default": null,
      "description": "Activation level: 0.0 (calm) to 1.0 (activated)",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "clarity": {
      "default": null,
      "description": "How clear/specific: 0.0 (vague) to 1.0 (clear)",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "significance": {
      "default": null,
      "description": "How significant/important: 0.0 to 1.0",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "valence": {
      "default": null,
      "description": "Emotional valence: -1.0 (negative) to 1.0 (positive)",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    }
  },
  "title": "ClassificationPhysics",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/CommandResult.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Result of processing a command",
  "properties": {
    "accepted": {
      "description": "Whether the command was accepted",
      "type": "boolean"
    },
    "error": {
      "default": null,
      "description": "Error message if not accepted",
      "type": [
        "string",
        "null"
      ]
    },
    "job_id": {
      "default": null,
      "description": "Job ID for async tracking",
      "type": [
        "string",
        "null"
      ]
    },
    "thread_id": {
      "default": null,
      "description": "Thread ID (for SendMessage commands)",
      "type": [
        "string",
        "null"
      ]
    },
    "ws_url": {
      "default": null,
      "description": "WebSocket URL for streaming events",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "accepted"
  ],
  "title": "CommandResult",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/ContentClassificationResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ClassificationPhysics": {
      "description": "Physics hints extracted during classification",
      "properties": {
        "arousal": {
          "default": null,
          "description": "Activation level: 0.0 (calm) to 1.0 (activated)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "clarity": {
          "default": null,
          "description": "How clear/specific: 0.0 (vague) to 1.0 (clear)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "significance": {
          "default": null,
          "description": "How significant/important: 0.0 to 1.0",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "valence": {
          "default": null,
          "description": "Emotional valence: -1.0 (negative) to 1.0 (positive)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "SegmentClassification": {
      "description": "Classification for a single segment",
      "properties": {
        "entity_type": {
          "allOf": [
            {
              "$ref": "../primitives/HeddleEntityType.schema.json"
            }
          ],
          "description": "The entity type (MOMENT, PULSE, INTENT) - relevant for LOG purpose"
        },
        "physics": {
          "anyOf": [
            {
              "$ref": "#/definitions/ClassificationPhysics"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Physics hints for entity spawning (only for LOG purpose)"
        },
        "purpose": {
          "allOf": [
            {
              "$ref": "../primitives/MessageIntent.schema.json"
            }
          ],
          "default": "LOG",
          "description": "Purpose of this specific segment (LOG, QUERY, COMMAND, etc.) Only LOG segments spawn entities"
        },
        "segment_index": {
          "description": "Index of the segment being classified",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "weight": {
          "default": 1.0,
          "description": "Confidence weight (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "entity_type",
        "segment_index"
      ],
      "type": "object"
    }
  },
  "description": "Phase 3 response: Classifications for each segment",
  "properties": {
    "classifications": {
      "description": "Classifications for each segment",
      "items": {
        "$ref": "#/definitions/SegmentClassification"
      },
      "type": "array"
    }
  },
  "required": [
    "classifications"
  ],
  "title": "ContentClassificationResponse",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/ConversationHistoryItem.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A single item in conversation history",
  "properties": {
    "content": {
      "description": "Content of the message",
      "type": "string"
    },
    "role": {
      "description": "Role: \"user\" or \"assistant\"",
      "type": "string"
    }
  },
  "required": [
    "content",
    "role"
  ],
  "title": "ConversationHistoryItem",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/CourseStatus.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Processing status for a Course",
  "oneOf": [
    {
      "description": "User input received, not yet segmented",
      "enum": [
        "received"
      ],
      "type": "string"
    },
    {
      "description": "Segmenting the input via Heddle",
      "enum": [
        "segmenting"
      ],
      "type": "string"
    },
    {
      "description": "All shuttles are processing segments",
      "enum": [
        "processing"
      ],
      "type": "string"
    },
    {
      "description": "All shuttles complete, generating response",
      "enum": [
        "responding"
      ],
      "type": "string"
    },
    {
      "description": "Course complete with response",
      "enum": [
        "complete"
      ],
      "type": "string"
    },
    {
      "description": "Course failed",
      "enum": [
        "failed"
      ],
      "type": "string"
    }
  ],
  "title": "CourseStatus",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/CreateMemberInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "MemberRole": {
      "description": "Role of a tenant member",
      "enum": [
        "admin",
        "member",
        "guest"
      ],
      "type": "string"
    }
  },
  "description": "Input for creating a new tenant member",
  "properties": {
    "avatar_url": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "email": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "name": {
      "type": "string"
    },
    "role": {
      "anyOf": [
        {
          "$ref": "#/definitions/MemberRole"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "tenant_id": {
      "$ref": "../primitives/TenantId.schema.json"
    }
  },
  "required": [
    "name",
    "tenant_id"
  ],
  "title": "CreateMemberInput",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/CreateTenantInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Input for creating a new tenant",
  "properties": {
    "name": {
      "type": "string"
    },
    "settings": {
      "default": null
    }
  },
  "required": [
    "name"
  ],
  "title": "CreateTenantInput",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/DbComponentTable.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Component tables (hypertables for time-series, regular for static)",
  "oneOf": [
    {
      "description": "Field excitations (hypertable - time-series physics state)",
      "enum": [
        "FieldExcitations"
      ],
      "type": "string"
    },
    {
      "description": "Quantum states (vector table for embeddings)",
      "enum": [
        "QuantumStates"
      ],
      "type": "string"
    },
    {
      "description": "Content payloads",
      "enum": [
        "Content"
      ],
      "type": "string"
    },
    {
      "description": "Cognitive optics",
      "enum": [
        "CognitiveOptics"
      ],
      "type": "string"
    },
    {
      "description": "Relational dynamics",
      "enum": [
        "RelationalDynamics"
      ],
      "type": "string"
    },
    {
      "description": "Bond physics",
      "enum": [
        "BondPhysics"
      ],
      "type": "string"
    },
    {
      "description": "Task dynamics",
      "enum": [
        "TaskDynamics"
      ],
      "type": "string"
    }
  ],
  "title": "DbComponentTable",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/DbEntityTable.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Entity types stored in the database",
  "enum": [
    "Pulse",
    "Thread",
    "Bond",
    "Moment",
    "Intent",
    "Focus",
    "Motif",
    "Filament"
  ],
  "title": "DbEntityTable",
  "type": "string",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/DbStoreError.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Errors that can occur during database operations",
  "oneOf": [
    {
      "description": "Connection failed",
      "properties": {
        "details": {
          "properties": {
            "message": {
              "type": "string"
            }
          },
          "required": [
            "message"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "Connection"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Query execution failed",
      "properties": {
        "details": {
          "properties": {
            "message": {
              "type": "string"
            },
            "query": {
              "type": [
                "string",
                "null"
              ]
            }
          },
          "required": [
            "message"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "Query"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Entity not found",
      "properties": {
        "details": {
          "properties": {
            "entity_type": {
              "type": "string"
            },
            "id": {
              "type": "string"
            }
          },
          "required": [
            "entity_type",
            "id"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "NotFound"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Constraint violation (unique, foreign key, etc.)",
      "properties": {
        "details": {
          "properties": {
            "message": {
              "type": "string"
            }
          },
          "required": [
            "message"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "Constraint"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Serialization/deserialization error",
      "properties": {
        "details": {
          "properties": {
            "message": {
              "type": "string"
            }
          },
          "required": [
            "message"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "Serialization"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Transaction failed",
      "properties": {
        "details": {
          "properties": {
            "message": {
              "type": "string"
            }
          },
          "required": [
            "message"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "Transaction"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Migration error",
      "properties": {
        "details": {
          "properties": {
            "message": {
              "type": "string"
            }
          },
          "required": [
            "message"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "Migration"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Operation failed (e.g. S3/MinIO)",
      "properties": {
        "details": {
          "properties": {
            "message": {
              "type": "string"
            }
          },
          "required": [
            "message"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "Operation"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    }
  ],
  "title": "DbStoreError",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/HeddleEntityType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "The fundamental Entity Types recognized by The Heddle Classification Engine. These map to the Symmetric Seven ontology.",
  "oneOf": [
    {
      "description": "A specific event that happened in the past (Narrative/External Particle)",
      "enum": [
        "MOMENT"
      ],
      "type": "string"
    },
    {
      "description": "A task or goal for the future (Operational/Intentional Particle)",
      "enum": [
        "INTENT"
      ],
      "type": "string"
    },
    {
      "description": "A definition of a person, place, or concept (Definitional/Object)",
      "enum": [
        "THREAD"
      ],
      "type": "string"
    },
    {
      "description": "A statement about the quality of a relationship (Relational/Connection)",
      "enum": [
        "BOND"
      ],
      "type": "string"
    },
    {
      "description": "A recurring external pattern (External Wave)",
      "enum": [
        "MOTIF"
      ],
      "type": "string"
    },
    {
      "description": "A recurring internal pattern (Internal Wave)",
      "enum": [
        "FILAMENT"
      ],
      "type": "string"
    },
    {
      "description": "An active thematic goal (Intentional Wave)",
      "enum": [
        "FOCUS"
      ],
      "type": "string"
    },
    {
      "description": "An internal state snapshot (Internal Particle)",
      "enum": [
        "PULSE"
      ],
      "type": "string"
    }
  ],
  "title": "HeddleEntityType",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/HeddleResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "RawClassification": {
      "description": "Raw classification from LLM output",
      "properties": {
        "entity_type": {
          "$ref": "../primitives/HeddleEntityType.schema.json"
        },
        "weight": {
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "entity_type",
        "weight"
      ],
      "type": "object"
    },
    "RawMessageIntent": {
      "description": "Raw message intent classification from LLM",
      "properties": {
        "confidence": {
          "default": 1.0,
          "description": "Confidence in classification (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "intent": {
          "allOf": [
            {
              "$ref": "../primitives/MessageIntent.schema.json"
            }
          ],
          "description": "Primary intent (LOG, QUERY, INFER, REFERENCE, REFLECT, COMMAND, SOCIAL)"
        },
        "query_target": {
          "anyOf": [
            {
              "$ref": "../primitives/QueryTarget.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "description": "If QUERY: what entities/threads are being queried"
        },
        "query_type": {
          "anyOf": [
            {
              "$ref": "../primitives/QueryType.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "description": "If QUERY: what type of query"
        }
      },
      "required": [
        "intent"
      ],
      "type": "object"
    },
    "RawPhysicsHint": {
      "description": "Raw physics hints from LLM (will be applied to spawned entities)",
      "properties": {
        "arousal": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "clarity": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "intrusiveness": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "significance": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "valence": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "volatility": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "RawWeaveUnit": {
      "description": "Raw weave unit from LLM output (before validation)",
      "properties": {
        "classifications": {
          "description": "Classifications in superposition",
          "items": {
            "$ref": "#/definitions/RawClassification"
          },
          "type": "array"
        },
        "content": {
          "description": "The extracted/cleaned text content for this weave unit",
          "type": "string"
        },
        "physics_hint": {
          "anyOf": [
            {
              "$ref": "#/definitions/RawPhysicsHint"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Physics hints (passed to spawned entities, not stored on WeaveUnit)"
        },
        "primary_thread": {
          "default": null,
          "description": "Primary thread: the main subject/actor of this unit",
          "type": [
            "string",
            "null"
          ]
        },
        "purpose": {
          "allOf": [
            {
              "$ref": "../primitives/MessageIntent.schema.json"
            }
          ],
          "default": "LOG",
          "description": "Purpose of this specific unit (LOG, QUERY, COMMAND, etc.) Only LOG units spawn entities"
        },
        "secondary_threads": {
          "default": null,
          "description": "Secondary threads: other people/places/things mentioned",
          "items": {
            "type": "string"
          },
          "type": [
            "array",
            "null"
          ]
        },
        "temporal_marker": {
          "default": null,
          "description": "Temporal marker: when this happened (absolute, relative, or frequency) Examples: \"6pm\", \"today\", \"yesterday\", \"once per hour\", \"every morning\"",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "classifications",
        "content"
      ],
      "type": "object"
    }
  },
  "description": "The full response from the Heddle LLM",
  "properties": {
    "message_intent": {
      "allOf": [
        {
          "$ref": "#/definitions/RawMessageIntent"
        }
      ],
      "default": {
        "confidence": 1.0,
        "intent": "LOG"
      },
      "description": "Message intent classification (WHAT is user trying to do?)"
    },
    "weave_units": {
      "default": [],
      "description": "Array of weave units extracted from the input (for LOG intent) May be empty for QUERY/REFERENCE intents",
      "items": {
        "$ref": "#/definitions/RawWeaveUnit"
      },
      "type": "array"
    }
  },
  "title": "HeddleResponse",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/InternalStateType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "emotional_shift",
    "realization",
    "reflection",
    "observation",
    "reaction"
  ],
  "title": "InternalStateType",
  "type": "string",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/MemberRole.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Role of a tenant member",
  "enum": [
    "admin",
    "member",
    "guest"
  ],
  "title": "MemberRole",
  "type": "string",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/MessageClassification.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Complete message classification (intent + optional details)",
  "properties": {
    "confidence": {
      "description": "Confidence in the classification (0.0 to 1.0)",
      "format": "double",
      "type": "number"
    },
    "intent": {
      "allOf": [
        {
          "$ref": "../primitives/MessageIntent.schema.json"
        }
      ],
      "description": "Primary intent of the message"
    },
    "query_target": {
      "anyOf": [
        {
          "$ref": "../primitives/QueryTarget.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "description": "If QUERY, what data is being requested"
    },
    "query_type": {
      "anyOf": [
        {
          "$ref": "../primitives/QueryType.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "description": "If QUERY, what type of query"
    },
    "secondary_intents": {
      "description": "Alternative intents that might also apply",
      "items": {
        "items": [
          {
            "$ref": "../primitives/MessageIntent.schema.json"
          },
          {
            "format": "double",
            "type": "number"
          }
        ],
        "maxItems": 2,
        "minItems": 2,
        "type": "array"
      },
      "type": "array"
    }
  },
  "required": [
    "confidence",
    "intent"
  ],
  "title": "MessageClassification",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/MessageIntent.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "The primary intent of the user's message",
  "oneOf": [
    {
      "description": "Recording something - events, states, observations (current default)",
      "enum": [
        "LOG"
      ],
      "type": "string"
    },
    {
      "description": "Asking a question - wants information back",
      "enum": [
        "QUERY"
      ],
      "type": "string"
    },
    {
      "description": "Requesting system to make connections or derive insights",
      "enum": [
        "INFER"
      ],
      "type": "string"
    },
    {
      "description": "Looking up specific entities, threads, or past entries",
      "enum": [
        "REFERENCE"
      ],
      "type": "string"
    },
    {
      "description": "Requesting analysis, patterns, or reflection on data",
      "enum": [
        "REFLECT"
      ],
      "type": "string"
    },
    {
      "description": "Giving a command/instruction to the system",
      "enum": [
        "COMMAND"
      ],
      "type": "string"
    },
    {
      "description": "Conversational/social - greetings, acknowledgments",
      "enum": [
        "SOCIAL"
      ],
      "type": "string"
    }
  ],
  "title": "MessageIntent",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/MessageRole.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Role in a chat conversation",
  "oneOf": [
    {
      "description": "System instructions",
      "enum": [
        "system"
      ],
      "type": "string"
    },
    {
      "description": "User input",
      "enum": [
        "user"
      ],
      "type": "string"
    },
    {
      "description": "Assistant response",
      "enum": [
        "assistant"
      ],
      "type": "string"
    }
  ],
  "title": "MessageRole",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/MessageStatusType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Message delivery status",
  "enum": [
    "sending",
    "sent",
    "delivered",
    "read",
    "failed"
  ],
  "title": "MessageStatusType",
  "type": "string",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/MomentType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "Event",
    "Realization",
    "Interaction",
    "Observation"
  ],
  "title": "MomentType",
  "type": "string",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/ObserverError.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Errors that can occur during AI observation",
  "oneOf": [
    {
      "description": "Configuration error (missing API key, invalid model, etc.)",
      "properties": {
        "details": {
          "properties": {
            "message": {
              "type": "string"
            }
          },
          "required": [
            "message"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "Configuration"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "The AI provider returned an invalid response",
      "properties": {
        "details": {
          "properties": {
            "message": {
              "type": "string"
            },
            "provider": {
              "$ref": "../primitives/AIProvider.schema.json"
            },
            "raw_response": {
              "type": [
                "string",
                "null"
              ]
            }
          },
          "required": [
            "message",
            "provider"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "InvalidResponse"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Network or API error",
      "properties": {
        "details": {
          "properties": {
            "message": {
              "type": "string"
            },
            "provider": {
              "$ref": "../primitives/AIProvider.schema.json"
            },
            "status_code": {
              "format": "uint16",
              "minimum": 0.0,
              "type": [
                "integer",
                "null"
              ]
            }
          },
          "required": [
            "message",
            "provider"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "Network"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Rate limit exceeded",
      "properties": {
        "details": {
          "properties": {
            "provider": {
              "$ref": "../primitives/AIProvider.schema.json"
            },
            "retry_after_ms": {
              "format": "uint64",
              "minimum": 0.0,
              "type": [
                "integer",
                "null"
              ]
            }
          },
          "required": [
            "provider"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "RateLimited"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "The AI refused to process (content policy)",
      "properties": {
        "details": {
          "properties": {
            "message": {
              "type": "string"
            },
            "provider": {
              "$ref": "../primitives/AIProvider.schema.json"
            }
          },
          "required": [
            "message",
            "provider"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "ContentFiltered"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Deserialization failed",
      "properties": {
        "details": {
          "properties": {
            "message": {
              "type": "string"
            },
            "raw_content": {
              "type": [
                "string",
                "null"
              ]
            }
          },
          "required": [
            "message"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "ParseError"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Timeout",
      "properties": {
        "details": {
          "properties": {
            "provider": {
              "$ref": "../primitives/AIProvider.schema.json"
            },
            "timeout_ms": {
              "format": "uint64",
              "minimum": 0.0,
              "type": "integer"
            }
          },
          "required": [
            "provider",
            "timeout_ms"
          ],
          "type": "object"
        },
        "type": {
          "enum": [
            "Timeout"
          ],
          "type": "string"
        }
      },
      "required": [
        "details",
        "type"
      ],
      "type": "object"
    }
  ],
  "title": "ObserverError",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/PromptConfig.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "PromptPhase": {
      "enum": [
        "Segmentation",
        "Purpose",
        "Classification"
      ],
      "type": "string"
    }
  },
  "description": "Schema for TypeScript prompt configuration Runtime prompts are in services/windmill/scripts/*.ts",
  "properties": {
    "max_tokens": {
      "format": "uint32",
      "minimum": 0.0,
      "type": "integer"
    },
    "model": {
      "type": "string"
    },
    "phase": {
      "$ref": "#/definitions/PromptPhase"
    },
    "temperature": {
      "format": "float",
      "type": "number"
    }
  },
  "required": [
    "max_tokens",
    "model",
    "phase",
    "temperature"
  ],
  "title": "PromptConfig",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/PromptPhase.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "Segmentation",
    "Purpose",
    "Classification"
  ],
  "title": "PromptPhase",
  "type": "string",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/QueryTarget.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Query target - what data is the query looking for?",
  "properties": {
    "entity_types": {
      "default": [],
      "description": "The entity/thread types being queried (e.g., \"moments\", \"threads\", \"pulses\")",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "keywords": {
      "default": [],
      "description": "Keywords extracted from the query",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "temporal_scope": {
      "default": null,
      "description": "Temporal scope (e.g., \"today\", \"last week\", \"all time\")",
      "type": [
        "string",
        "null"
      ]
    },
    "thread_hints": {
      "default": [],
      "description": "Specific thread hints (names, concepts) to search for",
      "items": {
        "type": "string"
      },
      "type": "array"
    }
  },
  "title": "QueryTarget",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/QueryType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "The type of query (when MessageIntent is QUERY)",
  "oneOf": [
    {
      "description": "When did X happen? Time-based lookup",
      "enum": [
        "TEMPORAL"
      ],
      "type": "string"
    },
    {
      "description": "Who/what questions - entity lookup",
      "enum": [
        "ENTITY"
      ],
      "type": "string"
    },
    {
      "description": "How often? Pattern/frequency questions",
      "enum": [
        "PATTERN"
      ],
      "type": "string"
    },
    {
      "description": "Compare X and Y",
      "enum": [
        "COMPARISON"
      ],
      "type": "string"
    },
    {
      "description": "Give me a summary/overview",
      "enum": [
        "SUMMARY"
      ],
      "type": "string"
    },
    {
      "description": "Count/quantity questions (how many?)",
      "enum": [
        "QUANTITATIVE"
      ],
      "type": "string"
    },
    {
      "description": "Yes/no questions (did X happen?)",
      "enum": [
        "BOOLEAN"
      ],
      "type": "string"
    },
    {
      "description": "Why questions - causation",
      "enum": [
        "CAUSAL"
      ],
      "type": "string"
    },
    {
      "description": "Location-based questions",
      "enum": [
        "SPATIAL"
      ],
      "type": "string"
    },
    {
      "description": "Open-ended/exploratory",
      "enum": [
        "EXPLORATORY"
      ],
      "type": "string"
    }
  ],
  "title": "QueryType",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/RawClassification.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Raw classification from LLM output",
  "properties": {
    "entity_type": {
      "$ref": "../primitives/HeddleEntityType.schema.json"
    },
    "weight": {
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "entity_type",
    "weight"
  ],
  "title": "RawClassification",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/RawMessageIntent.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Raw message intent classification from LLM",
  "properties": {
    "confidence": {
      "default": 1.0,
      "description": "Confidence in classification (0.0 to 1.0)",
      "format": "double",
      "type": "number"
    },
    "intent": {
      "allOf": [
        {
          "$ref": "../primitives/MessageIntent.schema.json"
        }
      ],
      "description": "Primary intent (LOG, QUERY, INFER, REFERENCE, REFLECT, COMMAND, SOCIAL)"
    },
    "query_target": {
      "anyOf": [
        {
          "$ref": "../primitives/QueryTarget.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "description": "If QUERY: what entities/threads are being queried"
    },
    "query_type": {
      "anyOf": [
        {
          "$ref": "../primitives/QueryType.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "description": "If QUERY: what type of query"
    }
  },
  "required": [
    "intent"
  ],
  "title": "RawMessageIntent",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/RawPhysicsHint.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Raw physics hints from LLM (will be applied to spawned entities)",
  "properties": {
    "arousal": {
      "default": null,
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "clarity": {
      "default": null,
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "intrusiveness": {
      "default": null,
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "significance": {
      "default": null,
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "valence": {
      "default": null,
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "volatility": {
      "default": null,
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    }
  },
  "title": "RawPhysicsHint",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/RawSegment.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A raw segment from Phase 1 - NO classification, just text",
  "properties": {
    "content": {
      "description": "The extracted semantic content",
      "type": "string"
    },
    "mentions": {
      "default": [],
      "description": "Other entities/things mentioned",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "subject": {
      "default": null,
      "description": "Who/what is the primary subject? (for context, not classification)",
      "type": [
        "string",
        "null"
      ]
    },
    "temporal": {
      "default": null,
      "description": "Any temporal reference found",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "content"
  ],
  "title": "RawSegment",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/RawWeaveUnit.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "RawClassification": {
      "description": "Raw classification from LLM output",
      "properties": {
        "entity_type": {
          "$ref": "../primitives/HeddleEntityType.schema.json"
        },
        "weight": {
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "entity_type",
        "weight"
      ],
      "type": "object"
    },
    "RawPhysicsHint": {
      "description": "Raw physics hints from LLM (will be applied to spawned entities)",
      "properties": {
        "arousal": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "clarity": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "intrusiveness": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "significance": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "valence": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "volatility": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object"
    }
  },
  "description": "Raw weave unit from LLM output (before validation)",
  "properties": {
    "classifications": {
      "description": "Classifications in superposition",
      "items": {
        "$ref": "#/definitions/RawClassification"
      },
      "type": "array"
    },
    "content": {
      "description": "The extracted/cleaned text content for this weave unit",
      "type": "string"
    },
    "physics_hint": {
      "anyOf": [
        {
          "$ref": "#/definitions/RawPhysicsHint"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Physics hints (passed to spawned entities, not stored on WeaveUnit)"
    },
    "primary_thread": {
      "default": null,
      "description": "Primary thread: the main subject/actor of this unit",
      "type": [
        "string",
        "null"
      ]
    },
    "purpose": {
      "allOf": [
        {
          "$ref": "../primitives/MessageIntent.schema.json"
        }
      ],
      "default": "LOG",
      "description": "Purpose of this specific unit (LOG, QUERY, COMMAND, etc.) Only LOG units spawn entities"
    },
    "secondary_threads": {
      "default": null,
      "description": "Secondary threads: other people/places/things mentioned",
      "items": {
        "type": "string"
      },
      "type": [
        "array",
        "null"
      ]
    },
    "temporal_marker": {
      "default": null,
      "description": "Temporal marker: when this happened (absolute, relative, or frequency) Examples: \"6pm\", \"today\", \"yesterday\", \"once per hour\", \"every morning\"",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "classifications",
    "content"
  ],
  "title": "RawWeaveUnit",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/SegmentClassification.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ClassificationPhysics": {
      "description": "Physics hints extracted during classification",
      "properties": {
        "arousal": {
          "default": null,
          "description": "Activation level: 0.0 (calm) to 1.0 (activated)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "clarity": {
          "default": null,
          "description": "How clear/specific: 0.0 (vague) to 1.0 (clear)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "significance": {
          "default": null,
          "description": "How significant/important: 0.0 to 1.0",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "valence": {
          "default": null,
          "description": "Emotional valence: -1.0 (negative) to 1.0 (positive)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object"
    }
  },
  "description": "Classification for a single segment",
  "properties": {
    "entity_type": {
      "allOf": [
        {
          "$ref": "../primitives/HeddleEntityType.schema.json"
        }
      ],
      "description": "The entity type (MOMENT, PULSE, INTENT) - relevant for LOG purpose"
    },
    "physics": {
      "anyOf": [
        {
          "$ref": "#/definitions/ClassificationPhysics"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Physics hints for entity spawning (only for LOG purpose)"
    },
    "purpose": {
      "allOf": [
        {
          "$ref": "../primitives/MessageIntent.schema.json"
        }
      ],
      "default": "LOG",
      "description": "Purpose of this specific segment (LOG, QUERY, COMMAND, etc.) Only LOG segments spawn entities"
    },
    "segment_index": {
      "description": "Index of the segment being classified",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "weight": {
      "default": 1.0,
      "description": "Confidence weight (0.0 to 1.0)",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "entity_type",
    "segment_index"
  ],
  "title": "SegmentClassification",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/SegmentationResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "RawSegment": {
      "description": "A raw segment from Phase 1 - NO classification, just text",
      "properties": {
        "content": {
          "description": "The extracted semantic content",
          "type": "string"
        },
        "mentions": {
          "default": [],
          "description": "Other entities/things mentioned",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "subject": {
          "default": null,
          "description": "Who/what is the primary subject? (for context, not classification)",
          "type": [
            "string",
            "null"
          ]
        },
        "temporal": {
          "default": null,
          "description": "Any temporal reference found",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "content"
      ],
      "type": "object"
    }
  },
  "description": "Phase 1 response: Just segments, no classification",
  "properties": {
    "segments": {
      "description": "The semantic segments extracted from the input",
      "items": {
        "$ref": "#/definitions/RawSegment"
      },
      "type": "array"
    }
  },
  "required": [
    "segments"
  ],
  "title": "SegmentationResponse",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/ShuttleStatus.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Processing status for a Shuttle",
  "oneOf": [
    {
      "description": "Segment received, not yet processed",
      "enum": [
        "pending"
      ],
      "type": "string"
    },
    {
      "description": "Currently being classified by LLM",
      "enum": [
        "classifying"
      ],
      "type": "string"
    },
    {
      "description": "Classification complete, spawning entities",
      "enum": [
        "spawning"
      ],
      "type": "string"
    },
    {
      "description": "All processing complete",
      "enum": [
        "complete"
      ],
      "type": "string"
    },
    {
      "description": "Processing failed",
      "enum": [
        "failed"
      ],
      "type": "string"
    }
  ],
  "title": "ShuttleStatus",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/Tenant.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A tenant (family) in the system\n\nUses `SystemEntityMeta` because tenants are top-level entities that don't belong to another tenant.",
  "properties": {
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "id": {
      "$ref": "../primitives/TenantId.schema.json"
    },
    "name": {
      "type": "string"
    },
    "settings": {
      "default": null
    },
    "updated_at": {
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "created_at",
    "id",
    "name",
    "updated_at"
  ],
  "title": "Tenant",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/TenantMember.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "MemberRole": {
      "description": "Role of a tenant member",
      "enum": [
        "admin",
        "member",
        "guest"
      ],
      "type": "string"
    }
  },
  "description": "A member of a tenant (user-tenant association with role)\n\nNote: Uses UserId as the entity ID since this is a join table where the user_id + tenant_id forms the unique key.",
  "properties": {
    "avatar_url": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "email": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "id": {
      "$ref": "../primitives/TenantId.schema.json"
    },
    "name": {
      "type": "string"
    },
    "role": {
      "$ref": "#/definitions/MemberRole"
    },
    "settings": {
      "default": null
    },
    "tenant_id": {
      "$ref": "../primitives/TenantId.schema.json"
    },
    "updated_at": {
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "created_at",
    "id",
    "name",
    "role",
    "tenant_id",
    "updated_at"
  ],
  "title": "TenantMember",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/ThreadType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "Person",
    "Place",
    "Concept",
    "GenericObject"
  ],
  "title": "ThreadType",
  "type": "string",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/ToolCallStatus.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Status of a tool call during execution",
  "enum": [
    "pending",
    "running",
    "complete",
    "error"
  ],
  "title": "ToolCallStatus",
  "type": "string",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/UIChannel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "UIChannelMessage": {
      "description": "A user message that starts a thread in a channel",
      "properties": {
        "content": {
          "description": "Original user message content",
          "type": "string"
        },
        "id": {
          "description": "Unique ID",
          "type": "string"
        },
        "is_active": {
          "default": false,
          "description": "Is this the active/latest message?",
          "type": "boolean"
        },
        "is_expanded": {
          "default": false,
          "description": "Is thread expanded in UI?",
          "type": "boolean"
        },
        "thread": {
          "description": "Thread of responses and follow-ups",
          "items": {
            "$ref": "#/definitions/UIThreadItem"
          },
          "type": "array"
        },
        "timestamp": {
          "description": "When posted",
          "type": "string"
        }
      },
      "required": [
        "content",
        "id",
        "thread",
        "timestamp"
      ],
      "type": "object"
    },
    "UIHeddleResult": {
      "description": "Structured result from the Heddle classification pipeline",
      "properties": {
        "classifications": {
          "default": [],
          "description": "Classification results",
          "items": {
            "$ref": "../primitives/UIClassification.schema.json"
          },
          "type": "array"
        },
        "physics": {
          "anyOf": [
            {
              "$ref": "../primitives/UIPhysicsResult.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Physics hints"
        },
        "purpose": {
          "default": null,
          "description": "Detected purpose/intent",
          "type": [
            "string",
            "null"
          ]
        },
        "segments": {
          "default": [],
          "description": "Segmented content",
          "items": {
            "$ref": "../primitives/UIHeddleSegment.schema.json"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "UIThinkingStep": {
      "description": "A thinking/reasoning step for chain-of-thought visibility",
      "properties": {
        "agent": {
          "description": "Which agent produced this thought",
          "type": "string"
        },
        "id": {
          "description": "Unique ID",
          "type": "string"
        },
        "thought": {
          "description": "The thought/reasoning content",
          "type": "string"
        },
        "timestamp": {
          "default": null,
          "description": "Timestamp",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "agent",
        "id",
        "thought"
      ],
      "type": "object"
    },
    "UIThreadItem": {
      "description": "An item in a conversation thread (user message or AI response)",
      "properties": {
        "agent_speaker": {
          "default": null,
          "description": "For assistant messages: which agent",
          "type": [
            "string",
            "null"
          ]
        },
        "content": {
          "description": "Text content",
          "type": "string"
        },
        "current_activity": {
          "default": null,
          "description": "Activity description for typing state",
          "type": [
            "string",
            "null"
          ]
        },
        "heddle_result": {
          "anyOf": [
            {
              "$ref": "#/definitions/UIHeddleResult"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Heddle classification result"
        },
        "id": {
          "description": "Unique ID",
          "type": "string"
        },
        "is_typing": {
          "default": false,
          "description": "Is this message still being generated?",
          "type": "boolean"
        },
        "role": {
          "description": "Role: \"user\" or \"assistant\"",
          "type": "string"
        },
        "status": {
          "default": null,
          "description": "Current status",
          "type": [
            "string",
            "null"
          ]
        },
        "summary": {
          "default": null,
          "description": "Summary for collapsed display",
          "type": [
            "string",
            "null"
          ]
        },
        "thinking_steps": {
          "default": [],
          "description": "Chain of thought steps",
          "items": {
            "$ref": "#/definitions/UIThinkingStep"
          },
          "type": "array"
        },
        "timestamp": {
          "description": "Timestamp",
          "type": "string"
        },
        "tool_calls": {
          "default": [],
          "description": "Tool calls made",
          "items": {
            "$ref": "#/definitions/UIToolCall"
          },
          "type": "array"
        }
      },
      "required": [
        "content",
        "id",
        "role",
        "timestamp"
      ],
      "type": "object"
    },
    "UIToolCall": {
      "description": "A tool call with real-time status updates for UI display",
      "properties": {
        "arguments": {
          "default": null,
          "description": "Arguments passed to the tool"
        },
        "id": {
          "description": "Unique ID for this tool call",
          "type": "string"
        },
        "result": {
          "default": null,
          "description": "Result from the tool"
        },
        "status": {
          "allOf": [
            {
              "$ref": "../primitives/ToolCallStatus.schema.json"
            }
          ],
          "description": "Current status"
        },
        "tool": {
          "description": "Name of the tool",
          "type": "string"
        }
      },
      "required": [
        "id",
        "status",
        "tool"
      ],
      "type": "object"
    }
  },
  "description": "A channel (persistent conversation space)",
  "properties": {
    "created_at": {
      "description": "When created",
      "type": "string"
    },
    "id": {
      "description": "Unique ID",
      "type": "string"
    },
    "messages": {
      "description": "Messages in this channel",
      "items": {
        "$ref": "#/definitions/UIChannelMessage"
      },
      "type": "array"
    },
    "name": {
      "description": "Display name",
      "type": "string"
    },
    "updated_at": {
      "description": "When last updated",
      "type": "string"
    }
  },
  "required": [
    "created_at",
    "id",
    "messages",
    "name",
    "updated_at"
  ],
  "title": "UIChannel",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/UIChannelMessage.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "UIHeddleResult": {
      "description": "Structured result from the Heddle classification pipeline",
      "properties": {
        "classifications": {
          "default": [],
          "description": "Classification results",
          "items": {
            "$ref": "../primitives/UIClassification.schema.json"
          },
          "type": "array"
        },
        "physics": {
          "anyOf": [
            {
              "$ref": "../primitives/UIPhysicsResult.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Physics hints"
        },
        "purpose": {
          "default": null,
          "description": "Detected purpose/intent",
          "type": [
            "string",
            "null"
          ]
        },
        "segments": {
          "default": [],
          "description": "Segmented content",
          "items": {
            "$ref": "../primitives/UIHeddleSegment.schema.json"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "UIThinkingStep": {
      "description": "A thinking/reasoning step for chain-of-thought visibility",
      "properties": {
        "agent": {
          "description": "Which agent produced this thought",
          "type": "string"
        },
        "id": {
          "description": "Unique ID",
          "type": "string"
        },
        "thought": {
          "description": "The thought/reasoning content",
          "type": "string"
        },
        "timestamp": {
          "default": null,
          "description": "Timestamp",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "agent",
        "id",
        "thought"
      ],
      "type": "object"
    },
    "UIThreadItem": {
      "description": "An item in a conversation thread (user message or AI response)",
      "properties": {
        "agent_speaker": {
          "default": null,
          "description": "For assistant messages: which agent",
          "type": [
            "string",
            "null"
          ]
        },
        "content": {
          "description": "Text content",
          "type": "string"
        },
        "current_activity": {
          "default": null,
          "description": "Activity description for typing state",
          "type": [
            "string",
            "null"
          ]
        },
        "heddle_result": {
          "anyOf": [
            {
              "$ref": "#/definitions/UIHeddleResult"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Heddle classification result"
        },
        "id": {
          "description": "Unique ID",
          "type": "string"
        },
        "is_typing": {
          "default": false,
          "description": "Is this message still being generated?",
          "type": "boolean"
        },
        "role": {
          "description": "Role: \"user\" or \"assistant\"",
          "type": "string"
        },
        "status": {
          "default": null,
          "description": "Current status",
          "type": [
            "string",
            "null"
          ]
        },
        "summary": {
          "default": null,
          "description": "Summary for collapsed display",
          "type": [
            "string",
            "null"
          ]
        },
        "thinking_steps": {
          "default": [],
          "description": "Chain of thought steps",
          "items": {
            "$ref": "#/definitions/UIThinkingStep"
          },
          "type": "array"
        },
        "timestamp": {
          "description": "Timestamp",
          "type": "string"
        },
        "tool_calls": {
          "default": [],
          "description": "Tool calls made",
          "items": {
            "$ref": "#/definitions/UIToolCall"
          },
          "type": "array"
        }
      },
      "required": [
        "content",
        "id",
        "role",
        "timestamp"
      ],
      "type": "object"
    },
    "UIToolCall": {
      "description": "A tool call with real-time status updates for UI display",
      "properties": {
        "arguments": {
          "default": null,
          "description": "Arguments passed to the tool"
        },
        "id": {
          "description": "Unique ID for this tool call",
          "type": "string"
        },
        "result": {
          "default": null,
          "description": "Result from the tool"
        },
        "status": {
          "allOf": [
            {
              "$ref": "../primitives/ToolCallStatus.schema.json"
            }
          ],
          "description": "Current status"
        },
        "tool": {
          "description": "Name of the tool",
          "type": "string"
        }
      },
      "required": [
        "id",
        "status",
        "tool"
      ],
      "type": "object"
    }
  },
  "description": "A user message that starts a thread in a channel",
  "properties": {
    "content": {
      "description": "Original user message content",
      "type": "string"
    },
    "id": {
      "description": "Unique ID",
      "type": "string"
    },
    "is_active": {
      "default": false,
      "description": "Is this the active/latest message?",
      "type": "boolean"
    },
    "is_expanded": {
      "default": false,
      "description": "Is thread expanded in UI?",
      "type": "boolean"
    },
    "thread": {
      "description": "Thread of responses and follow-ups",
      "items": {
        "$ref": "#/definitions/UIThreadItem"
      },
      "type": "array"
    },
    "timestamp": {
      "description": "When posted",
      "type": "string"
    }
  },
  "required": [
    "content",
    "id",
    "thread",
    "timestamp"
  ],
  "title": "UIChannelMessage",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/UIClassification.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A classification result",
  "properties": {
    "confidence": {
      "format": "double",
      "type": "number"
    },
    "entity_type": {
      "type": "string"
    }
  },
  "required": [
    "confidence",
    "entity_type"
  ],
  "title": "UIClassification",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/UIHeddleResult.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Structured result from the Heddle classification pipeline",
  "properties": {
    "classifications": {
      "default": [],
      "description": "Classification results",
      "items": {
        "$ref": "../primitives/UIClassification.schema.json"
      },
      "type": "array"
    },
    "physics": {
      "anyOf": [
        {
          "$ref": "../primitives/UIPhysicsResult.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Physics hints"
    },
    "purpose": {
      "default": null,
      "description": "Detected purpose/intent",
      "type": [
        "string",
        "null"
      ]
    },
    "segments": {
      "default": [],
      "description": "Segmented content",
      "items": {
        "$ref": "../primitives/UIHeddleSegment.schema.json"
      },
      "type": "array"
    }
  },
  "title": "UIHeddleResult",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/UIHeddleSegment.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A segment from Heddle",
  "properties": {
    "content": {
      "type": "string"
    },
    "subject": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "content"
  ],
  "title": "UIHeddleSegment",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/UIPhysicsResult.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Physics simulation result",
  "properties": {
    "energy": {
      "format": "double",
      "type": "number"
    },
    "position": {
      "items": {
        "format": "double",
        "type": "number"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    },
    "temperature": {
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "energy",
    "position",
    "temperature"
  ],
  "title": "UIPhysicsResult",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/UIThinkingStep.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A thinking/reasoning step for chain-of-thought visibility",
  "properties": {
    "agent": {
      "description": "Which agent produced this thought",
      "type": "string"
    },
    "id": {
      "description": "Unique ID",
      "type": "string"
    },
    "thought": {
      "description": "The thought/reasoning content",
      "type": "string"
    },
    "timestamp": {
      "default": null,
      "description": "Timestamp",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "agent",
    "id",
    "thought"
  ],
  "title": "UIThinkingStep",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/UIThreadItem.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "UIHeddleResult": {
      "description": "Structured result from the Heddle classification pipeline",
      "properties": {
        "classifications": {
          "default": [],
          "description": "Classification results",
          "items": {
            "$ref": "../primitives/UIClassification.schema.json"
          },
          "type": "array"
        },
        "physics": {
          "anyOf": [
            {
              "$ref": "../primitives/UIPhysicsResult.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Physics hints"
        },
        "purpose": {
          "default": null,
          "description": "Detected purpose/intent",
          "type": [
            "string",
            "null"
          ]
        },
        "segments": {
          "default": [],
          "description": "Segmented content",
          "items": {
            "$ref": "../primitives/UIHeddleSegment.schema.json"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "UIThinkingStep": {
      "description": "A thinking/reasoning step for chain-of-thought visibility",
      "properties": {
        "agent": {
          "description": "Which agent produced this thought",
          "type": "string"
        },
        "id": {
          "description": "Unique ID",
          "type": "string"
        },
        "thought": {
          "description": "The thought/reasoning content",
          "type": "string"
        },
        "timestamp": {
          "default": null,
          "description": "Timestamp",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "agent",
        "id",
        "thought"
      ],
      "type": "object"
    },
    "UIToolCall": {
      "description": "A tool call with real-time status updates for UI display",
      "properties": {
        "arguments": {
          "default": null,
          "description": "Arguments passed to the tool"
        },
        "id": {
          "description": "Unique ID for this tool call",
          "type": "string"
        },
        "result": {
          "default": null,
          "description": "Result from the tool"
        },
        "status": {
          "allOf": [
            {
              "$ref": "../primitives/ToolCallStatus.schema.json"
            }
          ],
          "description": "Current status"
        },
        "tool": {
          "description": "Name of the tool",
          "type": "string"
        }
      },
      "required": [
        "id",
        "status",
        "tool"
      ],
      "type": "object"
    }
  },
  "description": "An item in a conversation thread (user message or AI response)",
  "properties": {
    "agent_speaker": {
      "default": null,
      "description": "For assistant messages: which agent",
      "type": [
        "string",
        "null"
      ]
    },
    "content": {
      "description": "Text content",
      "type": "string"
    },
    "current_activity": {
      "default": null,
      "description": "Activity description for typing state",
      "type": [
        "string",
        "null"
      ]
    },
    "heddle_result": {
      "anyOf": [
        {
          "$ref": "#/definitions/UIHeddleResult"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Heddle classification result"
    },
    "id": {
      "description": "Unique ID",
      "type": "string"
    },
    "is_typing": {
      "default": false,
      "description": "Is this message still being generated?",
      "type": "boolean"
    },
    "role": {
      "description": "Role: \"user\" or \"assistant\"",
      "type": "string"
    },
    "status": {
      "default": null,
      "description": "Current status",
      "type": [
        "string",
        "null"
      ]
    },
    "summary": {
      "default": null,
      "description": "Summary for collapsed display",
      "type": [
        "string",
        "null"
      ]
    },
    "thinking_steps": {
      "default": [],
      "description": "Chain of thought steps",
      "items": {
        "$ref": "#/definitions/UIThinkingStep"
      },
      "type": "array"
    },
    "timestamp": {
      "description": "Timestamp",
      "type": "string"
    },
    "tool_calls": {
      "default": [],
      "description": "Tool calls made",
      "items": {
        "$ref": "#/definitions/UIToolCall"
      },
      "type": "array"
    }
  },
  "required": [
    "content",
    "id",
    "role",
    "timestamp"
  ],
  "title": "UIThreadItem",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/UIToolCall.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A tool call with real-time status updates for UI display",
  "properties": {
    "arguments": {
      "default": null,
      "description": "Arguments passed to the tool"
    },
    "id": {
      "description": "Unique ID for this tool call",
      "type": "string"
    },
    "result": {
      "default": null,
      "description": "Result from the tool"
    },
    "status": {
      "allOf": [
        {
          "$ref": "../primitives/ToolCallStatus.schema.json"
        }
      ],
      "description": "Current status"
    },
    "tool": {
      "description": "Name of the tool",
      "type": "string"
    }
  },
  "required": [
    "id",
    "status",
    "tool"
  ],
  "title": "UIToolCall",
  "type": "object",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/codegen/types/WsMessage.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AccordionState": {
      "enum": [
        "collapsed",
        "expanded"
      ],
      "type": "string"
    },
    "Block": {
      "description": "A single visual block in a message",
      "oneOf": [
        {
          "description": "Displays text, possibly alongside an accessory (image, button, etc.)",
          "properties": {
            "accessory": {
              "anyOf": [
                {
                  "$ref": "../primitives/BlockElement.schema.json"
                },
                {
                  "type": "null"
                }
              ]
            },
            "fields": {
              "items": {
                "$ref": "../primitives/TextObject.schema.json"
              },
              "type": [
                "array",
                "null"
              ]
            },
            "text": {
              "$ref": "../primitives/TextObject.schema.json"
            },
            "type": {
              "enum": [
                "section"
              ],
              "type": "string"
            }
          },
          "required": [
            "text",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A visual separator",
          "properties": {
            "type": {
              "enum": [
                "divider"
              ],
              "type": "string"
            }
          },
          "required": [
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Displays an image with optional title",
          "properties": {
            "alt_text": {
              "type": "string"
            },
            "image_url": {
              "type": "string"
            },
            "title": {
              "anyOf": [
                {
                  "$ref": "../primitives/PlainTextObject.schema.json"
                },
                {
                  "type": "null"
                }
              ]
            },
            "type": {
              "enum": [
                "image"
              ],
              "type": "string"
            }
          },
          "required": [
            "alt_text",
            "image_url",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A container for interactive elements (buttons, selects, etc.)",
          "properties": {
            "elements": {
              "items": {
                "$ref": "../primitives/BlockElement.schema.json"
              },
              "type": "array"
            },
            "type": {
              "enum": [
                "actions"
              ],
              "type": "string"
            }
          },
          "required": [
            "elements",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Displays contextual info (small grey text, images)",
          "properties": {
            "elements": {
              "items": {
                "$ref": "../primitives/ContextElement.schema.json"
              },
              "type": "array"
            },
            "type": {
              "enum": [
                "context"
              ],
              "type": "string"
            }
          },
          "required": [
            "elements",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A header with large, bold text",
          "properties": {
            "text": {
              "$ref": "../primitives/PlainTextObject.schema.json"
            },
            "type": {
              "enum": [
                "header"
              ],
              "type": "string"
            }
          },
          "required": [
            "text",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "An input field",
          "properties": {
            "element": {
              "$ref": "../primitives/BlockElement.schema.json"
            },
            "hint": {
              "anyOf": [
                {
                  "$ref": "../primitives/PlainTextObject.schema.json"
                },
                {
                  "type": "null"
                }
              ]
            },
            "label": {
              "$ref": "../primitives/PlainTextObject.schema.json"
            },
            "optional": {
              "default": false,
              "type": "boolean"
            },
            "type": {
              "enum": [
                "input"
              ],
              "type": "string"
            }
          },
          "required": [
            "element",
            "label",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A collapsible container",
          "properties": {
            "blocks": {
              "items": {
                "$ref": "#/definitions/Block"
              },
              "type": "array"
            },
            "initial_state": {
              "allOf": [
                {
                  "$ref": "#/definitions/AccordionState"
                }
              ],
              "default": "collapsed"
            },
            "summary": {
              "$ref": "../primitives/PlainTextObject.schema.json"
            },
            "type": {
              "enum": [
                "accordion"
              ],
              "type": "string"
            }
          },
          "required": [
            "blocks",
            "summary",
            "type"
          ],
          "type": "object"
        }
      ]
    },
    "BlockMessage": {
      "description": "The root container for a Block Kit message",
      "properties": {
        "blocks": {
          "items": {
            "$ref": "#/definitions/Block"
          },
          "type": "array"
        }
      },
      "required": [
        "blocks"
      ],
      "type": "object"
    },
    "MessageStatusType": {
      "description": "Message delivery status",
      "enum": [
        "sending",
        "sent",
        "delivered",
        "read",
        "failed"
      ],
      "type": "string"
    }
  },
  "description": "A message sent from the server to the client via WebSocket",
  "oneOf": [
    {
      "description": "Connection status / Handshake",
      "properties": {
        "job_id": {
          "type": "string"
        },
        "status": {
          "type": "string"
        },
        "type": {
          "enum": [
            "status"
          ],
          "type": "string"
        }
      },
      "required": [
        "job_id",
        "status",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Typing indicator (agent is processing)",
      "properties": {
        "job_id": {
          "type": "string"
        },
        "message": {
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "enum": [
            "typing"
          ],
          "type": "string"
        }
      },
      "required": [
        "job_id",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Job progress update (with optional Block Kit content)",
      "properties": {
        "blocks": {
          "anyOf": [
            {
              "$ref": "#/definitions/BlockMessage"
            },
            {
              "type": "null"
            }
          ]
        },
        "details": {
          "type": [
            "string",
            "null"
          ]
        },
        "status": {
          "type": "string"
        },
        "type": {
          "enum": [
            "progress"
          ],
          "type": "string"
        }
      },
      "required": [
        "status",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Job completed successfully (with Block Kit content)",
      "properties": {
        "blocks": {
          "anyOf": [
            {
              "$ref": "#/definitions/BlockMessage"
            },
            {
              "type": "null"
            }
          ]
        },
        "job_id": {
          "type": "string"
        },
        "result": true,
        "type": {
          "enum": [
            "complete"
          ],
          "type": "string"
        }
      },
      "required": [
        "job_id",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Error occurred (with Block Kit content)",
      "properties": {
        "blocks": {
          "anyOf": [
            {
              "$ref": "#/definitions/BlockMessage"
            },
            {
              "type": "null"
            }
          ]
        },
        "job_id": {
          "type": [
            "string",
            "null"
          ]
        },
        "message": {
          "type": "string"
        },
        "type": {
          "enum": [
            "error"
          ],
          "type": "string"
        }
      },
      "required": [
        "message",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Message status update (sent, delivered, read)",
      "properties": {
        "message_id": {
          "type": "string"
        },
        "status": {
          "$ref": "#/definitions/MessageStatusType"
        },
        "type": {
          "enum": [
            "message_status"
          ],
          "type": "string"
        }
      },
      "required": [
        "message_id",
        "status",
        "type"
      ],
      "type": "object"
    }
  ],
  "title": "WsMessage",
  "x-familiar-kind": "type"
}
```

### versions/v1.1.0-alpha/json-schema/domain/agentic/AgentMessageType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Finding": {
      "description": "A finding from an analysis agent",
      "properties": {
        "confidence": {
          "default": null,
          "description": "Confidence score (0.0 to 1.0)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "description": {
          "description": "Detailed description",
          "type": "string"
        },
        "related_entities": {
          "default": [],
          "description": "Related entity IDs",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "title": {
          "description": "Title or label of the finding",
          "type": "string"
        }
      },
      "required": [
        "description",
        "title"
      ],
      "type": "object"
    },
    "LogLevel": {
      "description": "Log level for agent log messages",
      "enum": [
        "debug",
        "info",
        "warning",
        "error"
      ],
      "type": "string"
    }
  },
  "description": "Agent message types for different response formats\n\nThe agentic system can produce various types of responses depending on what the agent is doing. This enum captures all possible message types.",
  "oneOf": [
    {
      "description": "A log message from the agent (debugging, status updates)",
      "properties": {
        "content": {
          "type": "string"
        },
        "level": {
          "$ref": "#/definitions/LogLevel"
        },
        "message_type": {
          "enum": [
            "log"
          ],
          "type": "string"
        }
      },
      "required": [
        "content",
        "level",
        "message_type"
      ],
      "type": "object"
    },
    {
      "description": "A question the agent is asking the user",
      "properties": {
        "message_type": {
          "enum": [
            "question"
          ],
          "type": "string"
        },
        "options": {
          "default": null,
          "items": {
            "type": "string"
          },
          "type": [
            "array",
            "null"
          ]
        },
        "prompt": {
          "type": "string"
        }
      },
      "required": [
        "message_type",
        "prompt"
      ],
      "type": "object"
    },
    {
      "description": "An insight derived by the agent",
      "properties": {
        "confidence": {
          "format": "double",
          "type": "number"
        },
        "domain": {
          "default": null,
          "type": [
            "string",
            "null"
          ]
        },
        "message_type": {
          "enum": [
            "insight"
          ],
          "type": "string"
        },
        "summary": {
          "type": "string"
        }
      },
      "required": [
        "confidence",
        "message_type",
        "summary"
      ],
      "type": "object"
    },
    {
      "description": "A detailed analysis result",
      "properties": {
        "domain": {
          "type": "string"
        },
        "findings": {
          "items": {
            "$ref": "#/definitions/Finding"
          },
          "type": "array"
        },
        "message_type": {
          "enum": [
            "analysis"
          ],
          "type": "string"
        }
      },
      "required": [
        "domain",
        "findings",
        "message_type"
      ],
      "type": "object"
    },
    {
      "description": "A command/action the agent wants to execute",
      "properties": {
        "action": {
          "type": "string"
        },
        "message_type": {
          "enum": [
            "command"
          ],
          "type": "string"
        },
        "parameters": true
      },
      "required": [
        "action",
        "message_type",
        "parameters"
      ],
      "type": "object"
    },
    {
      "description": "A simple text response",
      "properties": {
        "content": {
          "type": "string"
        },
        "message_type": {
          "enum": [
            "text"
          ],
          "type": "string"
        }
      },
      "required": [
        "content",
        "message_type"
      ],
      "type": "object"
    },
    {
      "description": "Progress update during long-running tasks",
      "properties": {
        "message": {
          "type": "string"
        },
        "message_type": {
          "enum": [
            "progress"
          ],
          "type": "string"
        },
        "percent_complete": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "required": [
        "message",
        "message_type"
      ],
      "type": "object"
    }
  ],
  "title": "AgentMessageType",
  "x-familiar-kind": "agentic",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/agentic/AgentSpeaker.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Speaker/agent identifiers for the orchestration system\n\nEach speaker is a specialized agent that handles specific types of tasks. The orchestrator routes to the appropriate speaker based on user intent.",
  "oneOf": [
    {
      "description": "Main user-facing agent - greets users, explains capabilities",
      "enum": [
        "concierge"
      ],
      "type": "string"
    },
    {
      "description": "Classification agent - determines entity types, message intent",
      "enum": [
        "classifier"
      ],
      "type": "string"
    },
    {
      "description": "Physics simulation agent - handles VAE space calculations",
      "enum": [
        "physics"
      ],
      "type": "string"
    },
    {
      "description": "Retrieval-augmented generation agent (future)",
      "enum": [
        "rag"
      ],
      "type": "string"
    },
    {
      "description": "Memory/context management agent",
      "enum": [
        "memory"
      ],
      "type": "string"
    },
    {
      "description": "Task execution agent",
      "enum": [
        "task_executor"
      ],
      "type": "string"
    }
  ],
  "title": "AgentSpeaker",
  "x-familiar-kind": "agentic",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/agentic/AgentState.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Global state shared across all agents in the orchestration loop\n\nThis state is passed between agents and maintains context about the current conversation, authentication status, and which agent is currently \"speaking\".",
  "properties": {
    "conversation_context": {
      "default": [],
      "description": "Conversation history for context",
      "items": {
        "$ref": "../../codegen/primitives/ConversationTurn.schema.json"
      },
      "type": "array"
    },
    "current_speaker": {
      "default": null,
      "description": "Currently active speaker (None means orchestrator decides)",
      "type": [
        "string",
        "null"
      ]
    },
    "is_authenticated": {
      "default": false,
      "description": "Whether the user is authenticated",
      "type": "boolean"
    },
    "just_finished": {
      "default": false,
      "description": "Whether the current agent just finished its task",
      "type": "boolean"
    },
    "metadata": {
      "default": null,
      "description": "Custom metadata for extensibility"
    },
    "tenant_id": {
      "description": "Tenant ID for multi-tenancy",
      "type": "string"
    },
    "thread_id": {
      "default": null,
      "description": "Current thread ID (if in a thread)",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "tenant_id"
  ],
  "title": "AgentState",
  "type": "object",
  "x-familiar-kind": "agentic",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/agentic/ConversationTurn.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A single turn in a conversation (for context tracking)",
  "properties": {
    "content": {
      "description": "Content of the message",
      "type": "string"
    },
    "role": {
      "description": "Role of the speaker (user, assistant, system)",
      "type": "string"
    },
    "speaker": {
      "default": null,
      "description": "Optional speaker identifier (for multi-agent)",
      "type": [
        "string",
        "null"
      ]
    },
    "timestamp": {
      "default": null,
      "description": "Timestamp of the turn",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "content",
    "role"
  ],
  "title": "ConversationTurn",
  "type": "object",
  "x-familiar-kind": "agentic",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/agentic/Finding.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A finding from an analysis agent",
  "properties": {
    "confidence": {
      "default": null,
      "description": "Confidence score (0.0 to 1.0)",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "description": {
      "description": "Detailed description",
      "type": "string"
    },
    "related_entities": {
      "default": [],
      "description": "Related entity IDs",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "title": {
      "description": "Title or label of the finding",
      "type": "string"
    }
  },
  "required": [
    "description",
    "title"
  ],
  "title": "Finding",
  "type": "object",
  "x-familiar-kind": "agentic",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/agentic/LogLevel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Log level for agent log messages",
  "enum": [
    "debug",
    "info",
    "warning",
    "error"
  ],
  "title": "LogLevel",
  "type": "string",
  "x-familiar-kind": "agentic",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/agentic/OrchestrationInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AgentState": {
      "description": "Global state shared across all agents in the orchestration loop\n\nThis state is passed between agents and maintains context about the current conversation, authentication status, and which agent is currently \"speaking\".",
      "properties": {
        "conversation_context": {
          "default": [],
          "description": "Conversation history for context",
          "items": {
            "$ref": "../../codegen/primitives/ConversationTurn.schema.json"
          },
          "type": "array"
        },
        "current_speaker": {
          "default": null,
          "description": "Currently active speaker (None means orchestrator decides)",
          "type": [
            "string",
            "null"
          ]
        },
        "is_authenticated": {
          "default": false,
          "description": "Whether the user is authenticated",
          "type": "boolean"
        },
        "just_finished": {
          "default": false,
          "description": "Whether the current agent just finished its task",
          "type": "boolean"
        },
        "metadata": {
          "default": null,
          "description": "Custom metadata for extensibility"
        },
        "tenant_id": {
          "description": "Tenant ID for multi-tenancy",
          "type": "string"
        },
        "thread_id": {
          "default": null,
          "description": "Current thread ID (if in a thread)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "tenant_id"
      ],
      "type": "object"
    }
  },
  "description": "Input payload for the orchestration agent",
  "properties": {
    "request_id": {
      "description": "Request ID for tracing",
      "type": "string"
    },
    "state": {
      "allOf": [
        {
          "$ref": "#/definitions/AgentState"
        }
      ],
      "description": "Current agent state"
    },
    "user_message": {
      "default": null,
      "description": "User's message content",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "request_id",
    "state"
  ],
  "title": "OrchestrationInput",
  "type": "object",
  "x-familiar-kind": "agentic",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/agentic/OrchestrationOutput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AgentState": {
      "description": "Global state shared across all agents in the orchestration loop\n\nThis state is passed between agents and maintains context about the current conversation, authentication status, and which agent is currently \"speaking\".",
      "properties": {
        "conversation_context": {
          "default": [],
          "description": "Conversation history for context",
          "items": {
            "$ref": "../../codegen/primitives/ConversationTurn.schema.json"
          },
          "type": "array"
        },
        "current_speaker": {
          "default": null,
          "description": "Currently active speaker (None means orchestrator decides)",
          "type": [
            "string",
            "null"
          ]
        },
        "is_authenticated": {
          "default": false,
          "description": "Whether the user is authenticated",
          "type": "boolean"
        },
        "just_finished": {
          "default": false,
          "description": "Whether the current agent just finished its task",
          "type": "boolean"
        },
        "metadata": {
          "default": null,
          "description": "Custom metadata for extensibility"
        },
        "tenant_id": {
          "description": "Tenant ID for multi-tenancy",
          "type": "string"
        },
        "thread_id": {
          "default": null,
          "description": "Current thread ID (if in a thread)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "tenant_id"
      ],
      "type": "object"
    }
  },
  "description": "Output from the orchestration agent",
  "properties": {
    "forwarded_message": {
      "default": null,
      "description": "Optional message to pass to next agent",
      "type": [
        "string",
        "null"
      ]
    },
    "next_speaker": {
      "description": "Which agent should speak next",
      "type": "string"
    },
    "should_continue": {
      "description": "Whether the orchestration loop should continue",
      "type": "boolean"
    },
    "state": {
      "allOf": [
        {
          "$ref": "#/definitions/AgentState"
        }
      ],
      "description": "Updated state"
    }
  },
  "required": [
    "next_speaker",
    "should_continue",
    "state"
  ],
  "title": "OrchestrationOutput",
  "type": "object",
  "x-familiar-kind": "agentic",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/agentic/ToolCallRequest.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A request to invoke a tool",
  "properties": {
    "arguments": {
      "description": "Arguments to pass to the tool"
    },
    "call_id": {
      "description": "Unique ID for this tool call",
      "type": "string"
    },
    "tool_name": {
      "description": "Name of the tool to invoke",
      "type": "string"
    }
  },
  "required": [
    "arguments",
    "call_id",
    "tool_name"
  ],
  "title": "ToolCallRequest",
  "type": "object",
  "x-familiar-kind": "agentic",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/agentic/ToolCallResult.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Result from a tool invocation",
  "properties": {
    "call_id": {
      "description": "ID of the original call",
      "type": "string"
    },
    "error": {
      "default": null,
      "description": "Error message (if failed)",
      "type": [
        "string",
        "null"
      ]
    },
    "result": {
      "default": null,
      "description": "Result data (if successful)"
    },
    "success": {
      "description": "Whether the call succeeded",
      "type": "boolean"
    }
  },
  "required": [
    "call_id",
    "success"
  ],
  "title": "ToolCallResult",
  "type": "object",
  "x-familiar-kind": "agentic",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/api/ApiError.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "API error details",
  "properties": {
    "code": {
      "description": "Error code (e.g., \"NOT_FOUND\", \"VALIDATION_FAILED\")",
      "type": "string"
    },
    "details": {
      "description": "Optional structured details"
    },
    "message": {
      "description": "Human-readable error message",
      "type": "string"
    }
  },
  "required": [
    "code",
    "message"
  ],
  "title": "ApiError",
  "type": "object",
  "x-familiar-kind": "api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/api/SuccessResult.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Simple success response (no data)\n\nUsed for operations that succeed but don't return data: - DELETE operations - Fire-and-forget operations",
  "properties": {
    "message": {
      "type": [
        "string",
        "null"
      ]
    },
    "success": {
      "type": "boolean"
    }
  },
  "required": [
    "success"
  ],
  "title": "SuccessResult",
  "type": "object",
  "x-familiar-kind": "api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/AuditLogEntry.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "An audit log entry",
  "properties": {
    "action": {
      "type": "string"
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "error_message": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "ip_address": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": {
      "default": null
    },
    "resource_id": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "resource_type": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "success": {
      "type": "boolean"
    },
    "user_agent": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "user_email": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "user_id": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "action",
    "created_at",
    "id",
    "success"
  ],
  "title": "AuditLogEntry",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/AuthResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "SessionCreated": {
      "description": "Result of creating a session (includes the raw token)",
      "properties": {
        "expires_at": {
          "format": "date-time",
          "type": "string"
        },
        "session_id": {
          "format": "uuid",
          "type": "string"
        },
        "token": {
          "type": "string"
        }
      },
      "required": [
        "expires_at",
        "session_id",
        "token"
      ],
      "type": "object"
    },
    "User": {
      "description": "A user's identity that can belong to multiple families\n\nUses `SystemEntityMeta` because users are not tenant-scoped - a single user can belong to multiple families.",
      "properties": {
        "avatar_url": {
          "default": null,
          "type": [
            "string",
            "null"
          ]
        },
        "created_at": {
          "format": "date-time",
          "type": "string"
        },
        "deletion_requested_at": {
          "default": null,
          "format": "date-time",
          "type": [
            "string",
            "null"
          ]
        },
        "email": {
          "type": "string"
        },
        "email_verified": {
          "type": "boolean"
        },
        "gdpr_consents": {
          "default": null
        },
        "id": {
          "description": "Unique identifier for this entity",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "primary_tenant_id": {
          "default": null,
          "description": "The user's primary family (can be changed)",
          "format": "uuid",
          "type": [
            "string",
            "null"
          ]
        },
        "settings": {
          "default": null
        },
        "updated_at": {
          "format": "date-time",
          "type": "string"
        }
      },
      "required": [
        "created_at",
        "email",
        "email_verified",
        "id",
        "name",
        "updated_at"
      ],
      "type": "object"
    }
  },
  "description": "Response after successful authentication",
  "properties": {
    "is_new_user": {
      "description": "True if this is a new user (just signed up)",
      "type": "boolean"
    },
    "needs_family": {
      "description": "True if user needs to create/join a family",
      "type": "boolean"
    },
    "session": {
      "$ref": "#/definitions/SessionCreated"
    },
    "user": {
      "$ref": "#/definitions/User"
    }
  },
  "required": [
    "is_new_user",
    "needs_family",
    "session",
    "user"
  ],
  "title": "AuthResponse",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/AuthSession.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "An authenticated session",
  "properties": {
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "expires_at": {
      "format": "date-time",
      "type": "string"
    },
    "id": {
      "$ref": "../../codegen/primitives/SessionId.schema.json"
    },
    "ip_address": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "token_hash": {
      "description": "Token hash (the actual token is only returned once on creation)",
      "type": "string"
    },
    "user_agent": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "user_id": {
      "$ref": "../../codegen/primitives/UserId.schema.json"
    }
  },
  "required": [
    "created_at",
    "expires_at",
    "id",
    "token_hash",
    "user_id"
  ],
  "title": "AuthSession",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/ConsentRecord.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ConsentType": {
      "description": "Type of consent",
      "enum": [
        "terms_of_service",
        "privacy_policy",
        "marketing_emails",
        "ai_processing",
        "data_sharing",
        "analytics"
      ],
      "type": "string"
    }
  },
  "description": "A consent record",
  "properties": {
    "consent_type": {
      "$ref": "#/definitions/ConsentType"
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "granted": {
      "type": "boolean"
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "ip_address": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "user_agent": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "user_id": {
      "$ref": "../../codegen/primitives/UserId.schema.json"
    },
    "version": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "consent_type",
    "created_at",
    "granted",
    "id",
    "user_id"
  ],
  "title": "ConsentRecord",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/ConsentStatus.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "User's current consent status",
  "properties": {
    "ai_processing": {
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "analytics": {
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "data_sharing": {
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "marketing_emails": {
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "privacy_policy": {
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "terms_of_service": {
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "title": "ConsentStatus",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/ConsentType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Type of consent",
  "enum": [
    "terms_of_service",
    "privacy_policy",
    "marketing_emails",
    "ai_processing",
    "data_sharing",
    "analytics"
  ],
  "title": "ConsentType",
  "type": "string",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/CreateCodeInviteInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "definitions": {
    "InviteRole": {
      "description": "Role to assign when invitation is accepted",
      "enum": [
        "admin",
        "member",
        "guest"
      ],
      "type": "string"
    }
  },
  "description": "Input for creating a code invitation",
  "properties": {
    "expires_in_days": {
      "default": null,
      "description": "Expiry in days (None = never)",
      "format": "int64",
      "type": [
        "integer",
        "null"
      ]
    },
    "max_uses": {
      "default": 1,
      "description": "Max number of uses (default 1, 0 = unlimited)",
      "format": "int32",
      "type": "integer"
    },
    "role": {
      "anyOf": [
        {
          "$ref": "#/definitions/InviteRole"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "tenant_id": {
      "format": "uuid",
      "type": "string"
    }
  },
  "required": [
    "tenant_id"
  ],
  "title": "CreateCodeInviteInput",
  "type": "object"
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/CreateEmailInviteInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "definitions": {
    "InviteRole": {
      "description": "Role to assign when invitation is accepted",
      "enum": [
        "admin",
        "member",
        "guest"
      ],
      "type": "string"
    }
  },
  "description": "Input for creating an email invitation",
  "properties": {
    "email": {
      "type": "string"
    },
    "expires_in_days": {
      "default": 7,
      "description": "Expiry in days (default 7)",
      "format": "int64",
      "type": "integer"
    },
    "role": {
      "anyOf": [
        {
          "$ref": "#/definitions/InviteRole"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "tenant_id": {
      "format": "uuid",
      "type": "string"
    }
  },
  "required": [
    "email",
    "tenant_id"
  ],
  "title": "CreateEmailInviteInput",
  "type": "object"
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/CreateJoinRequestInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Input for creating a join request",
  "properties": {
    "message": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    }
  },
  "required": [
    "tenant_id"
  ],
  "title": "CreateJoinRequestInput",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/CreateMagicLinkInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "MagicLinkPurpose": {
      "description": "Purpose of a magic link",
      "enum": [
        "login",
        "signup",
        "verify_email",
        "password_reset"
      ],
      "type": "string"
    }
  },
  "description": "Input for creating a magic link",
  "properties": {
    "email": {
      "type": "string"
    },
    "expires_in_minutes": {
      "default": 15,
      "description": "Link duration in minutes (default 15)",
      "format": "int64",
      "type": "integer"
    },
    "metadata": {
      "default": null
    },
    "purpose": {
      "$ref": "#/definitions/MagicLinkPurpose"
    }
  },
  "required": [
    "email",
    "purpose"
  ],
  "title": "CreateMagicLinkInput",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/CreateUserInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Input for creating a new user",
  "properties": {
    "avatar_url": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "email": {
      "type": "string"
    },
    "name": {
      "type": "string"
    },
    "password_hash": {
      "default": null,
      "description": "Password hash (already hashed by API layer)",
      "type": [
        "string",
        "null"
      ]
    },
    "primary_tenant_id": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "email",
    "name"
  ],
  "title": "CreateUserInput",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/CurrentUser.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "User": {
      "description": "A user's identity that can belong to multiple families\n\nUses `SystemEntityMeta` because users are not tenant-scoped - a single user can belong to multiple families.",
      "properties": {
        "avatar_url": {
          "default": null,
          "type": [
            "string",
            "null"
          ]
        },
        "created_at": {
          "format": "date-time",
          "type": "string"
        },
        "deletion_requested_at": {
          "default": null,
          "format": "date-time",
          "type": [
            "string",
            "null"
          ]
        },
        "email": {
          "type": "string"
        },
        "email_verified": {
          "type": "boolean"
        },
        "gdpr_consents": {
          "default": null
        },
        "id": {
          "description": "Unique identifier for this entity",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "primary_tenant_id": {
          "default": null,
          "description": "The user's primary family (can be changed)",
          "format": "uuid",
          "type": [
            "string",
            "null"
          ]
        },
        "settings": {
          "default": null
        },
        "updated_at": {
          "format": "date-time",
          "type": "string"
        }
      },
      "required": [
        "created_at",
        "email",
        "email_verified",
        "id",
        "name",
        "updated_at"
      ],
      "type": "object"
    },
    "UserMembership": {
      "description": "A user's membership in a family",
      "properties": {
        "is_primary": {
          "type": "boolean"
        },
        "joined_at": {
          "format": "date-time",
          "type": "string"
        },
        "role": {
          "$ref": "../../codegen/primitives/InviteRole.schema.json"
        },
        "tenant_id": {
          "format": "uuid",
          "type": "string"
        },
        "tenant_name": {
          "type": "string"
        }
      },
      "required": [
        "is_primary",
        "joined_at",
        "role",
        "tenant_id",
        "tenant_name"
      ],
      "type": "object"
    }
  },
  "description": "Current user info (for /api/auth/me)",
  "properties": {
    "memberships": {
      "description": "User's family memberships",
      "items": {
        "$ref": "#/definitions/UserMembership"
      },
      "type": "array"
    },
    "user": {
      "$ref": "#/definitions/User"
    }
  },
  "required": [
    "memberships",
    "user"
  ],
  "title": "CurrentUser",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/DataExportRequest.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ExportStatus": {
      "description": "Status of a data export request",
      "enum": [
        "pending",
        "processing",
        "ready",
        "expired",
        "failed"
      ],
      "type": "string"
    }
  },
  "description": "A data export request",
  "properties": {
    "completed_at": {
      "default": null,
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "error_message": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "expires_at": {
      "default": null,
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "export_format": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "export_url": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "file_size_bytes": {
      "default": null,
      "format": "int64",
      "type": [
        "integer",
        "null"
      ]
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "started_at": {
      "default": null,
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "status": {
      "$ref": "#/definitions/ExportStatus"
    },
    "user_id": {
      "$ref": "../../codegen/primitives/UserId.schema.json"
    }
  },
  "required": [
    "created_at",
    "id",
    "status",
    "user_id"
  ],
  "title": "DataExportRequest",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/DeletionRequest.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "DeletionStatus": {
      "description": "Status of a deletion request",
      "enum": [
        "pending",
        "cancelled",
        "processing",
        "completed"
      ],
      "type": "string"
    }
  },
  "description": "A deletion request",
  "properties": {
    "completed_at": {
      "default": null,
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "email": {
      "type": "string"
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "reason": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "scheduled_for": {
      "default": null,
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "status": {
      "$ref": "#/definitions/DeletionStatus"
    },
    "user_id": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "created_at",
    "email",
    "id",
    "status"
  ],
  "title": "DeletionRequest",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/DeletionStatus.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Status of a deletion request",
  "enum": [
    "pending",
    "cancelled",
    "processing",
    "completed"
  ],
  "title": "DeletionStatus",
  "type": "string",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/ExportStatus.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Status of a data export request",
  "enum": [
    "pending",
    "processing",
    "ready",
    "expired",
    "failed"
  ],
  "title": "ExportStatus",
  "type": "string",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/FamilyInvitation.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "InviteType": {
      "description": "Type of family invitation",
      "oneOf": [
        {
          "description": "Sent to a specific email address",
          "enum": [
            "email"
          ],
          "type": "string"
        },
        {
          "description": "Shareable code (like Discord)",
          "enum": [
            "code"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "A family invitation",
  "properties": {
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "email": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "expires_at": {
      "default": null,
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "invite_code": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "invite_type": {
      "$ref": "#/definitions/InviteType"
    },
    "invited_by": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "max_uses": {
      "format": "int32",
      "type": "integer"
    },
    "role": {
      "$ref": "../../codegen/primitives/InviteRole.schema.json"
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "use_count": {
      "format": "int32",
      "type": "integer"
    }
  },
  "required": [
    "created_at",
    "id",
    "invite_type",
    "max_uses",
    "role",
    "tenant_id",
    "use_count"
  ],
  "title": "FamilyInvitation",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/InvitationInfo.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Public invitation info (for showing what user is joining)",
  "properties": {
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "is_valid": {
      "type": "boolean"
    },
    "role": {
      "$ref": "../../codegen/primitives/InviteRole.schema.json"
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "tenant_name": {
      "type": "string"
    }
  },
  "required": [
    "id",
    "is_valid",
    "role",
    "tenant_id",
    "tenant_name"
  ],
  "title": "InvitationInfo",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/InviteRole.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Role to assign when invitation is accepted",
  "enum": [
    "admin",
    "member",
    "guest"
  ],
  "title": "InviteRole",
  "type": "string",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/InviteType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Type of family invitation",
  "oneOf": [
    {
      "description": "Sent to a specific email address",
      "enum": [
        "email"
      ],
      "type": "string"
    },
    {
      "description": "Shareable code (like Discord)",
      "enum": [
        "code"
      ],
      "type": "string"
    }
  ],
  "title": "InviteType",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/JoinRequest.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "JoinRequestStatus": {
      "description": "Status of a join request",
      "enum": [
        "pending",
        "approved",
        "rejected"
      ],
      "type": "string"
    }
  },
  "description": "A request to join a family",
  "properties": {
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "message": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "review_note": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "reviewed_at": {
      "default": null,
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "reviewed_by": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "status": {
      "$ref": "#/definitions/JoinRequestStatus"
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "user_id": {
      "$ref": "../../codegen/primitives/UserId.schema.json"
    }
  },
  "required": [
    "created_at",
    "id",
    "status",
    "tenant_id",
    "user_id"
  ],
  "title": "JoinRequest",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/JoinRequestStatus.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Status of a join request",
  "enum": [
    "pending",
    "approved",
    "rejected"
  ],
  "title": "JoinRequestStatus",
  "type": "string",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/LoginRequest.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Request for email+password login",
  "properties": {
    "email": {
      "type": "string"
    },
    "password": {
      "type": "string"
    }
  },
  "required": [
    "email",
    "password"
  ],
  "title": "LoginRequest",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/MagicLink.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "MagicLinkPurpose": {
      "description": "Purpose of a magic link",
      "enum": [
        "login",
        "signup",
        "verify_email",
        "password_reset"
      ],
      "type": "string"
    }
  },
  "description": "A magic link for passwordless auth",
  "properties": {
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "email": {
      "type": "string"
    },
    "expires_at": {
      "format": "date-time",
      "type": "string"
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "metadata": {
      "default": null
    },
    "purpose": {
      "$ref": "#/definitions/MagicLinkPurpose"
    },
    "used_at": {
      "default": null,
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "created_at",
    "email",
    "expires_at",
    "id",
    "purpose"
  ],
  "title": "MagicLink",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/MagicLinkCreated.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Result of creating a magic link (includes raw token)",
  "properties": {
    "expires_at": {
      "format": "date-time",
      "type": "string"
    },
    "link_id": {
      "format": "uuid",
      "type": "string"
    },
    "token": {
      "type": "string"
    }
  },
  "required": [
    "expires_at",
    "link_id",
    "token"
  ],
  "title": "MagicLinkCreated",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/MagicLinkPurpose.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Purpose of a magic link",
  "enum": [
    "login",
    "signup",
    "verify_email",
    "password_reset"
  ],
  "title": "MagicLinkPurpose",
  "type": "string",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/MagicLinkRequest.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Request for magic link",
  "properties": {
    "email": {
      "type": "string"
    },
    "invite_code": {
      "default": null,
      "description": "Optional invite code for signup flow",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "email"
  ],
  "title": "MagicLinkRequest",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/PublicUser.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Public user info (safe to expose to other users)",
  "properties": {
    "avatar_url": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "id": {
      "$ref": "../../codegen/primitives/UserId.schema.json"
    },
    "name": {
      "type": "string"
    }
  },
  "required": [
    "id",
    "name"
  ],
  "title": "PublicUser",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/RecordConsentInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ConsentType": {
      "description": "Type of consent",
      "enum": [
        "terms_of_service",
        "privacy_policy",
        "marketing_emails",
        "ai_processing",
        "data_sharing",
        "analytics"
      ],
      "type": "string"
    }
  },
  "description": "Input for recording consent",
  "properties": {
    "consent_type": {
      "$ref": "#/definitions/ConsentType"
    },
    "granted": {
      "type": "boolean"
    },
    "version": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "consent_type",
    "granted"
  ],
  "title": "RecordConsentInput",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/RequestDeletionInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Input for requesting deletion",
  "properties": {
    "reason": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    }
  },
  "title": "RequestDeletionInput",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/ReviewJoinRequestInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Input for reviewing a join request",
  "properties": {
    "approved": {
      "type": "boolean"
    },
    "note": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "approved"
  ],
  "title": "ReviewJoinRequestInput",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/SessionCreated.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Result of creating a session (includes the raw token)",
  "properties": {
    "expires_at": {
      "format": "date-time",
      "type": "string"
    },
    "session_id": {
      "$ref": "../../codegen/primitives/SessionId.schema.json"
    },
    "token": {
      "type": "string"
    }
  },
  "required": [
    "expires_at",
    "session_id",
    "token"
  ],
  "title": "SessionCreated",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/SignupRequest.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Request for email+password signup",
  "properties": {
    "accept_privacy": {
      "type": "boolean"
    },
    "accept_terms": {
      "description": "Consent to required terms",
      "type": "boolean"
    },
    "email": {
      "type": "string"
    },
    "invite_code": {
      "default": null,
      "description": "Optional invite code to join a family",
      "type": [
        "string",
        "null"
      ]
    },
    "name": {
      "type": "string"
    },
    "password": {
      "type": "string"
    }
  },
  "required": [
    "accept_privacy",
    "accept_terms",
    "email",
    "name",
    "password"
  ],
  "title": "SignupRequest",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/UpdateUserInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Input for updating user profile",
  "properties": {
    "avatar_url": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "name": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "primary_tenant_id": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "settings": {
      "default": null
    }
  },
  "title": "UpdateUserInput",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/User.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A user's identity that can belong to multiple families\n\nUses `SystemEntityMeta` because users are not tenant-scoped - a single user can belong to multiple families.",
  "properties": {
    "avatar_url": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "deletion_requested_at": {
      "default": null,
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "email": {
      "type": "string"
    },
    "email_verified": {
      "type": "boolean"
    },
    "gdpr_consents": {
      "default": null
    },
    "id": {
      "$ref": "../../codegen/primitives/UserId.schema.json"
    },
    "name": {
      "type": "string"
    },
    "primary_tenant_id": {
      "default": null,
      "description": "The user's primary family (can be changed)",
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "settings": {
      "default": null
    },
    "updated_at": {
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "created_at",
    "email",
    "email_verified",
    "id",
    "name",
    "updated_at"
  ],
  "title": "User",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/auth/UserMembership.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A user's membership in a family",
  "properties": {
    "is_primary": {
      "type": "boolean"
    },
    "joined_at": {
      "format": "date-time",
      "type": "string"
    },
    "role": {
      "$ref": "../../codegen/primitives/InviteRole.schema.json"
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "tenant_name": {
      "type": "string"
    }
  },
  "required": [
    "is_primary",
    "joined_at",
    "role",
    "tenant_id",
    "tenant_name"
  ],
  "title": "UserMembership",
  "type": "object",
  "x-familiar-kind": "auth",
  "x-familiar-requires-auth": true,
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/config/AIProvider.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "AI Provider enumeration",
  "enum": [
    "openai",
    "anthropic",
    "google",
    "mock"
  ],
  "title": "AIProvider",
  "type": "string",
  "x-familiar-kind": "config",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/config/ModelConfig.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Model definition with all configuration",
  "properties": {
    "api_model_id": {
      "description": "The actual API model ID to send to the provider",
      "type": "string"
    },
    "context_window": {
      "description": "Context window size (tokens)",
      "format": "uint32",
      "minimum": 0.0,
      "type": "integer"
    },
    "deprecated": {
      "default": false,
      "description": "Whether this model is deprecated",
      "type": "boolean"
    },
    "id": {
      "description": "Unique identifier (e.g., \"gpt-4o\", \"claude-sonnet-4\")",
      "type": "string"
    },
    "name": {
      "description": "Human-readable name",
      "type": "string"
    },
    "notes": {
      "default": null,
      "description": "Notes about the model",
      "type": [
        "string",
        "null"
      ]
    },
    "provider": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/AIProvider.schema.json"
        }
      ],
      "description": "The provider"
    },
    "supports_json_mode": {
      "description": "Whether the model supports JSON mode",
      "type": "boolean"
    }
  },
  "required": [
    "api_model_id",
    "context_window",
    "id",
    "name",
    "provider",
    "supports_json_mode"
  ],
  "title": "ModelConfig",
  "type": "object",
  "x-familiar-kind": "config",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/config/SystemDomain.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "ingestion",
    "physics",
    "analysis",
    "maintenance"
  ],
  "title": "SystemDomain",
  "type": "string",
  "x-familiar-kind": "config",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/config/SystemManifest.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "SystemDomain": {
      "enum": [
        "ingestion",
        "physics",
        "analysis",
        "maintenance"
      ],
      "type": "string"
    },
    "SystemTrigger": {
      "oneOf": [
        {
          "enum": [
            "on_demand"
          ],
          "type": "string"
        },
        {
          "additionalProperties": false,
          "properties": {
            "event": {
              "type": "string"
            }
          },
          "required": [
            "event"
          ],
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "schedule": {
              "type": "string"
            }
          },
          "required": [
            "schedule"
          ],
          "type": "object"
        }
      ]
    }
  },
  "properties": {
    "description": {
      "type": "string"
    },
    "domain": {
      "$ref": "#/definitions/SystemDomain"
    },
    "id": {
      "type": "string"
    },
    "reads": {
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "trigger": {
      "$ref": "#/definitions/SystemTrigger"
    },
    "writes": {
      "items": {
        "type": "string"
      },
      "type": "array"
    }
  },
  "required": [
    "description",
    "domain",
    "id",
    "reads",
    "trigger",
    "writes"
  ],
  "title": "SystemManifest",
  "type": "object",
  "x-familiar-kind": "config",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/config/SystemTrigger.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "oneOf": [
    {
      "enum": [
        "on_demand"
      ],
      "type": "string"
    },
    {
      "additionalProperties": false,
      "properties": {
        "event": {
          "type": "string"
        }
      },
      "required": [
        "event"
      ],
      "type": "object"
    },
    {
      "additionalProperties": false,
      "properties": {
        "schedule": {
          "type": "string"
        }
      },
      "required": [
        "schedule"
      ],
      "type": "object"
    }
  ],
  "title": "SystemTrigger",
  "x-familiar-kind": "config",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/contracts/EnvelopeV1.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Payload": {
      "description": "Discriminated union of all payload types\n\nThis enum contains ALL message types in the system. The `type` tag distinguishes between different payloads, enabling routing without deserializing the full message.\n\n## Naming Convention\n\n- Commands: verb form (e.g., `CourseStart`, `Signup`) - Events: past tense (e.g., `CourseStarted`, `SignupCompleted`) - Traces: special `Trace` variant with sub-typing",
      "oneOf": [
        {
          "description": "Start a new course from a weave",
          "properties": {
            "blocks": {
              "description": "Multimodal blocks (images, audio, etc.)",
              "items": true,
              "type": [
                "array",
                "null"
              ]
            },
            "content": {
              "description": "Raw text content",
              "type": "string"
            },
            "context": {
              "description": "Optional context",
              "type": [
                "string",
                "null"
              ]
            },
            "conversation_history": {
              "default": [],
              "description": "Prior conversation for context",
              "items": true,
              "type": "array"
            },
            "type": {
              "enum": [
                "course_start"
              ],
              "type": "string"
            },
            "weave_id": {
              "description": "The weave (user input) ID",
              "format": "uuid",
              "type": "string"
            }
          },
          "required": [
            "content",
            "type",
            "weave_id"
          ],
          "type": "object"
        },
        {
          "description": "Continue an existing course with additional user input",
          "properties": {
            "blocks": {
              "description": "Optional multimodal blocks",
              "items": true,
              "type": [
                "array",
                "null"
              ]
            },
            "type": {
              "enum": [
                "course_continue"
              ],
              "type": "string"
            },
            "user_message": {
              "description": "The new user message",
              "type": "string"
            }
          },
          "required": [
            "type",
            "user_message"
          ],
          "type": "object"
        },
        {
          "description": "Cancel a running course",
          "properties": {
            "reason": {
              "description": "Reason for cancellation",
              "type": [
                "string",
                "null"
              ]
            },
            "type": {
              "enum": [
                "course_cancel"
              ],
              "type": "string"
            }
          },
          "required": [
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Retry a failed course",
          "properties": {
            "original_command_id": {
              "description": "Original command to retry",
              "format": "uuid",
              "type": "string"
            },
            "type": {
              "enum": [
                "course_retry"
              ],
              "type": "string"
            }
          },
          "required": [
            "original_command_id",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Course has started processing",
          "properties": {
            "type": {
              "enum": [
                "course_started"
              ],
              "type": "string"
            },
            "weave_id": {
              "description": "The weave that started this course",
              "format": "uuid",
              "type": "string"
            }
          },
          "required": [
            "type",
            "weave_id"
          ],
          "type": "object"
        },
        {
          "description": "Segmentation phase completed",
          "properties": {
            "type": {
              "enum": [
                "course_segmented"
              ],
              "type": "string"
            },
            "unit_count": {
              "description": "Number of segments/units identified",
              "format": "uint",
              "minimum": 0.0,
              "type": "integer"
            }
          },
          "required": [
            "type",
            "unit_count"
          ],
          "type": "object"
        },
        {
          "description": "Classification phase completed",
          "properties": {
            "entity_types": {
              "description": "Entity types identified",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "physics_summary": {
              "description": "Physics hints computed (optional)",
              "type": [
                "string",
                "null"
              ]
            },
            "type": {
              "enum": [
                "course_classified"
              ],
              "type": "string"
            }
          },
          "required": [
            "entity_types",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Course completed successfully",
          "properties": {
            "duration_ms": {
              "description": "Duration in milliseconds",
              "format": "uint64",
              "minimum": 0.0,
              "type": "integer"
            },
            "response": {
              "description": "The final response to send to user",
              "type": "string"
            },
            "tokens_used": {
              "description": "Token usage (if tracked)",
              "format": "uint32",
              "minimum": 0.0,
              "type": [
                "integer",
                "null"
              ]
            },
            "type": {
              "enum": [
                "course_completed"
              ],
              "type": "string"
            }
          },
          "required": [
            "duration_ms",
            "response",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Course failed",
          "properties": {
            "error": {
              "description": "Error message (sanitized for storage)",
              "type": "string"
            },
            "error_code": {
              "description": "Error code for programmatic handling",
              "type": [
                "string",
                "null"
              ]
            },
            "retryable": {
              "default": false,
              "description": "Whether this is retryable",
              "type": "boolean"
            },
            "type": {
              "enum": [
                "course_failed"
              ],
              "type": "string"
            }
          },
          "required": [
            "error",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Course was cancelled",
          "properties": {
            "cancelled_by": {
              "description": "Who cancelled (user, system, timeout)",
              "type": "string"
            },
            "reason": {
              "description": "Reason for cancellation",
              "type": [
                "string",
                "null"
              ]
            },
            "type": {
              "enum": [
                "course_cancelled"
              ],
              "type": "string"
            }
          },
          "required": [
            "cancelled_by",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Course is being retried",
          "properties": {
            "attempt": {
              "description": "Retry attempt number",
              "format": "uint32",
              "minimum": 0.0,
              "type": "integer"
            },
            "original_error": {
              "description": "Original error that triggered retry",
              "type": "string"
            },
            "type": {
              "enum": [
                "course_retrying"
              ],
              "type": "string"
            }
          },
          "required": [
            "attempt",
            "original_error",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "User signup request",
          "properties": {
            "consents": {
              "allOf": [
                {
                  "$ref": "#/definitions/SignupConsents"
                }
              ],
              "description": "User consent flags"
            },
            "email": {
              "description": "User's email address",
              "type": "string"
            },
            "invite_code": {
              "description": "Invite code if signing up via invitation",
              "type": [
                "string",
                "null"
              ]
            },
            "name": {
              "description": "User's display name",
              "type": "string"
            },
            "password": {
              "description": "User's password (will be hashed by worker)",
              "type": "string"
            },
            "request_context": {
              "anyOf": [
                {
                  "$ref": "#/definitions/RequestContext"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Request context for audit"
            },
            "type": {
              "enum": [
                "signup"
              ],
              "type": "string"
            }
          },
          "required": [
            "consents",
            "email",
            "name",
            "password",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Create a new family/tenant",
          "properties": {
            "family_name": {
              "description": "Name for the new family",
              "type": "string"
            },
            "type": {
              "enum": [
                "create_family"
              ],
              "type": "string"
            }
          },
          "required": [
            "family_name",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Accept an invitation to join a family",
          "properties": {
            "invitation_code": {
              "description": "The invitation code to accept",
              "type": "string"
            },
            "type": {
              "enum": [
                "accept_invitation"
              ],
              "type": "string"
            }
          },
          "required": [
            "invitation_code",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Signup completed successfully",
          "properties": {
            "needs_family": {
              "description": "Whether the user needs to create/join a family",
              "type": "boolean"
            },
            "session_token": {
              "description": "Session token for the new user",
              "type": "string"
            },
            "type": {
              "enum": [
                "signup_completed"
              ],
              "type": "string"
            }
          },
          "required": [
            "needs_family",
            "session_token",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Family creation completed",
          "properties": {
            "tenant_name": {
              "description": "Name of the created tenant",
              "type": "string"
            },
            "type": {
              "enum": [
                "family_created"
              ],
              "type": "string"
            }
          },
          "required": [
            "tenant_name",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Invitation accepted",
          "properties": {
            "family_name": {
              "description": "Name of the family joined",
              "type": "string"
            },
            "type": {
              "enum": [
                "invitation_accepted"
              ],
              "type": "string"
            }
          },
          "required": [
            "family_name",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Onboarding failed",
          "properties": {
            "error_code": {
              "description": "Error code for programmatic handling",
              "type": "string"
            },
            "message": {
              "description": "Human-readable error message",
              "type": "string"
            },
            "type": {
              "enum": [
                "onboarding_failed"
              ],
              "type": "string"
            }
          },
          "required": [
            "error_code",
            "message",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Trace event for UI streaming",
          "properties": {
            "agent": {
              "description": "Agent that produced this trace",
              "type": [
                "string",
                "null"
              ]
            },
            "duration_ms": {
              "description": "Duration in milliseconds",
              "format": "uint64",
              "minimum": 0.0,
              "type": [
                "integer",
                "null"
              ]
            },
            "kind": {
              "allOf": [
                {
                  "$ref": "#/definitions/TraceKind"
                }
              ],
              "description": "Type of trace"
            },
            "message": {
              "description": "Human-readable message",
              "type": "string"
            },
            "parent_span_id": {
              "description": "Parent span (for hierarchy)",
              "type": [
                "string",
                "null"
              ]
            },
            "seq": {
              "description": "Monotonic sequence number per-course",
              "format": "uint64",
              "minimum": 0.0,
              "type": "integer"
            },
            "span_id": {
              "description": "Span identifier",
              "type": "string"
            },
            "status": {
              "allOf": [
                {
                  "$ref": "#/definitions/TraceStatus"
                }
              ],
              "description": "Status of this trace unit"
            },
            "tokens": {
              "description": "Response tokens (if kind == Token)",
              "type": [
                "string",
                "null"
              ]
            },
            "tool_args": {
              "description": "Tool arguments (redacted/summarized)"
            },
            "tool_name": {
              "description": "Tool name (if kind == Tool)",
              "type": [
                "string",
                "null"
              ]
            },
            "tool_result": {
              "description": "Tool result (summary only)",
              "type": [
                "string",
                "null"
              ]
            },
            "type": {
              "enum": [
                "trace"
              ],
              "type": "string"
            }
          },
          "required": [
            "kind",
            "message",
            "seq",
            "span_id",
            "status",
            "type"
          ],
          "type": "object"
        }
      ]
    },
    "ProducerInfo": {
      "description": "Producer metadata for tracing and debugging",
      "properties": {
        "build": {
          "description": "Build version (git hash, version tag)",
          "type": [
            "string",
            "null"
          ]
        },
        "instance": {
          "description": "Instance identifier (e.g., pod name, hostname)",
          "type": "string"
        },
        "service": {
          "description": "Service name (e.g., \"familiar-api\", \"familiar-worker\")",
          "type": "string"
        }
      },
      "required": [
        "instance",
        "service"
      ],
      "type": "object"
    },
    "RequestContext": {
      "description": "Request context for audit logging",
      "properties": {
        "ip_address": {
          "description": "Client IP address (may be behind proxy)",
          "type": [
            "string",
            "null"
          ]
        },
        "request_id": {
          "description": "Request ID for correlation",
          "type": [
            "string",
            "null"
          ]
        },
        "user_agent": {
          "description": "User agent string",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "SchemaInfo": {
      "description": "Schema metadata for validation and evolution",
      "properties": {
        "format": {
          "description": "Serialization format (\"json\", \"protobuf\", \"avro\")",
          "type": "string"
        },
        "subject": {
          "description": "Schema subject in Schema Registry",
          "type": "string"
        },
        "version": {
          "description": "Schema version",
          "format": "uint32",
          "minimum": 0.0,
          "type": "integer"
        }
      },
      "required": [
        "format",
        "subject",
        "version"
      ],
      "type": "object"
    },
    "SignupConsents": {
      "description": "User consent flags for signup",
      "properties": {
        "privacy": {
          "description": "User accepted privacy policy",
          "type": "boolean"
        },
        "terms": {
          "description": "User accepted terms of service",
          "type": "boolean"
        }
      },
      "required": [
        "privacy",
        "terms"
      ],
      "type": "object"
    },
    "TraceKind": {
      "description": "Type of trace event",
      "oneOf": [
        {
          "description": "Overall workflow step",
          "enum": [
            "step"
          ],
          "type": "string"
        },
        {
          "description": "Agent thinking/reasoning",
          "enum": [
            "thought"
          ],
          "type": "string"
        },
        {
          "description": "Tool invocation",
          "enum": [
            "tool"
          ],
          "type": "string"
        },
        {
          "description": "Response token stream",
          "enum": [
            "token"
          ],
          "type": "string"
        },
        {
          "description": "Error occurred",
          "enum": [
            "error"
          ],
          "type": "string"
        },
        {
          "description": "Metric/timing data",
          "enum": [
            "metric"
          ],
          "type": "string"
        }
      ]
    },
    "TraceStatus": {
      "description": "Status of a trace unit",
      "oneOf": [
        {
          "description": "Step started",
          "enum": [
            "started"
          ],
          "type": "string"
        },
        {
          "description": "Step in progress (for long-running)",
          "enum": [
            "in_progress"
          ],
          "type": "string"
        },
        {
          "description": "Step completed successfully",
          "enum": [
            "completed"
          ],
          "type": "string"
        },
        {
          "description": "Step failed",
          "enum": [
            "failed"
          ],
          "type": "string"
        },
        {
          "description": "Step was cancelled",
          "enum": [
            "cancelled"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Universal message envelope for all Kafka communication\n\nThis is the SINGLE envelope type used for commands, events, and traces. Payload type is distinguished by the discriminated union.\n\n## Key Design Decisions\n\n- **`message_id`**: ULID for natural time-ordering and uniqueness - **`message_type`**: Dot-notation for routing (e.g., `familiar.course.command.start`) - **`correlation_id`**: Often equals `course_id` for course workflows - **`causation_id`**: Points to upstream message that caused this one\n\n## Kafka Record Mapping\n\n- **Key**: `{tenant_id}:{correlation_id}` for partition affinity - **Value**: Serialized EnvelopeV1 (JSON) - **Headers**: `message_type`, `correlation_id`, `schema_id`, `content_type`",
  "properties": {
    "causation_id": {
      "description": "Causation ID (upstream message that caused this)",
      "type": [
        "string",
        "null"
      ]
    },
    "correlation_id": {
      "description": "Correlation ID (ties together workflow, often == course_id)",
      "type": "string"
    },
    "course_id": {
      "description": "Course context (correlation_id for course workflows)",
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "message_id": {
      "description": "Unique message ID (ULID for natural ordering)",
      "type": "string"
    },
    "message_type": {
      "description": "Message type for routing (e.g., \"familiar.course.command.start\")",
      "type": "string"
    },
    "occurred_at": {
      "description": "When this message was created",
      "format": "date-time",
      "type": "string"
    },
    "payload": {
      "allOf": [
        {
          "$ref": "#/definitions/Payload"
        }
      ],
      "description": "The actual message payload"
    },
    "producer": {
      "allOf": [
        {
          "$ref": "#/definitions/ProducerInfo"
        }
      ],
      "description": "Information about the message producer"
    },
    "schema": {
      "allOf": [
        {
          "$ref": "#/definitions/SchemaInfo"
        }
      ],
      "description": "Schema information for validation"
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "thread_id": {
      "description": "Thread context (conversation) - optional for non-conversation messages",
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "user_id": {
      "$ref": "../../codegen/primitives/UserId.schema.json"
    }
  },
  "required": [
    "correlation_id",
    "message_id",
    "message_type",
    "occurred_at",
    "payload",
    "producer",
    "schema",
    "tenant_id",
    "user_id"
  ],
  "title": "EnvelopeV1",
  "type": "object",
  "x-familiar-kind": "contract",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/contracts/Payload.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "RequestContext": {
      "description": "Request context for audit logging",
      "properties": {
        "ip_address": {
          "description": "Client IP address (may be behind proxy)",
          "type": [
            "string",
            "null"
          ]
        },
        "request_id": {
          "description": "Request ID for correlation",
          "type": [
            "string",
            "null"
          ]
        },
        "user_agent": {
          "description": "User agent string",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "SignupConsents": {
      "description": "User consent flags for signup",
      "properties": {
        "privacy": {
          "description": "User accepted privacy policy",
          "type": "boolean"
        },
        "terms": {
          "description": "User accepted terms of service",
          "type": "boolean"
        }
      },
      "required": [
        "privacy",
        "terms"
      ],
      "type": "object"
    },
    "TraceKind": {
      "description": "Type of trace event",
      "oneOf": [
        {
          "description": "Overall workflow step",
          "enum": [
            "step"
          ],
          "type": "string"
        },
        {
          "description": "Agent thinking/reasoning",
          "enum": [
            "thought"
          ],
          "type": "string"
        },
        {
          "description": "Tool invocation",
          "enum": [
            "tool"
          ],
          "type": "string"
        },
        {
          "description": "Response token stream",
          "enum": [
            "token"
          ],
          "type": "string"
        },
        {
          "description": "Error occurred",
          "enum": [
            "error"
          ],
          "type": "string"
        },
        {
          "description": "Metric/timing data",
          "enum": [
            "metric"
          ],
          "type": "string"
        }
      ]
    },
    "TraceStatus": {
      "description": "Status of a trace unit",
      "oneOf": [
        {
          "description": "Step started",
          "enum": [
            "started"
          ],
          "type": "string"
        },
        {
          "description": "Step in progress (for long-running)",
          "enum": [
            "in_progress"
          ],
          "type": "string"
        },
        {
          "description": "Step completed successfully",
          "enum": [
            "completed"
          ],
          "type": "string"
        },
        {
          "description": "Step failed",
          "enum": [
            "failed"
          ],
          "type": "string"
        },
        {
          "description": "Step was cancelled",
          "enum": [
            "cancelled"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Discriminated union of all payload types\n\nThis enum contains ALL message types in the system. The `type` tag distinguishes between different payloads, enabling routing without deserializing the full message.\n\n## Naming Convention\n\n- Commands: verb form (e.g., `CourseStart`, `Signup`) - Events: past tense (e.g., `CourseStarted`, `SignupCompleted`) - Traces: special `Trace` variant with sub-typing",
  "oneOf": [
    {
      "description": "Start a new course from a weave",
      "properties": {
        "blocks": {
          "description": "Multimodal blocks (images, audio, etc.)",
          "items": true,
          "type": [
            "array",
            "null"
          ]
        },
        "content": {
          "description": "Raw text content",
          "type": "string"
        },
        "context": {
          "description": "Optional context",
          "type": [
            "string",
            "null"
          ]
        },
        "conversation_history": {
          "default": [],
          "description": "Prior conversation for context",
          "items": true,
          "type": "array"
        },
        "type": {
          "enum": [
            "course_start"
          ],
          "type": "string"
        },
        "weave_id": {
          "description": "The weave (user input) ID",
          "format": "uuid",
          "type": "string"
        }
      },
      "required": [
        "content",
        "type",
        "weave_id"
      ],
      "type": "object"
    },
    {
      "description": "Continue an existing course with additional user input",
      "properties": {
        "blocks": {
          "description": "Optional multimodal blocks",
          "items": true,
          "type": [
            "array",
            "null"
          ]
        },
        "type": {
          "enum": [
            "course_continue"
          ],
          "type": "string"
        },
        "user_message": {
          "description": "The new user message",
          "type": "string"
        }
      },
      "required": [
        "type",
        "user_message"
      ],
      "type": "object"
    },
    {
      "description": "Cancel a running course",
      "properties": {
        "reason": {
          "description": "Reason for cancellation",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "enum": [
            "course_cancel"
          ],
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Retry a failed course",
      "properties": {
        "original_command_id": {
          "description": "Original command to retry",
          "format": "uuid",
          "type": "string"
        },
        "type": {
          "enum": [
            "course_retry"
          ],
          "type": "string"
        }
      },
      "required": [
        "original_command_id",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Course has started processing",
      "properties": {
        "type": {
          "enum": [
            "course_started"
          ],
          "type": "string"
        },
        "weave_id": {
          "description": "The weave that started this course",
          "format": "uuid",
          "type": "string"
        }
      },
      "required": [
        "type",
        "weave_id"
      ],
      "type": "object"
    },
    {
      "description": "Segmentation phase completed",
      "properties": {
        "type": {
          "enum": [
            "course_segmented"
          ],
          "type": "string"
        },
        "unit_count": {
          "description": "Number of segments/units identified",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        }
      },
      "required": [
        "type",
        "unit_count"
      ],
      "type": "object"
    },
    {
      "description": "Classification phase completed",
      "properties": {
        "entity_types": {
          "description": "Entity types identified",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "physics_summary": {
          "description": "Physics hints computed (optional)",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "enum": [
            "course_classified"
          ],
          "type": "string"
        }
      },
      "required": [
        "entity_types",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Course completed successfully",
      "properties": {
        "duration_ms": {
          "description": "Duration in milliseconds",
          "format": "uint64",
          "minimum": 0.0,
          "type": "integer"
        },
        "response": {
          "description": "The final response to send to user",
          "type": "string"
        },
        "tokens_used": {
          "description": "Token usage (if tracked)",
          "format": "uint32",
          "minimum": 0.0,
          "type": [
            "integer",
            "null"
          ]
        },
        "type": {
          "enum": [
            "course_completed"
          ],
          "type": "string"
        }
      },
      "required": [
        "duration_ms",
        "response",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Course failed",
      "properties": {
        "error": {
          "description": "Error message (sanitized for storage)",
          "type": "string"
        },
        "error_code": {
          "description": "Error code for programmatic handling",
          "type": [
            "string",
            "null"
          ]
        },
        "retryable": {
          "default": false,
          "description": "Whether this is retryable",
          "type": "boolean"
        },
        "type": {
          "enum": [
            "course_failed"
          ],
          "type": "string"
        }
      },
      "required": [
        "error",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Course was cancelled",
      "properties": {
        "cancelled_by": {
          "description": "Who cancelled (user, system, timeout)",
          "type": "string"
        },
        "reason": {
          "description": "Reason for cancellation",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "enum": [
            "course_cancelled"
          ],
          "type": "string"
        }
      },
      "required": [
        "cancelled_by",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Course is being retried",
      "properties": {
        "attempt": {
          "description": "Retry attempt number",
          "format": "uint32",
          "minimum": 0.0,
          "type": "integer"
        },
        "original_error": {
          "description": "Original error that triggered retry",
          "type": "string"
        },
        "type": {
          "enum": [
            "course_retrying"
          ],
          "type": "string"
        }
      },
      "required": [
        "attempt",
        "original_error",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "User signup request",
      "properties": {
        "consents": {
          "allOf": [
            {
              "$ref": "#/definitions/SignupConsents"
            }
          ],
          "description": "User consent flags"
        },
        "email": {
          "description": "User's email address",
          "type": "string"
        },
        "invite_code": {
          "description": "Invite code if signing up via invitation",
          "type": [
            "string",
            "null"
          ]
        },
        "name": {
          "description": "User's display name",
          "type": "string"
        },
        "password": {
          "description": "User's password (will be hashed by worker)",
          "type": "string"
        },
        "request_context": {
          "anyOf": [
            {
              "$ref": "#/definitions/RequestContext"
            },
            {
              "type": "null"
            }
          ],
          "description": "Request context for audit"
        },
        "type": {
          "enum": [
            "signup"
          ],
          "type": "string"
        }
      },
      "required": [
        "consents",
        "email",
        "name",
        "password",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Create a new family/tenant",
      "properties": {
        "family_name": {
          "description": "Name for the new family",
          "type": "string"
        },
        "type": {
          "enum": [
            "create_family"
          ],
          "type": "string"
        }
      },
      "required": [
        "family_name",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Accept an invitation to join a family",
      "properties": {
        "invitation_code": {
          "description": "The invitation code to accept",
          "type": "string"
        },
        "type": {
          "enum": [
            "accept_invitation"
          ],
          "type": "string"
        }
      },
      "required": [
        "invitation_code",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Signup completed successfully",
      "properties": {
        "needs_family": {
          "description": "Whether the user needs to create/join a family",
          "type": "boolean"
        },
        "session_token": {
          "description": "Session token for the new user",
          "type": "string"
        },
        "type": {
          "enum": [
            "signup_completed"
          ],
          "type": "string"
        }
      },
      "required": [
        "needs_family",
        "session_token",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Family creation completed",
      "properties": {
        "tenant_name": {
          "description": "Name of the created tenant",
          "type": "string"
        },
        "type": {
          "enum": [
            "family_created"
          ],
          "type": "string"
        }
      },
      "required": [
        "tenant_name",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Invitation accepted",
      "properties": {
        "family_name": {
          "description": "Name of the family joined",
          "type": "string"
        },
        "type": {
          "enum": [
            "invitation_accepted"
          ],
          "type": "string"
        }
      },
      "required": [
        "family_name",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Onboarding failed",
      "properties": {
        "error_code": {
          "description": "Error code for programmatic handling",
          "type": "string"
        },
        "message": {
          "description": "Human-readable error message",
          "type": "string"
        },
        "type": {
          "enum": [
            "onboarding_failed"
          ],
          "type": "string"
        }
      },
      "required": [
        "error_code",
        "message",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Trace event for UI streaming",
      "properties": {
        "agent": {
          "description": "Agent that produced this trace",
          "type": [
            "string",
            "null"
          ]
        },
        "duration_ms": {
          "description": "Duration in milliseconds",
          "format": "uint64",
          "minimum": 0.0,
          "type": [
            "integer",
            "null"
          ]
        },
        "kind": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceKind"
            }
          ],
          "description": "Type of trace"
        },
        "message": {
          "description": "Human-readable message",
          "type": "string"
        },
        "parent_span_id": {
          "description": "Parent span (for hierarchy)",
          "type": [
            "string",
            "null"
          ]
        },
        "seq": {
          "description": "Monotonic sequence number per-course",
          "format": "uint64",
          "minimum": 0.0,
          "type": "integer"
        },
        "span_id": {
          "description": "Span identifier",
          "type": "string"
        },
        "status": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceStatus"
            }
          ],
          "description": "Status of this trace unit"
        },
        "tokens": {
          "description": "Response tokens (if kind == Token)",
          "type": [
            "string",
            "null"
          ]
        },
        "tool_args": {
          "description": "Tool arguments (redacted/summarized)"
        },
        "tool_name": {
          "description": "Tool name (if kind == Tool)",
          "type": [
            "string",
            "null"
          ]
        },
        "tool_result": {
          "description": "Tool result (summary only)",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "enum": [
            "trace"
          ],
          "type": "string"
        }
      },
      "required": [
        "kind",
        "message",
        "seq",
        "span_id",
        "status",
        "type"
      ],
      "type": "object"
    }
  ],
  "title": "Payload",
  "x-familiar-kind": "contract",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/contracts/ProducerInfo.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Producer metadata for tracing and debugging",
  "properties": {
    "build": {
      "description": "Build version (git hash, version tag)",
      "type": [
        "string",
        "null"
      ]
    },
    "instance": {
      "description": "Instance identifier (e.g., pod name, hostname)",
      "type": "string"
    },
    "service": {
      "description": "Service name (e.g., \"familiar-api\", \"familiar-worker\")",
      "type": "string"
    }
  },
  "required": [
    "instance",
    "service"
  ],
  "title": "ProducerInfo",
  "type": "object",
  "x-familiar-kind": "contract",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/contracts/RequestContext.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Request context for audit logging",
  "properties": {
    "ip_address": {
      "description": "Client IP address (may be behind proxy)",
      "type": [
        "string",
        "null"
      ]
    },
    "request_id": {
      "description": "Request ID for correlation",
      "type": [
        "string",
        "null"
      ]
    },
    "user_agent": {
      "description": "User agent string",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "title": "RequestContext",
  "type": "object",
  "x-familiar-kind": "contract",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/contracts/SchemaInfo.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Schema metadata for validation and evolution",
  "properties": {
    "format": {
      "description": "Serialization format (\"json\", \"protobuf\", \"avro\")",
      "type": "string"
    },
    "subject": {
      "description": "Schema subject in Schema Registry",
      "type": "string"
    },
    "version": {
      "description": "Schema version",
      "format": "uint32",
      "minimum": 0.0,
      "type": "integer"
    }
  },
  "required": [
    "format",
    "subject",
    "version"
  ],
  "title": "SchemaInfo",
  "type": "object",
  "x-familiar-kind": "contract",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/contracts/SignupConsents.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "User consent flags for signup",
  "properties": {
    "privacy": {
      "description": "User accepted privacy policy",
      "type": "boolean"
    },
    "terms": {
      "description": "User accepted terms of service",
      "type": "boolean"
    }
  },
  "required": [
    "privacy",
    "terms"
  ],
  "title": "SignupConsents",
  "type": "object",
  "x-familiar-kind": "contract",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/contracts/TraceKind.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Type of trace event",
  "oneOf": [
    {
      "description": "Overall workflow step",
      "enum": [
        "step"
      ],
      "type": "string"
    },
    {
      "description": "Agent thinking/reasoning",
      "enum": [
        "thought"
      ],
      "type": "string"
    },
    {
      "description": "Tool invocation",
      "enum": [
        "tool"
      ],
      "type": "string"
    },
    {
      "description": "Response token stream",
      "enum": [
        "token"
      ],
      "type": "string"
    },
    {
      "description": "Error occurred",
      "enum": [
        "error"
      ],
      "type": "string"
    },
    {
      "description": "Metric/timing data",
      "enum": [
        "metric"
      ],
      "type": "string"
    }
  ],
  "title": "TraceKind",
  "x-familiar-kind": "contract",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/contracts/TraceStatus.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Status of a trace unit",
  "oneOf": [
    {
      "description": "Step started",
      "enum": [
        "started"
      ],
      "type": "string"
    },
    {
      "description": "Step in progress (for long-running)",
      "enum": [
        "in_progress"
      ],
      "type": "string"
    },
    {
      "description": "Step completed successfully",
      "enum": [
        "completed"
      ],
      "type": "string"
    },
    {
      "description": "Step failed",
      "enum": [
        "failed"
      ],
      "type": "string"
    },
    {
      "description": "Step was cancelled",
      "enum": [
        "cancelled"
      ],
      "type": "string"
    }
  ],
  "title": "TraceStatus",
  "x-familiar-kind": "contract",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/Channel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ChannelType": {
      "description": "Type of channel",
      "oneOf": [
        {
          "description": "Personal channel for a single user",
          "enum": [
            "personal"
          ],
          "type": "string"
        },
        {
          "description": "Family channel shared by all tenant members",
          "enum": [
            "family"
          ],
          "type": "string"
        },
        {
          "description": "Shared channel for specific members",
          "enum": [
            "shared"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "A channel (conversation space)",
  "properties": {
    "channel_type": {
      "$ref": "#/definitions/ChannelType"
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "description": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "id": {
      "$ref": "../../codegen/primitives/ChannelId.schema.json"
    },
    "name": {
      "type": "string"
    },
    "owner_id": {
      "default": null,
      "description": "Owner of the channel (None for family channels)",
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "settings": {
      "default": null
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "updated_at": {
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "channel_type",
    "created_at",
    "id",
    "name",
    "tenant_id",
    "updated_at"
  ],
  "title": "Channel",
  "type": "object",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/ChannelType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Type of channel",
  "oneOf": [
    {
      "description": "Personal channel for a single user",
      "enum": [
        "personal"
      ],
      "type": "string"
    },
    {
      "description": "Family channel shared by all tenant members",
      "enum": [
        "family"
      ],
      "type": "string"
    },
    {
      "description": "Shared channel for specific members",
      "enum": [
        "shared"
      ],
      "type": "string"
    }
  ],
  "title": "ChannelType",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/ConversationMessage.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Simplified message for conversation history (LLM context)",
  "properties": {
    "content": {
      "type": "string"
    },
    "role": {
      "type": "string"
    }
  },
  "required": [
    "content",
    "role"
  ],
  "title": "ConversationMessage",
  "type": "object",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/CreateChannelInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ChannelType": {
      "description": "Type of channel",
      "oneOf": [
        {
          "description": "Personal channel for a single user",
          "enum": [
            "personal"
          ],
          "type": "string"
        },
        {
          "description": "Family channel shared by all tenant members",
          "enum": [
            "family"
          ],
          "type": "string"
        },
        {
          "description": "Shared channel for specific members",
          "enum": [
            "shared"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Input for creating a new channel",
  "properties": {
    "channel_type": {
      "anyOf": [
        {
          "$ref": "#/definitions/ChannelType"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "description": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "name": {
      "type": "string"
    },
    "owner_id": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    }
  },
  "required": [
    "name",
    "tenant_id"
  ],
  "title": "CreateChannelInput",
  "type": "object",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/CreateEntityInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "EntityPhysics": {
      "description": "Physics state for an entity",
      "properties": {
        "arousal": {
          "format": "double",
          "type": "number"
        },
        "epistemic": {
          "format": "double",
          "type": "number"
        },
        "significance": {
          "format": "double",
          "type": "number"
        },
        "valence": {
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "arousal",
        "epistemic",
        "significance",
        "valence"
      ],
      "type": "object"
    },
    "EntityStatus": {
      "description": "HILT (Human in the Loop) status for entity approval",
      "enum": [
        "pending",
        "approved",
        "rejected",
        "auto_spawned"
      ],
      "type": "string"
    },
    "FamiliarEntityType": {
      "description": "Type of familiar entity",
      "enum": [
        "MOMENT",
        "PULSE",
        "INTENT",
        "THREAD",
        "BOND",
        "MOTIF",
        "FILAMENT",
        "FOCUS"
      ],
      "type": "string"
    }
  },
  "description": "Input for creating a new familiar entity",
  "properties": {
    "content": {
      "type": "string"
    },
    "entity_type": {
      "$ref": "#/definitions/FamiliarEntityType"
    },
    "metadata": {
      "default": null
    },
    "physics": {
      "anyOf": [
        {
          "$ref": "#/definitions/EntityPhysics"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "source_channel_id": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "source_message_id": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/definitions/EntityStatus"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "subject": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    }
  },
  "required": [
    "content",
    "entity_type",
    "tenant_id"
  ],
  "title": "CreateEntityInput",
  "type": "object",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/CreateMessageInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Input for creating a new message",
  "properties": {
    "agent_speaker": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "channel_id": {
      "$ref": "../../codegen/primitives/ChannelId.schema.json"
    },
    "content": {
      "type": "string"
    },
    "metadata": {
      "default": null
    },
    "parent_id": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "role": {
      "$ref": "../../codegen/primitives/MessageRole.schema.json"
    },
    "sender_id": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "thinking_steps": {
      "default": null
    },
    "tool_calls": {
      "default": null
    },
    "weave_result": {
      "default": null
    }
  },
  "required": [
    "channel_id",
    "content",
    "role"
  ],
  "title": "CreateMessageInput",
  "type": "object",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/EntityPhysics.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Physics state for an entity",
  "properties": {
    "arousal": {
      "format": "double",
      "type": "number"
    },
    "epistemic": {
      "format": "double",
      "type": "number"
    },
    "significance": {
      "format": "double",
      "type": "number"
    },
    "valence": {
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "arousal",
    "epistemic",
    "significance",
    "valence"
  ],
  "title": "EntityPhysics",
  "type": "object",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/EntityStatus.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "HILT (Human in the Loop) status for entity approval",
  "enum": [
    "pending",
    "approved",
    "rejected",
    "auto_spawned"
  ],
  "title": "EntityStatus",
  "type": "string",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/FamiliarEntity.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "EntityPhysics": {
      "description": "Physics state for an entity",
      "properties": {
        "arousal": {
          "format": "double",
          "type": "number"
        },
        "epistemic": {
          "format": "double",
          "type": "number"
        },
        "significance": {
          "format": "double",
          "type": "number"
        },
        "valence": {
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "arousal",
        "epistemic",
        "significance",
        "valence"
      ],
      "type": "object"
    },
    "EntityStatus": {
      "description": "HILT (Human in the Loop) status for entity approval",
      "enum": [
        "pending",
        "approved",
        "rejected",
        "auto_spawned"
      ],
      "type": "string"
    },
    "FamiliarEntityType": {
      "description": "Type of familiar entity",
      "enum": [
        "MOMENT",
        "PULSE",
        "INTENT",
        "THREAD",
        "BOND",
        "MOTIF",
        "FILAMENT",
        "FOCUS"
      ],
      "type": "string"
    }
  },
  "description": "A familiar entity spawned from conversation",
  "properties": {
    "content": {
      "type": "string"
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "entity_type": {
      "$ref": "#/definitions/FamiliarEntityType"
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "metadata": {
      "default": null
    },
    "physics": {
      "anyOf": [
        {
          "$ref": "#/definitions/EntityPhysics"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "qdrant_collection": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "qdrant_point_id": {
      "default": null,
      "description": "Reference to Qdrant vector",
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "reviewed_at": {
      "default": null,
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "reviewed_by": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "source_channel_id": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "source_message_id": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "status": {
      "$ref": "#/definitions/EntityStatus"
    },
    "subject": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "updated_at": {
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "content",
    "created_at",
    "entity_type",
    "id",
    "status",
    "tenant_id",
    "updated_at"
  ],
  "title": "FamiliarEntity",
  "type": "object",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/FamiliarEntityType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Type of familiar entity",
  "enum": [
    "MOMENT",
    "PULSE",
    "INTENT",
    "THREAD",
    "BOND",
    "MOTIF",
    "FILAMENT",
    "FOCUS"
  ],
  "title": "FamiliarEntityType",
  "type": "string",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/ListChannelsOptions.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ChannelType": {
      "description": "Type of channel",
      "oneOf": [
        {
          "description": "Personal channel for a single user",
          "enum": [
            "personal"
          ],
          "type": "string"
        },
        {
          "description": "Family channel shared by all tenant members",
          "enum": [
            "family"
          ],
          "type": "string"
        },
        {
          "description": "Shared channel for specific members",
          "enum": [
            "shared"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Options for listing channels",
  "properties": {
    "channel_type": {
      "anyOf": [
        {
          "$ref": "#/definitions/ChannelType"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "owner_id": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "title": "ListChannelsOptions",
  "type": "object",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/ListEntitiesOptions.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "EntityStatus": {
      "description": "HILT (Human in the Loop) status for entity approval",
      "enum": [
        "pending",
        "approved",
        "rejected",
        "auto_spawned"
      ],
      "type": "string"
    },
    "FamiliarEntityType": {
      "description": "Type of familiar entity",
      "enum": [
        "MOMENT",
        "PULSE",
        "INTENT",
        "THREAD",
        "BOND",
        "MOTIF",
        "FILAMENT",
        "FOCUS"
      ],
      "type": "string"
    }
  },
  "description": "Options for listing entities",
  "properties": {
    "entity_type": {
      "anyOf": [
        {
          "$ref": "#/definitions/FamiliarEntityType"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "limit": {
      "default": null,
      "format": "int64",
      "type": [
        "integer",
        "null"
      ]
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/definitions/EntityStatus"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "title": "ListEntitiesOptions",
  "type": "object",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/ListMessagesOptions.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Options for listing messages",
  "properties": {
    "after": {
      "default": null,
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "before": {
      "default": null,
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "limit": {
      "default": null,
      "format": "int64",
      "type": [
        "integer",
        "null"
      ]
    }
  },
  "title": "ListMessagesOptions",
  "type": "object",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/Message.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A message in a channel",
  "properties": {
    "agent_speaker": {
      "default": null,
      "description": "Which agent generated this (for assistant messages)",
      "type": [
        "string",
        "null"
      ]
    },
    "channel_id": {
      "$ref": "../../codegen/primitives/ChannelId.schema.json"
    },
    "content": {
      "type": "string"
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "id": {
      "$ref": "../../codegen/primitives/MessageId.schema.json"
    },
    "metadata": {
      "default": null
    },
    "parent_id": {
      "default": null,
      "description": "Parent message for threading",
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "role": {
      "$ref": "../../codegen/primitives/MessageRole.schema.json"
    },
    "sender_id": {
      "default": null,
      "description": "Sender (None for AI/system messages)",
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "thinking_steps": {
      "default": null,
      "description": "Chain of thought steps"
    },
    "tool_calls": {
      "default": null,
      "description": "Tool calls made"
    },
    "weave_result": {
      "default": null,
      "description": "Full weave_result from Fates pipeline"
    }
  },
  "required": [
    "channel_id",
    "content",
    "created_at",
    "id",
    "role"
  ],
  "title": "Message",
  "type": "object",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/conversation/UpdateEntityStatusInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "EntityStatus": {
      "description": "HILT (Human in the Loop) status for entity approval",
      "enum": [
        "pending",
        "approved",
        "rejected",
        "auto_spawned"
      ],
      "type": "string"
    }
  },
  "description": "Input for updating entity status (HILT)",
  "properties": {
    "reviewed_by": {
      "default": null,
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "status": {
      "$ref": "#/definitions/EntityStatus"
    }
  },
  "required": [
    "status"
  ],
  "title": "UpdateEntityStatusInput",
  "type": "object",
  "x-familiar-kind": "conversation",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/AuditLogEntryModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "action": {
      "type": "string"
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "error_message": {
      "type": [
        "string",
        "null"
      ]
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "ip_address": {
      "type": [
        "string",
        "null"
      ]
    },
    "metadata": true,
    "resource_id": {
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "resource_type": {
      "type": [
        "string",
        "null"
      ]
    },
    "success": {
      "type": "boolean"
    },
    "user_agent": {
      "type": [
        "string",
        "null"
      ]
    },
    "user_email": {
      "type": [
        "string",
        "null"
      ]
    },
    "user_id": {
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "action",
    "created_at",
    "id",
    "metadata",
    "success"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/AuthSessionModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "expires_at": {
      "format": "date-time",
      "type": "string"
    },
    "id": {
      "$ref": "../../codegen/primitives/SessionId.schema.json"
    },
    "ip_address": {
      "type": [
        "string",
        "null"
      ]
    },
    "token_hash": {
      "type": "string"
    },
    "user_agent": {
      "type": [
        "string",
        "null"
      ]
    },
    "user_id": {
      "$ref": "../../codegen/primitives/UserId.schema.json"
    }
  },
  "required": [
    "created_at",
    "expires_at",
    "id",
    "token_hash",
    "user_id"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/ChannelModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ChannelType": {
      "enum": [
        "Personal",
        "Family",
        "Shared"
      ],
      "type": "string"
    }
  },
  "properties": {
    "channel_type": {
      "$ref": "#/definitions/ChannelType"
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "description": {
      "type": [
        "string",
        "null"
      ]
    },
    "id": {
      "$ref": "../../codegen/primitives/ChannelId.schema.json"
    },
    "name": {
      "type": "string"
    },
    "owner_id": {
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "settings": true,
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "updated_at": {
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "channel_type",
    "created_at",
    "id",
    "name",
    "settings",
    "tenant_id",
    "updated_at"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/ConsentRecordModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ConsentType": {
      "enum": [
        "TermsOfService",
        "PrivacyPolicy",
        "MarketingEmails",
        "AiProcessing",
        "DataSharing",
        "Analytics"
      ],
      "type": "string"
    }
  },
  "properties": {
    "consent_type": {
      "$ref": "#/definitions/ConsentType"
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "granted": {
      "type": "boolean"
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "ip_address": {
      "type": [
        "string",
        "null"
      ]
    },
    "user_agent": {
      "type": [
        "string",
        "null"
      ]
    },
    "user_id": {
      "$ref": "../../codegen/primitives/UserId.schema.json"
    },
    "version": {
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "consent_type",
    "created_at",
    "granted",
    "id",
    "user_id"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/ContentPayloadModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "entity_id": {
      "$ref": "../../codegen/primitives/EntityId.schema.json"
    },
    "metadata": true,
    "text_content": {
      "type": "string"
    }
  },
  "required": [
    "entity_id",
    "metadata",
    "text_content"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/EntityRegistryModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "entity_type": {
      "type": "string"
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    }
  },
  "required": [
    "created_at",
    "entity_type",
    "id",
    "tenant_id"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/FamiliarEntityModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "EntityStatus": {
      "enum": [
        "Pending",
        "Approved",
        "Rejected",
        "AutoSpawned"
      ],
      "type": "string"
    },
    "FamiliarEntityType": {
      "enum": [
        "Moment",
        "Pulse",
        "Intent",
        "Thread",
        "Bond",
        "Motif",
        "Filament",
        "Focus"
      ],
      "type": "string"
    }
  },
  "properties": {
    "content": {
      "type": "string"
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "entity_type": {
      "$ref": "#/definitions/FamiliarEntityType"
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "metadata": true,
    "physics": true,
    "qdrant_collection": {
      "type": [
        "string",
        "null"
      ]
    },
    "qdrant_point_id": {
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "reviewed_at": {
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "reviewed_by": {
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "source_channel_id": {
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "source_message_id": {
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "status": {
      "$ref": "#/definitions/EntityStatus"
    },
    "subject": {
      "type": [
        "string",
        "null"
      ]
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "updated_at": {
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "content",
    "created_at",
    "entity_type",
    "id",
    "metadata",
    "status",
    "tenant_id",
    "updated_at"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/FamilyInvitationModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "InviteType": {
      "enum": [
        "Email",
        "Code"
      ],
      "type": "string"
    }
  },
  "properties": {
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "email": {
      "type": [
        "string",
        "null"
      ]
    },
    "expires_at": {
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "invite_code": {
      "type": [
        "string",
        "null"
      ]
    },
    "invite_type": {
      "$ref": "#/definitions/InviteType"
    },
    "invited_by": {
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "max_uses": {
      "format": "int32",
      "type": [
        "integer",
        "null"
      ]
    },
    "role": {
      "$ref": "../../codegen/primitives/InviteRole.schema.json"
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "use_count": {
      "format": "int32",
      "type": "integer"
    }
  },
  "required": [
    "created_at",
    "id",
    "invite_type",
    "role",
    "tenant_id",
    "use_count"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/FieldExcitationModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "amplitude": {
      "format": "double",
      "type": "number"
    },
    "energy": {
      "format": "double",
      "type": "number"
    },
    "entity_id": {
      "$ref": "../../codegen/primitives/EntityId.schema.json"
    },
    "pos_arousal": {
      "format": "int64",
      "type": "integer"
    },
    "pos_epistemic": {
      "format": "int64",
      "type": "integer"
    },
    "pos_valence": {
      "format": "int64",
      "type": "integer"
    },
    "temperature": {
      "format": "double",
      "type": "number"
    },
    "time": {
      "format": "date-time",
      "type": "string"
    },
    "vel_arousal": {
      "format": "int64",
      "type": "integer"
    },
    "vel_epistemic": {
      "format": "int64",
      "type": "integer"
    },
    "vel_valence": {
      "format": "int64",
      "type": "integer"
    }
  },
  "required": [
    "amplitude",
    "energy",
    "entity_id",
    "pos_arousal",
    "pos_epistemic",
    "pos_valence",
    "temperature",
    "time",
    "vel_arousal",
    "vel_epistemic",
    "vel_valence"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/JoinRequestModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "JoinRequestStatus": {
      "enum": [
        "Pending",
        "Approved",
        "Rejected"
      ],
      "type": "string"
    }
  },
  "properties": {
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "message": {
      "type": [
        "string",
        "null"
      ]
    },
    "review_note": {
      "type": [
        "string",
        "null"
      ]
    },
    "reviewed_at": {
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "reviewed_by": {
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "status": {
      "$ref": "#/definitions/JoinRequestStatus"
    },
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "user_id": {
      "$ref": "../../codegen/primitives/UserId.schema.json"
    }
  },
  "required": [
    "created_at",
    "id",
    "status",
    "tenant_id",
    "user_id"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/MagicLinkModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "MagicLinkPurpose": {
      "enum": [
        "Login",
        "Signup",
        "VerifyEmail",
        "PasswordReset"
      ],
      "type": "string"
    }
  },
  "properties": {
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "email": {
      "type": "string"
    },
    "expires_at": {
      "format": "date-time",
      "type": "string"
    },
    "id": {
      "format": "uuid",
      "type": "string"
    },
    "metadata": true,
    "purpose": {
      "$ref": "#/definitions/MagicLinkPurpose"
    },
    "token_hash": {
      "type": "string"
    },
    "used_at": {
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "created_at",
    "email",
    "expires_at",
    "id",
    "metadata",
    "purpose",
    "token_hash"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/MessageModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "agent_speaker": {
      "type": [
        "string",
        "null"
      ]
    },
    "channel_id": {
      "$ref": "../../codegen/primitives/ChannelId.schema.json"
    },
    "content": {
      "type": "string"
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "id": {
      "$ref": "../../codegen/primitives/MessageId.schema.json"
    },
    "metadata": true,
    "parent_id": {
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "role": {
      "$ref": "../../codegen/primitives/MessageRole.schema.json"
    },
    "sender_id": {
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "thinking_steps": true,
    "tool_calls": true,
    "weave_result": true
  },
  "required": [
    "channel_id",
    "content",
    "created_at",
    "id",
    "metadata",
    "role",
    "thinking_steps",
    "tool_calls"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/QuantumStateModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Quantum state with vector embedding (pgvector) Note: The `amplitudes` field uses pgvector VECTOR(3072) type SeaORM doesn't have native pgvector support, so raw SQL is used in store.rs",
  "properties": {
    "coherence": {
      "format": "double",
      "type": "number"
    },
    "entity_id": {
      "$ref": "../../codegen/primitives/EntityId.schema.json"
    },
    "frequency": {
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    }
  },
  "required": [
    "coherence",
    "entity_id"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/TenantMemberModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "MemberRole": {
      "enum": [
        "Admin",
        "Member",
        "Guest"
      ],
      "type": "string"
    }
  },
  "properties": {
    "avatar_url": {
      "type": [
        "string",
        "null"
      ]
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "email": {
      "type": [
        "string",
        "null"
      ]
    },
    "id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "name": {
      "type": "string"
    },
    "role": {
      "$ref": "#/definitions/MemberRole"
    },
    "settings": true,
    "tenant_id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "updated_at": {
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "created_at",
    "id",
    "name",
    "role",
    "settings",
    "tenant_id",
    "updated_at"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/TenantModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "name": {
      "type": "string"
    },
    "settings": true,
    "updated_at": {
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "created_at",
    "id",
    "name",
    "settings",
    "updated_at"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/database/UserModel.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "avatar_url": {
      "type": [
        "string",
        "null"
      ]
    },
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "deletion_requested_at": {
      "format": "date-time",
      "type": [
        "string",
        "null"
      ]
    },
    "email": {
      "type": "string"
    },
    "email_verified": {
      "type": "boolean"
    },
    "gdpr_consents": true,
    "id": {
      "$ref": "../../codegen/primitives/UserId.schema.json"
    },
    "name": {
      "type": "string"
    },
    "password_hash": {
      "type": [
        "string",
        "null"
      ]
    },
    "primary_tenant_id": {
      "format": "uuid",
      "type": [
        "string",
        "null"
      ]
    },
    "settings": true,
    "updated_at": {
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "created_at",
    "email",
    "email_verified",
    "gdpr_consents",
    "id",
    "name",
    "settings",
    "updated_at"
  ],
  "title": "Model",
  "type": "object",
  "x-familiar-kind": "database",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/AudioBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "duration_secs": {
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "source": {
      "type": "string"
    },
    "transcript": {
      "description": "Pre-transcribed (skip Whisper)",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "source"
  ],
  "title": "AudioBlock",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/ClassificationResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Classification with weight",
  "properties": {
    "entity_type": {
      "type": "string"
    },
    "weight": {
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "entity_type",
    "weight"
  ],
  "title": "ClassificationResponse",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/CourseResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ClassificationResponse": {
      "description": "Classification with weight",
      "properties": {
        "entity_type": {
          "type": "string"
        },
        "weight": {
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "entity_type",
        "weight"
      ],
      "type": "object"
    },
    "EntityResponse": {
      "description": "A spawned entity in the response",
      "properties": {
        "content_preview": {
          "type": "string"
        },
        "entity_type": {
          "type": "string"
        },
        "id": {
          "type": "string"
        },
        "physics": {
          "anyOf": [
            {
              "$ref": "#/definitions/PhysicsResponse"
            },
            {
              "type": "null"
            }
          ]
        },
        "unit_index": {
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        }
      },
      "required": [
        "content_preview",
        "entity_type",
        "id",
        "unit_index"
      ],
      "type": "object"
    },
    "LlmRequestDebug": {
      "description": "Debug info about the LLM request",
      "properties": {
        "system_prompt": {
          "type": "string"
        },
        "user_prompt": {
          "type": "string"
        }
      },
      "required": [
        "system_prompt",
        "user_prompt"
      ],
      "type": "object"
    },
    "MediaRef": {
      "properties": {
        "bucket_key": {
          "type": [
            "string",
            "null"
          ]
        },
        "id": {
          "type": "string"
        },
        "media_type": {
          "$ref": "#/definitions/MediaType"
        },
        "metadata": true,
        "normalized_text": {
          "type": "string"
        }
      },
      "required": [
        "id",
        "media_type",
        "metadata",
        "normalized_text"
      ],
      "type": "object"
    },
    "MediaType": {
      "enum": [
        "Image",
        "Audio",
        "Document",
        "Webpage"
      ],
      "type": "string"
    },
    "MessageIntentResponse": {
      "description": "Classified message intent (what the user is trying to do)",
      "properties": {
        "confidence": {
          "description": "Confidence score 0.0-1.0",
          "format": "double",
          "type": "number"
        },
        "intent": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/MessageIntent.schema.json"
            }
          ],
          "description": "Primary intent: LOG, QUERY, INFER, REFERENCE, REFLECT, COMMAND, SOCIAL"
        },
        "query_target": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/QueryTarget.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "description": "If QUERY: what is being queried"
        },
        "query_type": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/QueryType.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "description": "If QUERY: what type of query"
        }
      },
      "required": [
        "confidence",
        "intent"
      ],
      "type": "object"
    },
    "PhysicsHintResponse": {
      "description": "Physics hints from LLM",
      "properties": {
        "arousal": {
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "clarity": {
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "intrusiveness": {
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "significance": {
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "valence": {
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "volatility": {
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "PhysicsResponse": {
      "description": "Physics state on spawned entity",
      "properties": {
        "amplitude": {
          "format": "double",
          "type": "number"
        },
        "energy": {
          "format": "double",
          "type": "number"
        },
        "position": {
          "description": "Position in VAE space [Valence, Arousal, Epistemic]",
          "items": {
            "format": "double",
            "type": "number"
          },
          "maxItems": 3,
          "minItems": 3,
          "type": "array"
        },
        "temperature": {
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "amplitude",
        "energy",
        "position",
        "temperature"
      ],
      "type": "object"
    },
    "SegmentResponse": {
      "description": "A raw segment from Phase 1 (no classification)",
      "properties": {
        "content": {
          "type": "string"
        },
        "mentions": {
          "default": [],
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "subject": {
          "type": [
            "string",
            "null"
          ]
        },
        "temporal": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "content"
      ],
      "type": "object"
    },
    "WeaveUnitResponse": {
      "description": "A weave unit in the response",
      "properties": {
        "classifications": {
          "items": {
            "$ref": "#/definitions/ClassificationResponse"
          },
          "type": "array"
        },
        "content": {
          "type": "string"
        },
        "index": {
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "physics_hint": {
          "anyOf": [
            {
              "$ref": "#/definitions/PhysicsHintResponse"
            },
            {
              "type": "null"
            }
          ]
        },
        "primary_thread": {
          "description": "Primary thread (main subject/actor)",
          "type": [
            "string",
            "null"
          ]
        },
        "purpose": {
          "description": "Purpose of this specific weave unit (LOG, QUERY, COMMAND, INFER, REFERENCE)",
          "type": [
            "string",
            "null"
          ]
        },
        "secondary_threads": {
          "default": [],
          "description": "Secondary threads (other people/places/things)",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "spawned_ids": {
          "default": [],
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "temporal_marker": {
          "default": null,
          "description": "Temporal marker (when: absolute, relative, frequency, duration) Always included in output for debugging (even if null)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "classifications",
        "content",
        "index"
      ],
      "type": "object"
    }
  },
  "description": "Response payload for POST /weave",
  "properties": {
    "course_id": {
      "description": "Course ID (the workflow container)",
      "type": "string"
    },
    "debug_llm_request": {
      "anyOf": [
        {
          "$ref": "#/definitions/LlmRequestDebug"
        },
        {
          "type": "null"
        }
      ],
      "description": "Raw prompt sent to LLM (system + user message)"
    },
    "debug_llm_response": {
      "description": "Raw JSON response from LLM (before processing)",
      "type": [
        "string",
        "null"
      ]
    },
    "entities": {
      "description": "Entities spawned from weave units (by Spawner, not LLM)",
      "items": {
        "$ref": "#/definitions/EntityResponse"
      },
      "type": [
        "array",
        "null"
      ]
    },
    "error": {
      "description": "Error message if failed",
      "type": [
        "string",
        "null"
      ]
    },
    "media_refs": {
      "description": "Media references from multimodal input",
      "items": {
        "$ref": "#/definitions/MediaRef"
      },
      "type": [
        "array",
        "null"
      ]
    },
    "message_intent": {
      "allOf": [
        {
          "$ref": "#/definitions/MessageIntentResponse"
        }
      ],
      "description": "What is the user trying to do with this message?"
    },
    "metadata": {
      "description": "Processing metadata"
    },
    "original_weave": {
      "description": "The original user input (preserved for context)",
      "type": "string"
    },
    "provider": {
      "description": "Provider used",
      "type": "string"
    },
    "segments": {
      "default": [],
      "description": "Raw segments before classification (Phase 1 output)",
      "items": {
        "$ref": "#/definitions/SegmentResponse"
      },
      "type": "array"
    },
    "shuttle_id": {
      "description": "Shuttle ID (carries the weave units)",
      "type": "string"
    },
    "success": {
      "type": "boolean"
    },
    "unit_count": {
      "description": "Number of weave units extracted (0 for queries)",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "weave_units": {
      "description": "The classified weave units (for LOG intent)",
      "items": {
        "$ref": "#/definitions/WeaveUnitResponse"
      },
      "type": "array"
    }
  },
  "required": [
    "course_id",
    "message_intent",
    "original_weave",
    "provider",
    "shuttle_id",
    "success",
    "unit_count",
    "weave_units"
  ],
  "title": "CourseResponse",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/DocumentBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "filename": {
      "type": [
        "string",
        "null"
      ]
    },
    "mime_type": {
      "type": [
        "string",
        "null"
      ]
    },
    "source": {
      "type": "string"
    }
  },
  "required": [
    "source"
  ],
  "title": "DocumentBlock",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/EntityResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "PhysicsResponse": {
      "description": "Physics state on spawned entity",
      "properties": {
        "amplitude": {
          "format": "double",
          "type": "number"
        },
        "energy": {
          "format": "double",
          "type": "number"
        },
        "position": {
          "description": "Position in VAE space [Valence, Arousal, Epistemic]",
          "items": {
            "format": "double",
            "type": "number"
          },
          "maxItems": 3,
          "minItems": 3,
          "type": "array"
        },
        "temperature": {
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "amplitude",
        "energy",
        "position",
        "temperature"
      ],
      "type": "object"
    }
  },
  "description": "A spawned entity in the response",
  "properties": {
    "content_preview": {
      "type": "string"
    },
    "entity_type": {
      "type": "string"
    },
    "id": {
      "type": "string"
    },
    "physics": {
      "anyOf": [
        {
          "$ref": "#/definitions/PhysicsResponse"
        },
        {
          "type": "null"
        }
      ]
    },
    "unit_index": {
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    }
  },
  "required": [
    "content_preview",
    "entity_type",
    "id",
    "unit_index"
  ],
  "title": "EntityResponse",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/HealthResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Response payload for GET /health",
  "properties": {
    "service": {
      "type": "string"
    },
    "status": {
      "type": "string"
    },
    "version": {
      "type": "string"
    }
  },
  "required": [
    "service",
    "status",
    "version"
  ],
  "title": "HealthResponse",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/ImageBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "alt_text": {
      "type": [
        "string",
        "null"
      ]
    },
    "analyze": {
      "default": true,
      "description": "Request vision analysis",
      "type": "boolean"
    },
    "source": {
      "description": "base64 data URI or URL",
      "type": "string"
    }
  },
  "required": [
    "source"
  ],
  "title": "ImageBlock",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/MediaRef.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "MediaType": {
      "enum": [
        "Image",
        "Audio",
        "Document",
        "Webpage"
      ],
      "type": "string"
    }
  },
  "properties": {
    "bucket_key": {
      "type": [
        "string",
        "null"
      ]
    },
    "id": {
      "type": "string"
    },
    "media_type": {
      "$ref": "#/definitions/MediaType"
    },
    "metadata": true,
    "normalized_text": {
      "type": "string"
    }
  },
  "required": [
    "id",
    "media_type",
    "metadata",
    "normalized_text"
  ],
  "title": "MediaRef",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/MediaType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "Image",
    "Audio",
    "Document",
    "Webpage"
  ],
  "title": "MediaType",
  "type": "string",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/MessageIntentResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Classified message intent (what the user is trying to do)",
  "properties": {
    "confidence": {
      "description": "Confidence score 0.0-1.0",
      "format": "double",
      "type": "number"
    },
    "intent": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/MessageIntent.schema.json"
        }
      ],
      "description": "Primary intent: LOG, QUERY, INFER, REFERENCE, REFLECT, COMMAND, SOCIAL"
    },
    "query_target": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/QueryTarget.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "description": "If QUERY: what is being queried"
    },
    "query_type": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/QueryType.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "description": "If QUERY: what type of query"
    }
  },
  "required": [
    "confidence",
    "intent"
  ],
  "title": "MessageIntentResponse",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/ModelInfo.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Model information component",
  "properties": {
    "api_model_id": {
      "type": "string"
    },
    "id": {
      "type": "string"
    },
    "name": {
      "type": "string"
    },
    "provider": {
      "type": "string"
    }
  },
  "required": [
    "api_model_id",
    "id",
    "name",
    "provider"
  ],
  "title": "ModelInfo",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/PhysicsHintResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Physics hints from LLM",
  "properties": {
    "arousal": {
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "clarity": {
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "intrusiveness": {
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "significance": {
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "valence": {
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "volatility": {
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    }
  },
  "title": "PhysicsHintResponse",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/PhysicsResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Physics state on spawned entity",
  "properties": {
    "amplitude": {
      "format": "double",
      "type": "number"
    },
    "energy": {
      "format": "double",
      "type": "number"
    },
    "position": {
      "description": "Position in VAE space [Valence, Arousal, Epistemic]",
      "items": {
        "format": "double",
        "type": "number"
      },
      "maxItems": 3,
      "minItems": 3,
      "type": "array"
    },
    "temperature": {
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "amplitude",
    "energy",
    "position",
    "temperature"
  ],
  "title": "PhysicsResponse",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/SegmentResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A raw segment from Phase 1 (no classification)",
  "properties": {
    "content": {
      "type": "string"
    },
    "mentions": {
      "default": [],
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "subject": {
      "type": [
        "string",
        "null"
      ]
    },
    "temporal": {
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "content"
  ],
  "title": "SegmentResponse",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/TextBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "content": {
      "type": "string"
    }
  },
  "required": [
    "content"
  ],
  "title": "TextBlock",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/WeaveBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Input block types for multimodal weave requests",
  "oneOf": [
    {
      "properties": {
        "content": {
          "type": "string"
        },
        "type": {
          "enum": [
            "text"
          ],
          "type": "string"
        }
      },
      "required": [
        "content",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "alt_text": {
          "type": [
            "string",
            "null"
          ]
        },
        "analyze": {
          "default": true,
          "description": "Request vision analysis",
          "type": "boolean"
        },
        "source": {
          "description": "base64 data URI or URL",
          "type": "string"
        },
        "type": {
          "enum": [
            "image"
          ],
          "type": "string"
        }
      },
      "required": [
        "source",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "duration_secs": {
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "source": {
          "type": "string"
        },
        "transcript": {
          "description": "Pre-transcribed (skip Whisper)",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "enum": [
            "audio"
          ],
          "type": "string"
        }
      },
      "required": [
        "source",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "filename": {
          "type": [
            "string",
            "null"
          ]
        },
        "mime_type": {
          "type": [
            "string",
            "null"
          ]
        },
        "source": {
          "type": "string"
        },
        "type": {
          "enum": [
            "document"
          ],
          "type": "string"
        }
      },
      "required": [
        "source",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "extract_images": {
          "default": false,
          "description": "Whether to extract images from the page",
          "type": "boolean"
        },
        "selector": {
          "description": "Optional CSS selector to extract specific content",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "enum": [
            "webpage"
          ],
          "type": "string"
        },
        "url": {
          "description": "URL to scrape",
          "type": "string"
        }
      },
      "required": [
        "type",
        "url"
      ],
      "type": "object"
    }
  ],
  "title": "WeaveBlock",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/WeaveRequest.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "WeaveBlock": {
      "description": "Input block types for multimodal weave requests",
      "oneOf": [
        {
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "enum": [
                "text"
              ],
              "type": "string"
            }
          },
          "required": [
            "content",
            "type"
          ],
          "type": "object"
        },
        {
          "properties": {
            "alt_text": {
              "type": [
                "string",
                "null"
              ]
            },
            "analyze": {
              "default": true,
              "description": "Request vision analysis",
              "type": "boolean"
            },
            "source": {
              "description": "base64 data URI or URL",
              "type": "string"
            },
            "type": {
              "enum": [
                "image"
              ],
              "type": "string"
            }
          },
          "required": [
            "source",
            "type"
          ],
          "type": "object"
        },
        {
          "properties": {
            "duration_secs": {
              "format": "double",
              "type": [
                "number",
                "null"
              ]
            },
            "source": {
              "type": "string"
            },
            "transcript": {
              "description": "Pre-transcribed (skip Whisper)",
              "type": [
                "string",
                "null"
              ]
            },
            "type": {
              "enum": [
                "audio"
              ],
              "type": "string"
            }
          },
          "required": [
            "source",
            "type"
          ],
          "type": "object"
        },
        {
          "properties": {
            "filename": {
              "type": [
                "string",
                "null"
              ]
            },
            "mime_type": {
              "type": [
                "string",
                "null"
              ]
            },
            "source": {
              "type": "string"
            },
            "type": {
              "enum": [
                "document"
              ],
              "type": "string"
            }
          },
          "required": [
            "source",
            "type"
          ],
          "type": "object"
        },
        {
          "properties": {
            "extract_images": {
              "default": false,
              "description": "Whether to extract images from the page",
              "type": "boolean"
            },
            "selector": {
              "description": "Optional CSS selector to extract specific content",
              "type": [
                "string",
                "null"
              ]
            },
            "type": {
              "enum": [
                "webpage"
              ],
              "type": "string"
            },
            "url": {
              "description": "URL to scrape",
              "type": "string"
            }
          },
          "required": [
            "type",
            "url"
          ],
          "type": "object"
        }
      ]
    }
  },
  "description": "Request payload for POST /weave",
  "properties": {
    "agent_id": {
      "description": "Agent/Flow ID (\"heddle\" or \"concierge\")",
      "type": [
        "string",
        "null"
      ]
    },
    "api_key": {
      "description": "API key (passed from client)",
      "type": [
        "string",
        "null"
      ]
    },
    "blocks": {
      "description": "Multimodal blocks (replaces/augments simple text weave)",
      "items": {
        "$ref": "#/definitions/WeaveBlock"
      },
      "type": [
        "array",
        "null"
      ]
    },
    "context": {
      "description": "Optional global context (the \"Golden Thread\")",
      "type": [
        "string",
        "null"
      ]
    },
    "context_blocks": {
      "description": "Context can also be multimodal",
      "items": {
        "$ref": "#/definitions/WeaveBlock"
      },
      "type": [
        "array",
        "null"
      ]
    },
    "model": {
      "description": "Model ID to use",
      "type": [
        "string",
        "null"
      ]
    },
    "provider": {
      "description": "AI provider to use",
      "type": [
        "string",
        "null"
      ]
    },
    "threshold": {
      "description": "Collapse threshold for entity spawning (default: 0.7)",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "weave": {
      "description": "The raw user input (the \"weave\" of thought)",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "title": "WeaveRequest",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/WeaveUnitResponse.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ClassificationResponse": {
      "description": "Classification with weight",
      "properties": {
        "entity_type": {
          "type": "string"
        },
        "weight": {
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "entity_type",
        "weight"
      ],
      "type": "object"
    },
    "PhysicsHintResponse": {
      "description": "Physics hints from LLM",
      "properties": {
        "arousal": {
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "clarity": {
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "intrusiveness": {
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "significance": {
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "valence": {
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "volatility": {
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object"
    }
  },
  "description": "A weave unit in the response",
  "properties": {
    "classifications": {
      "items": {
        "$ref": "#/definitions/ClassificationResponse"
      },
      "type": "array"
    },
    "content": {
      "type": "string"
    },
    "index": {
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "physics_hint": {
      "anyOf": [
        {
          "$ref": "#/definitions/PhysicsHintResponse"
        },
        {
          "type": "null"
        }
      ]
    },
    "primary_thread": {
      "description": "Primary thread (main subject/actor)",
      "type": [
        "string",
        "null"
      ]
    },
    "purpose": {
      "description": "Purpose of this specific weave unit (LOG, QUERY, COMMAND, INFER, REFERENCE)",
      "type": [
        "string",
        "null"
      ]
    },
    "secondary_threads": {
      "default": [],
      "description": "Secondary threads (other people/places/things)",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "spawned_ids": {
      "default": [],
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "temporal_marker": {
      "default": null,
      "description": "Temporal marker (when: absolute, relative, frequency, duration) Always included in output for debugging (even if null)",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "classifications",
    "content",
    "index"
  ],
  "title": "WeaveUnitResponse",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/entities_api/WebpageBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "extract_images": {
      "default": false,
      "description": "Whether to extract images from the page",
      "type": "boolean"
    },
    "selector": {
      "description": "Optional CSS selector to extract specific content",
      "type": [
        "string",
        "null"
      ]
    },
    "url": {
      "description": "URL to scrape",
      "type": "string"
    }
  },
  "required": [
    "url"
  ],
  "title": "WebpageBlock",
  "type": "object",
  "x-familiar-kind": "entities_api",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/tenant/CreateTenantInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Input for creating a new tenant",
  "properties": {
    "name": {
      "type": "string"
    },
    "settings": {
      "default": null
    }
  },
  "required": [
    "name"
  ],
  "title": "CreateTenantInput",
  "type": "object",
  "x-familiar-kind": "tenant",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/tenant/Tenant.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A tenant (family) in the system\n\nUses `SystemEntityMeta` because tenants are top-level entities that don't belong to another tenant.",
  "properties": {
    "created_at": {
      "format": "date-time",
      "type": "string"
    },
    "id": {
      "$ref": "../../codegen/primitives/TenantId.schema.json"
    },
    "name": {
      "type": "string"
    },
    "settings": {
      "default": null
    },
    "updated_at": {
      "format": "date-time",
      "type": "string"
    }
  },
  "required": [
    "created_at",
    "id",
    "name",
    "updated_at"
  ],
  "title": "Tenant",
  "type": "object",
  "x-familiar-kind": "tenant",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-daemon.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/AccordionBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AccordionState": {
      "enum": [
        "collapsed",
        "expanded"
      ],
      "type": "string"
    },
    "Block": {
      "description": "A single visual block in a message",
      "oneOf": [
        {
          "description": "Displays text, possibly alongside an accessory (image, button, etc.)",
          "properties": {
            "accessory": {
              "anyOf": [
                {
                  "$ref": "../../codegen/primitives/BlockElement.schema.json"
                },
                {
                  "type": "null"
                }
              ]
            },
            "fields": {
              "items": {
                "$ref": "../../codegen/primitives/TextObject.schema.json"
              },
              "type": [
                "array",
                "null"
              ]
            },
            "text": {
              "$ref": "../../codegen/primitives/TextObject.schema.json"
            },
            "type": {
              "enum": [
                "section"
              ],
              "type": "string"
            }
          },
          "required": [
            "text",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A visual separator",
          "properties": {
            "type": {
              "enum": [
                "divider"
              ],
              "type": "string"
            }
          },
          "required": [
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Displays an image with optional title",
          "properties": {
            "alt_text": {
              "type": "string"
            },
            "image_url": {
              "type": "string"
            },
            "title": {
              "anyOf": [
                {
                  "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
                },
                {
                  "type": "null"
                }
              ]
            },
            "type": {
              "enum": [
                "image"
              ],
              "type": "string"
            }
          },
          "required": [
            "alt_text",
            "image_url",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A container for interactive elements (buttons, selects, etc.)",
          "properties": {
            "elements": {
              "items": {
                "$ref": "../../codegen/primitives/BlockElement.schema.json"
              },
              "type": "array"
            },
            "type": {
              "enum": [
                "actions"
              ],
              "type": "string"
            }
          },
          "required": [
            "elements",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Displays contextual info (small grey text, images)",
          "properties": {
            "elements": {
              "items": {
                "$ref": "../../codegen/primitives/ContextElement.schema.json"
              },
              "type": "array"
            },
            "type": {
              "enum": [
                "context"
              ],
              "type": "string"
            }
          },
          "required": [
            "elements",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A header with large, bold text",
          "properties": {
            "text": {
              "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
            },
            "type": {
              "enum": [
                "header"
              ],
              "type": "string"
            }
          },
          "required": [
            "text",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "An input field",
          "properties": {
            "element": {
              "$ref": "../../codegen/primitives/BlockElement.schema.json"
            },
            "hint": {
              "anyOf": [
                {
                  "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
                },
                {
                  "type": "null"
                }
              ]
            },
            "label": {
              "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
            },
            "optional": {
              "default": false,
              "type": "boolean"
            },
            "type": {
              "enum": [
                "input"
              ],
              "type": "string"
            }
          },
          "required": [
            "element",
            "label",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A collapsible container",
          "properties": {
            "blocks": {
              "items": {
                "$ref": "#/definitions/Block"
              },
              "type": "array"
            },
            "initial_state": {
              "allOf": [
                {
                  "$ref": "#/definitions/AccordionState"
                }
              ],
              "default": "collapsed"
            },
            "summary": {
              "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
            },
            "type": {
              "enum": [
                "accordion"
              ],
              "type": "string"
            }
          },
          "required": [
            "blocks",
            "summary",
            "type"
          ],
          "type": "object"
        }
      ]
    }
  },
  "description": "A collapsible container",
  "properties": {
    "blocks": {
      "items": {
        "$ref": "#/definitions/Block"
      },
      "type": "array"
    },
    "initial_state": {
      "allOf": [
        {
          "$ref": "#/definitions/AccordionState"
        }
      ],
      "default": "collapsed"
    },
    "summary": {
      "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
    }
  },
  "required": [
    "blocks",
    "summary"
  ],
  "title": "AccordionBlock",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/AccordionState.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "collapsed",
    "expanded"
  ],
  "title": "AccordionState",
  "type": "string",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/ActionsBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A container for interactive elements (buttons, selects, etc.)",
  "properties": {
    "elements": {
      "items": {
        "$ref": "../../codegen/primitives/BlockElement.schema.json"
      },
      "type": "array"
    }
  },
  "required": [
    "elements"
  ],
  "title": "ActionsBlock",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/Block.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AccordionState": {
      "enum": [
        "collapsed",
        "expanded"
      ],
      "type": "string"
    },
    "Block": {
      "description": "A single visual block in a message",
      "oneOf": [
        {
          "description": "Displays text, possibly alongside an accessory (image, button, etc.)",
          "properties": {
            "accessory": {
              "anyOf": [
                {
                  "$ref": "../../codegen/primitives/BlockElement.schema.json"
                },
                {
                  "type": "null"
                }
              ]
            },
            "fields": {
              "items": {
                "$ref": "../../codegen/primitives/TextObject.schema.json"
              },
              "type": [
                "array",
                "null"
              ]
            },
            "text": {
              "$ref": "../../codegen/primitives/TextObject.schema.json"
            },
            "type": {
              "enum": [
                "section"
              ],
              "type": "string"
            }
          },
          "required": [
            "text",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A visual separator",
          "properties": {
            "type": {
              "enum": [
                "divider"
              ],
              "type": "string"
            }
          },
          "required": [
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Displays an image with optional title",
          "properties": {
            "alt_text": {
              "type": "string"
            },
            "image_url": {
              "type": "string"
            },
            "title": {
              "anyOf": [
                {
                  "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
                },
                {
                  "type": "null"
                }
              ]
            },
            "type": {
              "enum": [
                "image"
              ],
              "type": "string"
            }
          },
          "required": [
            "alt_text",
            "image_url",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A container for interactive elements (buttons, selects, etc.)",
          "properties": {
            "elements": {
              "items": {
                "$ref": "../../codegen/primitives/BlockElement.schema.json"
              },
              "type": "array"
            },
            "type": {
              "enum": [
                "actions"
              ],
              "type": "string"
            }
          },
          "required": [
            "elements",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Displays contextual info (small grey text, images)",
          "properties": {
            "elements": {
              "items": {
                "$ref": "../../codegen/primitives/ContextElement.schema.json"
              },
              "type": "array"
            },
            "type": {
              "enum": [
                "context"
              ],
              "type": "string"
            }
          },
          "required": [
            "elements",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A header with large, bold text",
          "properties": {
            "text": {
              "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
            },
            "type": {
              "enum": [
                "header"
              ],
              "type": "string"
            }
          },
          "required": [
            "text",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "An input field",
          "properties": {
            "element": {
              "$ref": "../../codegen/primitives/BlockElement.schema.json"
            },
            "hint": {
              "anyOf": [
                {
                  "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
                },
                {
                  "type": "null"
                }
              ]
            },
            "label": {
              "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
            },
            "optional": {
              "default": false,
              "type": "boolean"
            },
            "type": {
              "enum": [
                "input"
              ],
              "type": "string"
            }
          },
          "required": [
            "element",
            "label",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A collapsible container",
          "properties": {
            "blocks": {
              "items": {
                "$ref": "#/definitions/Block"
              },
              "type": "array"
            },
            "initial_state": {
              "allOf": [
                {
                  "$ref": "#/definitions/AccordionState"
                }
              ],
              "default": "collapsed"
            },
            "summary": {
              "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
            },
            "type": {
              "enum": [
                "accordion"
              ],
              "type": "string"
            }
          },
          "required": [
            "blocks",
            "summary",
            "type"
          ],
          "type": "object"
        }
      ]
    }
  },
  "description": "A single visual block in a message",
  "oneOf": [
    {
      "description": "Displays text, possibly alongside an accessory (image, button, etc.)",
      "properties": {
        "accessory": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/BlockElement.schema.json"
            },
            {
              "type": "null"
            }
          ]
        },
        "fields": {
          "items": {
            "$ref": "../../codegen/primitives/TextObject.schema.json"
          },
          "type": [
            "array",
            "null"
          ]
        },
        "text": {
          "$ref": "../../codegen/primitives/TextObject.schema.json"
        },
        "type": {
          "enum": [
            "section"
          ],
          "type": "string"
        }
      },
      "required": [
        "text",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "A visual separator",
      "properties": {
        "type": {
          "enum": [
            "divider"
          ],
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Displays an image with optional title",
      "properties": {
        "alt_text": {
          "type": "string"
        },
        "image_url": {
          "type": "string"
        },
        "title": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
            },
            {
              "type": "null"
            }
          ]
        },
        "type": {
          "enum": [
            "image"
          ],
          "type": "string"
        }
      },
      "required": [
        "alt_text",
        "image_url",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "A container for interactive elements (buttons, selects, etc.)",
      "properties": {
        "elements": {
          "items": {
            "$ref": "../../codegen/primitives/BlockElement.schema.json"
          },
          "type": "array"
        },
        "type": {
          "enum": [
            "actions"
          ],
          "type": "string"
        }
      },
      "required": [
        "elements",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Displays contextual info (small grey text, images)",
      "properties": {
        "elements": {
          "items": {
            "$ref": "../../codegen/primitives/ContextElement.schema.json"
          },
          "type": "array"
        },
        "type": {
          "enum": [
            "context"
          ],
          "type": "string"
        }
      },
      "required": [
        "elements",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "A header with large, bold text",
      "properties": {
        "text": {
          "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
        },
        "type": {
          "enum": [
            "header"
          ],
          "type": "string"
        }
      },
      "required": [
        "text",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "An input field",
      "properties": {
        "element": {
          "$ref": "../../codegen/primitives/BlockElement.schema.json"
        },
        "hint": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
            },
            {
              "type": "null"
            }
          ]
        },
        "label": {
          "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
        },
        "optional": {
          "default": false,
          "type": "boolean"
        },
        "type": {
          "enum": [
            "input"
          ],
          "type": "string"
        }
      },
      "required": [
        "element",
        "label",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "A collapsible container",
      "properties": {
        "blocks": {
          "items": {
            "$ref": "#/definitions/Block"
          },
          "type": "array"
        },
        "initial_state": {
          "allOf": [
            {
              "$ref": "#/definitions/AccordionState"
            }
          ],
          "default": "collapsed"
        },
        "summary": {
          "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
        },
        "type": {
          "enum": [
            "accordion"
          ],
          "type": "string"
        }
      },
      "required": [
        "blocks",
        "summary",
        "type"
      ],
      "type": "object"
    }
  ],
  "title": "Block",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/BlockElement.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "oneOf": [
    {
      "properties": {
        "action_id": {
          "type": "string"
        },
        "style": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/ButtonStyle.schema.json"
            },
            {
              "type": "null"
            }
          ]
        },
        "text": {
          "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
        },
        "type": {
          "enum": [
            "button"
          ],
          "type": "string"
        },
        "url": {
          "type": [
            "string",
            "null"
          ]
        },
        "value": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "action_id",
        "text",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "alt_text": {
          "type": "string"
        },
        "image_url": {
          "type": "string"
        },
        "type": {
          "enum": [
            "image"
          ],
          "type": "string"
        }
      },
      "required": [
        "alt_text",
        "image_url",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "action_id": {
          "type": "string"
        },
        "options": {
          "items": {
            "$ref": "../../codegen/primitives/OptionObject.schema.json"
          },
          "type": "array"
        },
        "type": {
          "enum": [
            "overflow"
          ],
          "type": "string"
        }
      },
      "required": [
        "action_id",
        "options",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "action_id": {
          "type": "string"
        },
        "initial_value": {
          "type": [
            "string",
            "null"
          ]
        },
        "multiline": {
          "default": false,
          "type": "boolean"
        },
        "placeholder": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
            },
            {
              "type": "null"
            }
          ]
        },
        "type": {
          "enum": [
            "plain_text_input"
          ],
          "type": "string"
        }
      },
      "required": [
        "action_id",
        "type"
      ],
      "type": "object"
    }
  ],
  "title": "BlockElement",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/BlockMessage.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AccordionState": {
      "enum": [
        "collapsed",
        "expanded"
      ],
      "type": "string"
    },
    "Block": {
      "description": "A single visual block in a message",
      "oneOf": [
        {
          "description": "Displays text, possibly alongside an accessory (image, button, etc.)",
          "properties": {
            "accessory": {
              "anyOf": [
                {
                  "$ref": "../../codegen/primitives/BlockElement.schema.json"
                },
                {
                  "type": "null"
                }
              ]
            },
            "fields": {
              "items": {
                "$ref": "../../codegen/primitives/TextObject.schema.json"
              },
              "type": [
                "array",
                "null"
              ]
            },
            "text": {
              "$ref": "../../codegen/primitives/TextObject.schema.json"
            },
            "type": {
              "enum": [
                "section"
              ],
              "type": "string"
            }
          },
          "required": [
            "text",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A visual separator",
          "properties": {
            "type": {
              "enum": [
                "divider"
              ],
              "type": "string"
            }
          },
          "required": [
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Displays an image with optional title",
          "properties": {
            "alt_text": {
              "type": "string"
            },
            "image_url": {
              "type": "string"
            },
            "title": {
              "anyOf": [
                {
                  "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
                },
                {
                  "type": "null"
                }
              ]
            },
            "type": {
              "enum": [
                "image"
              ],
              "type": "string"
            }
          },
          "required": [
            "alt_text",
            "image_url",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A container for interactive elements (buttons, selects, etc.)",
          "properties": {
            "elements": {
              "items": {
                "$ref": "../../codegen/primitives/BlockElement.schema.json"
              },
              "type": "array"
            },
            "type": {
              "enum": [
                "actions"
              ],
              "type": "string"
            }
          },
          "required": [
            "elements",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Displays contextual info (small grey text, images)",
          "properties": {
            "elements": {
              "items": {
                "$ref": "../../codegen/primitives/ContextElement.schema.json"
              },
              "type": "array"
            },
            "type": {
              "enum": [
                "context"
              ],
              "type": "string"
            }
          },
          "required": [
            "elements",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A header with large, bold text",
          "properties": {
            "text": {
              "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
            },
            "type": {
              "enum": [
                "header"
              ],
              "type": "string"
            }
          },
          "required": [
            "text",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "An input field",
          "properties": {
            "element": {
              "$ref": "../../codegen/primitives/BlockElement.schema.json"
            },
            "hint": {
              "anyOf": [
                {
                  "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
                },
                {
                  "type": "null"
                }
              ]
            },
            "label": {
              "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
            },
            "optional": {
              "default": false,
              "type": "boolean"
            },
            "type": {
              "enum": [
                "input"
              ],
              "type": "string"
            }
          },
          "required": [
            "element",
            "label",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "A collapsible container",
          "properties": {
            "blocks": {
              "items": {
                "$ref": "#/definitions/Block"
              },
              "type": "array"
            },
            "initial_state": {
              "allOf": [
                {
                  "$ref": "#/definitions/AccordionState"
                }
              ],
              "default": "collapsed"
            },
            "summary": {
              "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
            },
            "type": {
              "enum": [
                "accordion"
              ],
              "type": "string"
            }
          },
          "required": [
            "blocks",
            "summary",
            "type"
          ],
          "type": "object"
        }
      ]
    }
  },
  "description": "The root container for a Block Kit message",
  "properties": {
    "blocks": {
      "items": {
        "$ref": "#/definitions/Block"
      },
      "type": "array"
    }
  },
  "required": [
    "blocks"
  ],
  "title": "BlockMessage",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/ButtonElement.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "action_id": {
      "type": "string"
    },
    "style": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/ButtonStyle.schema.json"
        },
        {
          "type": "null"
        }
      ]
    },
    "text": {
      "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
    },
    "url": {
      "type": [
        "string",
        "null"
      ]
    },
    "value": {
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "action_id",
    "text"
  ],
  "title": "ButtonElement",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/ButtonStyle.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "enum": [
    "primary",
    "danger"
  ],
  "title": "ButtonStyle",
  "type": "string",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/ContextBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Displays contextual info (small grey text, images)",
  "properties": {
    "elements": {
      "items": {
        "$ref": "../../codegen/primitives/ContextElement.schema.json"
      },
      "type": "array"
    }
  },
  "required": [
    "elements"
  ],
  "title": "ContextBlock",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/ContextElement.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "oneOf": [
    {
      "properties": {
        "alt_text": {
          "type": "string"
        },
        "image_url": {
          "type": "string"
        },
        "type": {
          "enum": [
            "image"
          ],
          "type": "string"
        }
      },
      "required": [
        "alt_text",
        "image_url",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "text": {
          "type": "string"
        },
        "type": {
          "enum": [
            "mrkdwn"
          ],
          "type": "string"
        },
        "verbatim": {
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "text",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "emoji": {
          "default": false,
          "type": "boolean"
        },
        "text": {
          "type": "string"
        },
        "type": {
          "enum": [
            "plain_text"
          ],
          "type": "string"
        }
      },
      "required": [
        "text",
        "type"
      ],
      "type": "object"
    }
  ],
  "title": "ContextElement",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/DividerBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A visual separator",
  "title": "DividerBlock",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/HeaderBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A header with large, bold text",
  "properties": {
    "text": {
      "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
    }
  },
  "required": [
    "text"
  ],
  "title": "HeaderBlock",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/ImageBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Displays an image with optional title",
  "properties": {
    "alt_text": {
      "type": "string"
    },
    "image_url": {
      "type": "string"
    },
    "title": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "alt_text",
    "image_url"
  ],
  "title": "ImageBlock",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/ImageElement.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "alt_text": {
      "type": "string"
    },
    "image_url": {
      "type": "string"
    }
  },
  "required": [
    "alt_text",
    "image_url"
  ],
  "title": "ImageElement",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/InputBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "An input field",
  "properties": {
    "element": {
      "$ref": "../../codegen/primitives/BlockElement.schema.json"
    },
    "hint": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
        },
        {
          "type": "null"
        }
      ]
    },
    "label": {
      "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
    },
    "optional": {
      "default": false,
      "type": "boolean"
    }
  },
  "required": [
    "element",
    "label"
  ],
  "title": "InputBlock",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/MarkdownTextObject.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "text": {
      "type": "string"
    },
    "verbatim": {
      "default": false,
      "type": "boolean"
    }
  },
  "required": [
    "text"
  ],
  "title": "MarkdownTextObject",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/OptionObject.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "description": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
        },
        {
          "type": "null"
        }
      ]
    },
    "text": {
      "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
    },
    "url": {
      "type": [
        "string",
        "null"
      ]
    },
    "value": {
      "type": "string"
    }
  },
  "required": [
    "text",
    "value"
  ],
  "title": "OptionObject",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/OverflowElement.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "action_id": {
      "type": "string"
    },
    "options": {
      "items": {
        "$ref": "../../codegen/primitives/OptionObject.schema.json"
      },
      "type": "array"
    }
  },
  "required": [
    "action_id",
    "options"
  ],
  "title": "OverflowElement",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/PlainTextInputElement.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "action_id": {
      "type": "string"
    },
    "initial_value": {
      "type": [
        "string",
        "null"
      ]
    },
    "multiline": {
      "default": false,
      "type": "boolean"
    },
    "placeholder": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/PlainTextObject.schema.json"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "required": [
    "action_id"
  ],
  "title": "PlainTextInputElement",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/PlainTextObject.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "properties": {
    "emoji": {
      "default": false,
      "type": "boolean"
    },
    "text": {
      "type": "string"
    }
  },
  "required": [
    "text"
  ],
  "title": "PlainTextObject",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/SectionBlock.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Displays text, possibly alongside an accessory (image, button, etc.)",
  "properties": {
    "accessory": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/BlockElement.schema.json"
        },
        {
          "type": "null"
        }
      ]
    },
    "fields": {
      "items": {
        "$ref": "../../codegen/primitives/TextObject.schema.json"
      },
      "type": [
        "array",
        "null"
      ]
    },
    "text": {
      "$ref": "../../codegen/primitives/TextObject.schema.json"
    }
  },
  "required": [
    "text"
  ],
  "title": "SectionBlock",
  "type": "object",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/domain/ui/TextObject.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "oneOf": [
    {
      "properties": {
        "emoji": {
          "default": false,
          "type": "boolean"
        },
        "text": {
          "type": "string"
        },
        "type": {
          "enum": [
            "plain_text"
          ],
          "type": "string"
        }
      },
      "required": [
        "text",
        "type"
      ],
      "type": "object"
    },
    {
      "properties": {
        "text": {
          "type": "string"
        },
        "type": {
          "enum": [
            "mrkdwn"
          ],
          "type": "string"
        },
        "verbatim": {
          "default": false,
          "type": "boolean"
        }
      },
      "required": [
        "text",
        "type"
      ],
      "type": "object"
    }
  ],
  "title": "TextObject",
  "x-familiar-kind": "ui",
  "x-familiar-service": {
    "$ref": "../../infrastructure/nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/actions/classification/extract-features.action.json

```json
{
  "$schema": "../../../architecture/meta/Action.meta.schema.json",
  "$id": "infrastructure/actions/classification/extract-features.action.json",
  "id": "classification.extract-features",
  "title": "Extract Segment Features",
  "description": "Extract semantic and temporal features from text segments",
  "x-familiar-kind": "action",
  "x-familiar-compute-category": "ai",
  "x-familiar-execution-model": "async",
  "x-familiar-side-effects": ["ml-inference"],
  "x-familiar-reliability": "idempotent",
  "signature": {
    "inputs": {
      "segment": {
        "schema": { "$ref": "../../../primitives/Segment.schema.json" },
        "semantics": "borrow"
      }
    },
    "output": {
      "schema": { "$ref": "../../../primitives/SegmentFeatures.schema.json" },
      "nature": "atomic"
    },
    "capabilities": {
      "category": "feature-extraction",
      "provides": ["semantic-features", "temporal-features"],
      "description": "Feature extraction models for semantic understanding"
    }
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/nodes/familiar-daemon.node.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "High-performance service node for LLM-connected operations. Runs Fates pipeline systems with low latency.",
  "title": "FamiliarDaemon",
  "x-familiar-components": [
    {
      "$ref": "../../codegen/components/TigerDataStore.component.json"
    },
    {
      "$ref": "../../codegen/components/ContractEnforcer.component.json"
    }
  ],
  "x-familiar-concurrency": 10,
  "x-familiar-kind": "node",
  "x-familiar-memory": "2Gi",
  "x-familiar-meta-schema": {
    "$ref": "../architecture/ecs/Node.meta.schema.json"
  },
  "x-familiar-queue": "daemon-queue",
  "x-familiar-resource-class": "llm",
  "x-familiar-resources": [
    {
      "$ref": "../resources/postgres-tiger.resource.json"
    },
    {
      "$ref": "../resources/openai-gpt4.resource.json"
    },
    {
      "$ref": "../resources/anthropic-claude.resource.json"
    }
  ],
  "x-familiar-systems": [
    {
      "$ref": "../systems/FatesGate.system.json"
    },
    {
      "$ref": "../systems/FatesMorta.system.json"
    },
    {
      "$ref": "../systems/FatesDecima.system.json"
    },
    {
      "$ref": "../systems/FatesNona.system.json"
    }
  ]
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/nodes/familiar-worker.node.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Batch processing service node for IO-bound operations. Runs non-LLM tasks like database maintenance and exports.",
  "title": "FamiliarWorker",
  "x-familiar-components": [
    {
      "$ref": "../../codegen/components/DatabasePool.component.json"
    }
  ],
  "x-familiar-concurrency": 50,
  "x-familiar-kind": "node",
  "x-familiar-memory": "512Mi",
  "x-familiar-meta-schema": {
    "$ref": "../architecture/ecs/Node.meta.schema.json"
  },
  "x-familiar-queue": "worker-queue",
  "x-familiar-resource-class": "io",
  "x-familiar-resources": [
    {
      "$ref": "../resources/postgres-main.resource.json"
    }
  ],
  "x-familiar-systems": []
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/queues/daemon-queue.queue.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Temporal task queue for LLM-bound operations. Routes work to familiar-daemon nodes.",
  "title": "DaemonQueue",
  "x-familiar-concurrency": 10,
  "x-familiar-consumers": [
    {
      "$ref": "../nodes/familiar-daemon.node.json"
    }
  ],
  "x-familiar-kind": "queue",
  "x-familiar-meta-schema": {
    "$ref": "../architecture/ecs/Queue.meta.schema.json"
  },
  "x-familiar-queue-type": "temporal",
  "x-familiar-resource-class": "llm",
  "x-familiar-retention": "24h",
  "x-familiar-visibility-timeout": "5m"
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/queues/worker-queue.queue.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Temporal task queue for IO-bound batch operations. Routes work to familiar-worker nodes.",
  "title": "WorkerQueue",
  "x-familiar-concurrency": 50,
  "x-familiar-consumers": [
    {
      "$ref": "../nodes/familiar-worker.node.json"
    }
  ],
  "x-familiar-kind": "queue",
  "x-familiar-meta-schema": {
    "$ref": "../architecture/ecs/Queue.meta.schema.json"
  },
  "x-familiar-queue-type": "temporal",
  "x-familiar-resource-class": "io",
  "x-familiar-retention": "7d",
  "x-familiar-visibility-timeout": "30s"
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/resources/anthropic-claude.resource.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Virtual resource representing Anthropic's Claude API. Acts as a proxy contract defining expected capabilities.",
  "title": "AnthropicClaude",
  "x-familiar-endpoint": "https://api.anthropic.com/v1/messages",
  "x-familiar-health-check": {
    "endpoint": "https://api.anthropic.com/v1/models",
    "interval": "5m"
  },
  "x-familiar-kind": "resource",
  "x-familiar-meta-schema": {
    "$ref": "../architecture/ecs/Resource.meta.schema.json"
  },
  "x-familiar-models": [
    "claude-3-5-sonnet-20241022",
    "claude-3-5-haiku-20241022",
    "claude-3-opus-20240229",
    "claude-3-sonnet-20240229"
  ],
  "x-familiar-rate-limit": 4000,
  "x-familiar-resource-type": "llm-api",
  "x-familiar-virtual": true
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/resources/openai-gpt4.resource.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Virtual resource representing OpenAI's GPT-4 API. Acts as a proxy contract defining expected capabilities.",
  "title": "OpenAIGPT4",
  "x-familiar-endpoint": "https://api.openai.com/v1/chat/completions",
  "x-familiar-health-check": {
    "endpoint": "https://api.openai.com/v1/models",
    "interval": "5m"
  },
  "x-familiar-kind": "resource",
  "x-familiar-meta-schema": {
    "$ref": "../architecture/ecs/Resource.meta.schema.json"
  },
  "x-familiar-models": [
    "gpt-4",
    "gpt-4-turbo",
    "gpt-4-turbo-preview",
    "gpt-4o",
    "gpt-4o-mini"
  ],
  "x-familiar-rate-limit": 10000,
  "x-familiar-resource-type": "llm-api",
  "x-familiar-virtual": true
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/resources/postgres-main.resource.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Primary PostgreSQL database for core application data including auth, users, and configuration.",
  "title": "PostgresMain",
  "x-familiar-config": {
    "$ref": "../../codegen/components/DbPoolConfig.schema.json"
  },
  "x-familiar-connection-pool": {
    "max": 20,
    "min": 5
  },
  "x-familiar-health-check": {
    "endpoint": "/health/db",
    "interval": "30s"
  },
  "x-familiar-kind": "resource",
  "x-familiar-meta-schema": {
    "$ref": "../architecture/ecs/Resource.meta.schema.json"
  },
  "x-familiar-resource-type": "database",
  "x-familiar-tables": [
    "users",
    "tenants",
    "sessions",
    "invitations",
    "join_requests",
    "magic_links",
    "consent_records",
    "audit_logs"
  ],
  "x-familiar-virtual": false
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/resources/postgres-tiger.resource.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "TimescaleDB instance for Tiger physics engine data - moments, pulses, bonds, and filaments.",
  "title": "PostgresTiger",
  "x-familiar-config": {
    "$ref": "../../codegen/components/DbPoolConfig.schema.json"
  },
  "x-familiar-connection-pool": {
    "max": 50,
    "min": 10
  },
  "x-familiar-health-check": {
    "endpoint": "/health/tiger",
    "interval": "15s"
  },
  "x-familiar-kind": "resource",
  "x-familiar-meta-schema": {
    "$ref": "../architecture/ecs/Resource.meta.schema.json"
  },
  "x-familiar-resource-type": "database",
  "x-familiar-tables": [
    "moments",
    "threads",
    "pulses",
    "bonds",
    "filaments",
    "shuttles",
    "courses",
    "weaves"
  ],
  "x-familiar-virtual": false
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/systems/FatesDecima.system.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Fate of Measure - handles quantification, measurement, and metric calculation in the Fates pipeline.",
  "title": "FatesDecima",
  "x-familiar-depends": [
    {
      "$ref": "../../codegen/components/TigerDataStore.component.json"
    }
  ],
  "x-familiar-kind": "system",
  "x-familiar-meta-schema": {
    "$ref": "../architecture/ecs/System.meta.schema.json"
  },
  "x-familiar-queue": "daemon-queue",
  "x-familiar-reads": [
    {
      "$ref": "../../codegen/entities/Shuttle.schema.json"
    },
    {
      "$ref": "../../codegen/entities/Moment.schema.json"
    }
  ],
  "x-familiar-retries": 3,
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  },
  "x-familiar-timeout": "45s",
  "x-familiar-writes": [
    {
      "$ref": "../../codegen/entities/Bond.schema.json"
    }
  ]
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/systems/FatesGate.system.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Entry point to the Fates pipeline. Performs initial classification and routing of incoming messages.",
  "title": "FatesGate",
  "x-familiar-depends": [
    {
      "$ref": "../../codegen/components/TigerDataStore.component.json"
    },
    {
      "$ref": "../../codegen/components/ContractEnforcer.component.json"
    }
  ],
  "x-familiar-input": {
    "$ref": "../tools/GateInput.schema.json"
  },
  "x-familiar-kind": "system",
  "x-familiar-meta-schema": {
    "$ref": "../architecture/ecs/System.meta.schema.json"
  },
  "x-familiar-output": {
    "$ref": "../tools/GateOutput.schema.json"
  },
  "x-familiar-queue": "daemon-queue",
  "x-familiar-reads": [
    {
      "$ref": "../../codegen/entities/Moment.schema.json"
    },
    {
      "$ref": "../../codegen/entities/Thread.schema.json"
    },
    {
      "$ref": "../../codegen/entities/Course.schema.json"
    }
  ],
  "x-familiar-retries": 3,
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  },
  "x-familiar-timeout": "30s",
  "x-familiar-writes": [
    {
      "$ref": "../../codegen/entities/Shuttle.schema.json"
    }
  ]
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/systems/FatesMorta.system.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Fate of Death - handles completion, termination, and lifecycle endings in the Fates pipeline.",
  "title": "FatesMorta",
  "x-familiar-depends": [
    {
      "$ref": "../../codegen/components/TigerDataStore.component.json"
    }
  ],
  "x-familiar-kind": "system",
  "x-familiar-meta-schema": {
    "$ref": "../architecture/ecs/System.meta.schema.json"
  },
  "x-familiar-queue": "daemon-queue",
  "x-familiar-reads": [
    {
      "$ref": "../../codegen/entities/Shuttle.schema.json"
    },
    {
      "$ref": "../../codegen/entities/Thread.schema.json"
    }
  ],
  "x-familiar-retries": 2,
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  },
  "x-familiar-timeout": "60s",
  "x-familiar-writes": [
    {
      "$ref": "../../codegen/entities/Pulse.schema.json"
    }
  ]
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/systems/FatesNona.system.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Fate of Spinning - handles weaving, connection, and relationship building in the Fates pipeline.",
  "title": "FatesNona",
  "x-familiar-depends": [
    {
      "$ref": "../../codegen/components/TigerDataStore.component.json"
    }
  ],
  "x-familiar-kind": "system",
  "x-familiar-meta-schema": {
    "$ref": "../architecture/ecs/System.meta.schema.json"
  },
  "x-familiar-queue": "daemon-queue",
  "x-familiar-reads": [
    {
      "$ref": "../../codegen/entities/Shuttle.schema.json"
    },
    {
      "$ref": "../../codegen/entities/Bond.schema.json"
    }
  ],
  "x-familiar-retries": 3,
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  },
  "x-familiar-timeout": "60s",
  "x-familiar-writes": [
    {
      "$ref": "../../codegen/entities/Filament.schema.json"
    }
  ]
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/AudioFeatures.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Audio characteristics",
  "properties": {
    "pitch_variance": {
      "default": null,
      "description": "Pitch variation",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "speaking_rate": {
      "default": null,
      "description": "Speaking rate (words per minute)",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "voice_emotion": {
      "default": null,
      "description": "Detected emotion from voice",
      "type": [
        "string",
        "null"
      ]
    },
    "volume": {
      "description": "Average volume (0.0 to 1.0)",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "volume"
  ],
  "title": "AudioFeatures",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/AudioSegmentFeatures.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AudioFeatures": {
      "description": "Audio characteristics",
      "properties": {
        "pitch_variance": {
          "default": null,
          "description": "Pitch variation",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "speaking_rate": {
          "default": null,
          "description": "Speaking rate (words per minute)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "voice_emotion": {
          "default": null,
          "description": "Detected emotion from voice",
          "type": [
            "string",
            "null"
          ]
        },
        "volume": {
          "description": "Average volume (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "volume"
      ],
      "type": "object"
    }
  },
  "description": "Audio-specific segment features",
  "properties": {
    "audio_features": {
      "allOf": [
        {
          "$ref": "#/definitions/AudioFeatures"
        }
      ],
      "description": "Audio characteristics"
    },
    "speaker_id": {
      "default": null,
      "description": "Speaker ID",
      "type": [
        "string",
        "null"
      ]
    },
    "transcript": {
      "description": "Transcribed text",
      "type": "string"
    }
  },
  "required": [
    "audio_features",
    "transcript"
  ],
  "title": "AudioSegmentFeatures",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BindingCharacteristics.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "SemanticProperties": {
      "description": "Semantic properties of binding",
      "properties": {
        "relationship_description": {
          "default": null,
          "description": "Relationship description",
          "type": [
            "string",
            "null"
          ]
        },
        "shared_concepts": {
          "default": [],
          "description": "Shared concepts/topics",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "similarity": {
          "description": "Semantic similarity score",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "similarity"
      ],
      "type": "object"
    },
    "TemporalProperties": {
      "description": "Temporal properties of binding",
      "properties": {
        "gap": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/TimeGap.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Time gap between entities"
        },
        "recurring": {
          "default": false,
          "description": "Is this a recurring pattern?",
          "type": "boolean"
        },
        "relation": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/TemporalRelation.schema.json"
            }
          ],
          "description": "Time relation"
        }
      },
      "required": [
        "relation"
      ],
      "type": "object"
    }
  },
  "description": "Binding characteristics",
  "properties": {
    "binding_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/BindingType.schema.json"
        }
      ],
      "description": "Type of cognitive binding"
    },
    "directionality": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/Directionality.schema.json"
        }
      ],
      "description": "Directionality"
    },
    "salience": {
      "description": "Salience (how notable/memorable)",
      "format": "double",
      "type": "number"
    },
    "semantic": {
      "anyOf": [
        {
          "$ref": "#/definitions/SemanticProperties"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Semantic properties"
    },
    "strength": {
      "description": "Strength of binding (0.0 to 1.0)",
      "format": "double",
      "type": "number"
    },
    "temporal": {
      "anyOf": [
        {
          "$ref": "#/definitions/TemporalProperties"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Temporal properties"
    }
  },
  "required": [
    "binding_type",
    "directionality",
    "salience",
    "strength"
  ],
  "title": "BindingCharacteristics",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BindingEvidence.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BindingEvidenceType": {
      "description": "Types of binding evidence",
      "oneOf": [
        {
          "description": "Explicit linguistic marker",
          "enum": [
            "linguistic_marker"
          ],
          "type": "string"
        },
        {
          "description": "Temporal proximity",
          "enum": [
            "temporal_proximity"
          ],
          "type": "string"
        },
        {
          "description": "Semantic similarity",
          "enum": [
            "semantic_similarity"
          ],
          "type": "string"
        },
        {
          "description": "Entity co-reference",
          "enum": [
            "co_reference"
          ],
          "type": "string"
        },
        {
          "description": "Emotional similarity",
          "enum": [
            "emotional_similarity"
          ],
          "type": "string"
        },
        {
          "description": "Narrative continuity",
          "enum": [
            "narrative_continuity"
          ],
          "type": "string"
        },
        {
          "description": "User explicit statement",
          "enum": [
            "explicit_statement"
          ],
          "type": "string"
        },
        {
          "description": "Inferred from context",
          "enum": [
            "contextual_inference"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Evidence for a detected binding",
  "properties": {
    "evidence_type": {
      "allOf": [
        {
          "$ref": "#/definitions/BindingEvidenceType"
        }
      ],
      "description": "Type of evidence"
    },
    "explanation": {
      "description": "Explanation",
      "type": "string"
    },
    "markers": {
      "default": [],
      "description": "Specific markers found",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "trigger_text": {
      "description": "Text that triggered detection",
      "type": "string"
    }
  },
  "required": [
    "evidence_type",
    "explanation",
    "trigger_text"
  ],
  "title": "BindingEvidence",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BindingEvidenceType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of binding evidence",
  "oneOf": [
    {
      "description": "Explicit linguistic marker",
      "enum": [
        "linguistic_marker"
      ],
      "type": "string"
    },
    {
      "description": "Temporal proximity",
      "enum": [
        "temporal_proximity"
      ],
      "type": "string"
    },
    {
      "description": "Semantic similarity",
      "enum": [
        "semantic_similarity"
      ],
      "type": "string"
    },
    {
      "description": "Entity co-reference",
      "enum": [
        "co_reference"
      ],
      "type": "string"
    },
    {
      "description": "Emotional similarity",
      "enum": [
        "emotional_similarity"
      ],
      "type": "string"
    },
    {
      "description": "Narrative continuity",
      "enum": [
        "narrative_continuity"
      ],
      "type": "string"
    },
    {
      "description": "User explicit statement",
      "enum": [
        "explicit_statement"
      ],
      "type": "string"
    },
    {
      "description": "Inferred from context",
      "enum": [
        "contextual_inference"
      ],
      "type": "string"
    }
  ],
  "title": "BindingEvidenceType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BindingGraphUpdate.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BindingCharacteristics": {
      "description": "Binding characteristics",
      "properties": {
        "binding_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/BindingType.schema.json"
            }
          ],
          "description": "Type of cognitive binding"
        },
        "directionality": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/Directionality.schema.json"
            }
          ],
          "description": "Directionality"
        },
        "salience": {
          "description": "Salience (how notable/memorable)",
          "format": "double",
          "type": "number"
        },
        "semantic": {
          "anyOf": [
            {
              "$ref": "#/definitions/SemanticProperties"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Semantic properties"
        },
        "strength": {
          "description": "Strength of binding (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "temporal": {
          "anyOf": [
            {
              "$ref": "#/definitions/TemporalProperties"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Temporal properties"
        }
      },
      "required": [
        "binding_type",
        "directionality",
        "salience",
        "strength"
      ],
      "type": "object"
    },
    "GraphUpdateType": {
      "description": "Types of graph updates",
      "oneOf": [
        {
          "description": "Add new binding",
          "enum": [
            "add_binding"
          ],
          "type": "string"
        },
        {
          "description": "Strengthen existing binding",
          "enum": [
            "strengthen_binding"
          ],
          "type": "string"
        },
        {
          "description": "Weaken existing binding",
          "enum": [
            "weaken_binding"
          ],
          "type": "string"
        },
        {
          "description": "Remove binding",
          "enum": [
            "remove_binding"
          ],
          "type": "string"
        },
        {
          "description": "Merge duplicate bindings",
          "enum": [
            "merge_bindings"
          ],
          "type": "string"
        }
      ]
    },
    "SemanticProperties": {
      "description": "Semantic properties of binding",
      "properties": {
        "relationship_description": {
          "default": null,
          "description": "Relationship description",
          "type": [
            "string",
            "null"
          ]
        },
        "shared_concepts": {
          "default": [],
          "description": "Shared concepts/topics",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "similarity": {
          "description": "Semantic similarity score",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "similarity"
      ],
      "type": "object"
    },
    "TemporalProperties": {
      "description": "Temporal properties of binding",
      "properties": {
        "gap": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/TimeGap.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Time gap between entities"
        },
        "recurring": {
          "default": false,
          "description": "Is this a recurring pattern?",
          "type": "boolean"
        },
        "relation": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/TemporalRelation.schema.json"
            }
          ],
          "description": "Time relation"
        }
      },
      "required": [
        "relation"
      ],
      "type": "object"
    }
  },
  "description": "Update to the binding graph",
  "properties": {
    "binding": {
      "anyOf": [
        {
          "$ref": "#/definitions/BindingCharacteristics"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Binding characteristics"
    },
    "source_id": {
      "description": "Source entity ID",
      "type": "string"
    },
    "target_id": {
      "default": null,
      "description": "Target entity ID",
      "type": [
        "string",
        "null"
      ]
    },
    "update_type": {
      "allOf": [
        {
          "$ref": "#/definitions/GraphUpdateType"
        }
      ],
      "description": "Type of update"
    }
  },
  "required": [
    "source_id",
    "update_type"
  ],
  "title": "BindingGraphUpdate",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BindingHintInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ContextWindow": {
      "description": "Context window for binding analysis",
      "properties": {
        "following": {
          "default": [],
          "description": "Following content",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "preceding": {
          "default": [],
          "description": "Preceding content",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "time_span_hours": {
          "default": null,
          "description": "Time span in hours",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "EntityRef": {
      "description": "Reference to an entity for binding",
      "properties": {
        "content": {
          "description": "Content/description",
          "type": "string"
        },
        "entity_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/EntityType.schema.json"
            }
          ],
          "description": "Entity type"
        },
        "id": {
          "default": null,
          "description": "Entity ID (if existing)",
          "type": [
            "string",
            "null"
          ]
        },
        "timestamp": {
          "default": null,
          "description": "When created (for temporal binding)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "content",
        "entity_type"
      ],
      "type": "object"
    }
  },
  "description": "Input for binding hint generation",
  "properties": {
    "context_window": {
      "anyOf": [
        {
          "$ref": "#/definitions/ContextWindow"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Context window for binding analysis"
    },
    "current_entity": {
      "allOf": [
        {
          "$ref": "#/definitions/EntityRef"
        }
      ],
      "description": "Entity being spawned"
    },
    "recent_entities": {
      "default": [],
      "description": "Recent entities for binding detection",
      "items": {
        "$ref": "#/definitions/EntityRef"
      },
      "type": "array"
    },
    "segment": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/Segment.schema.json"
        }
      ],
      "description": "The current segment"
    }
  },
  "required": [
    "current_entity",
    "segment"
  ],
  "title": "BindingHintInput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "input",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BindingHintOutput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BindingCharacteristics": {
      "description": "Binding characteristics",
      "properties": {
        "binding_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/BindingType.schema.json"
            }
          ],
          "description": "Type of cognitive binding"
        },
        "directionality": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/Directionality.schema.json"
            }
          ],
          "description": "Directionality"
        },
        "salience": {
          "description": "Salience (how notable/memorable)",
          "format": "double",
          "type": "number"
        },
        "semantic": {
          "anyOf": [
            {
              "$ref": "#/definitions/SemanticProperties"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Semantic properties"
        },
        "strength": {
          "description": "Strength of binding (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "temporal": {
          "anyOf": [
            {
              "$ref": "#/definitions/TemporalProperties"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Temporal properties"
        }
      },
      "required": [
        "binding_type",
        "directionality",
        "salience",
        "strength"
      ],
      "type": "object"
    },
    "BindingEvidence": {
      "description": "Evidence for a detected binding",
      "properties": {
        "evidence_type": {
          "allOf": [
            {
              "$ref": "#/definitions/BindingEvidenceType"
            }
          ],
          "description": "Type of evidence"
        },
        "explanation": {
          "description": "Explanation",
          "type": "string"
        },
        "markers": {
          "default": [],
          "description": "Specific markers found",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "trigger_text": {
          "description": "Text that triggered detection",
          "type": "string"
        }
      },
      "required": [
        "evidence_type",
        "explanation",
        "trigger_text"
      ],
      "type": "object"
    },
    "BindingEvidenceType": {
      "description": "Types of binding evidence",
      "oneOf": [
        {
          "description": "Explicit linguistic marker",
          "enum": [
            "linguistic_marker"
          ],
          "type": "string"
        },
        {
          "description": "Temporal proximity",
          "enum": [
            "temporal_proximity"
          ],
          "type": "string"
        },
        {
          "description": "Semantic similarity",
          "enum": [
            "semantic_similarity"
          ],
          "type": "string"
        },
        {
          "description": "Entity co-reference",
          "enum": [
            "co_reference"
          ],
          "type": "string"
        },
        {
          "description": "Emotional similarity",
          "enum": [
            "emotional_similarity"
          ],
          "type": "string"
        },
        {
          "description": "Narrative continuity",
          "enum": [
            "narrative_continuity"
          ],
          "type": "string"
        },
        {
          "description": "User explicit statement",
          "enum": [
            "explicit_statement"
          ],
          "type": "string"
        },
        {
          "description": "Inferred from context",
          "enum": [
            "contextual_inference"
          ],
          "type": "string"
        }
      ]
    },
    "BindingGraphUpdate": {
      "description": "Update to the binding graph",
      "properties": {
        "binding": {
          "anyOf": [
            {
              "$ref": "#/definitions/BindingCharacteristics"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Binding characteristics"
        },
        "source_id": {
          "description": "Source entity ID",
          "type": "string"
        },
        "target_id": {
          "default": null,
          "description": "Target entity ID",
          "type": [
            "string",
            "null"
          ]
        },
        "update_type": {
          "allOf": [
            {
              "$ref": "#/definitions/GraphUpdateType"
            }
          ],
          "description": "Type of update"
        }
      },
      "required": [
        "source_id",
        "update_type"
      ],
      "type": "object"
    },
    "DetectedBinding": {
      "description": "A detected binding between entities",
      "properties": {
        "binding": {
          "allOf": [
            {
              "$ref": "#/definitions/BindingCharacteristics"
            }
          ],
          "description": "Binding characteristics"
        },
        "confidence": {
          "description": "Confidence in detection",
          "format": "double",
          "type": "number"
        },
        "evidence": {
          "allOf": [
            {
              "$ref": "#/definitions/BindingEvidence"
            }
          ],
          "description": "Evidence for the binding"
        },
        "source": {
          "allOf": [
            {
              "$ref": "#/definitions/EntityRef"
            }
          ],
          "description": "Source entity"
        },
        "target": {
          "allOf": [
            {
              "$ref": "#/definitions/EntityRef"
            }
          ],
          "description": "Target entity"
        }
      },
      "required": [
        "binding",
        "confidence",
        "evidence",
        "source",
        "target"
      ],
      "type": "object"
    },
    "EntityRef": {
      "description": "Reference to an entity for binding",
      "properties": {
        "content": {
          "description": "Content/description",
          "type": "string"
        },
        "entity_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/EntityType.schema.json"
            }
          ],
          "description": "Entity type"
        },
        "id": {
          "default": null,
          "description": "Entity ID (if existing)",
          "type": [
            "string",
            "null"
          ]
        },
        "timestamp": {
          "default": null,
          "description": "When created (for temporal binding)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "content",
        "entity_type"
      ],
      "type": "object"
    },
    "GraphUpdateType": {
      "description": "Types of graph updates",
      "oneOf": [
        {
          "description": "Add new binding",
          "enum": [
            "add_binding"
          ],
          "type": "string"
        },
        {
          "description": "Strengthen existing binding",
          "enum": [
            "strengthen_binding"
          ],
          "type": "string"
        },
        {
          "description": "Weaken existing binding",
          "enum": [
            "weaken_binding"
          ],
          "type": "string"
        },
        {
          "description": "Remove binding",
          "enum": [
            "remove_binding"
          ],
          "type": "string"
        },
        {
          "description": "Merge duplicate bindings",
          "enum": [
            "merge_bindings"
          ],
          "type": "string"
        }
      ]
    },
    "SemanticProperties": {
      "description": "Semantic properties of binding",
      "properties": {
        "relationship_description": {
          "default": null,
          "description": "Relationship description",
          "type": [
            "string",
            "null"
          ]
        },
        "shared_concepts": {
          "default": [],
          "description": "Shared concepts/topics",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "similarity": {
          "description": "Semantic similarity score",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "similarity"
      ],
      "type": "object"
    },
    "TemporalProperties": {
      "description": "Temporal properties of binding",
      "properties": {
        "gap": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/TimeGap.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Time gap between entities"
        },
        "recurring": {
          "default": false,
          "description": "Is this a recurring pattern?",
          "type": "boolean"
        },
        "relation": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/TemporalRelation.schema.json"
            }
          ],
          "description": "Time relation"
        }
      },
      "required": [
        "relation"
      ],
      "type": "object"
    }
  },
  "description": "Output from binding hint generation",
  "properties": {
    "bindings": {
      "description": "Detected bindings",
      "items": {
        "$ref": "#/definitions/DetectedBinding"
      },
      "type": "array"
    },
    "graph_updates": {
      "default": [],
      "description": "Binding graph additions",
      "items": {
        "$ref": "#/definitions/BindingGraphUpdate"
      },
      "type": "array"
    }
  },
  "required": [
    "bindings"
  ],
  "title": "BindingHintOutput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "output",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BindingHints.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "EntityReference": {
      "description": "Reference to an entity for binding",
      "properties": {
        "description": {
          "description": "Description for matching",
          "type": "string"
        },
        "entity_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/EntityType.schema.json"
            }
          ],
          "description": "Entity type"
        },
        "id": {
          "default": null,
          "description": "Entity ID (if existing)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "description",
        "entity_type"
      ],
      "type": "object"
    },
    "TemporalBinding": {
      "description": "Temporal aspect of binding",
      "properties": {
        "gap": {
          "default": null,
          "description": "Time gap (if known)",
          "type": [
            "string",
            "null"
          ]
        },
        "relation": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/TemporalRelation.schema.json"
            }
          ],
          "description": "Time relationship"
        }
      },
      "required": [
        "relation"
      ],
      "type": "object"
    }
  },
  "description": "Hints for cognitive binding between entities",
  "properties": {
    "binding_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/BindingType.schema.json"
        }
      ],
      "description": "Type of cognitive binding"
    },
    "context": {
      "default": null,
      "description": "Context explaining the binding",
      "type": [
        "string",
        "null"
      ]
    },
    "directionality": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/Directionality.schema.json"
        }
      ],
      "description": "Directionality of binding"
    },
    "source": {
      "allOf": [
        {
          "$ref": "#/definitions/EntityReference"
        }
      ],
      "description": "Source entity"
    },
    "strength": {
      "description": "Strength of binding (0.0 to 1.0)",
      "format": "double",
      "type": "number"
    },
    "target": {
      "allOf": [
        {
          "$ref": "#/definitions/EntityReference"
        }
      ],
      "description": "Target entity"
    },
    "temporal": {
      "anyOf": [
        {
          "$ref": "#/definitions/TemporalBinding"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Temporal aspect of binding"
    }
  },
  "required": [
    "binding_type",
    "directionality",
    "source",
    "strength",
    "target"
  ],
  "title": "BindingHints",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BindingPattern.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Common binding patterns for detection",
  "properties": {
    "binding_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/BindingType.schema.json"
        }
      ],
      "description": "Binding type this pattern indicates"
    },
    "confidence_boost": {
      "description": "Confidence boost when matched",
      "format": "double",
      "type": "number"
    },
    "name": {
      "description": "Pattern name",
      "type": "string"
    },
    "pattern": {
      "description": "Regex or linguistic pattern",
      "type": "string"
    }
  },
  "required": [
    "binding_type",
    "confidence_boost",
    "name",
    "pattern"
  ],
  "title": "BindingPattern",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BindingType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of cognitive binding",
  "oneOf": [
    {
      "description": "Cause leads to effect",
      "enum": [
        "causal"
      ],
      "type": "string"
    },
    {
      "description": "Temporal sequence (before/after)",
      "enum": [
        "temporal"
      ],
      "type": "string"
    },
    {
      "description": "Associated by proximity/context",
      "enum": [
        "associative"
      ],
      "type": "string"
    },
    {
      "description": "Part-whole relationship",
      "enum": [
        "compositional"
      ],
      "type": "string"
    },
    {
      "description": "Contrast/opposition",
      "enum": [
        "contrastive"
      ],
      "type": "string"
    },
    {
      "description": "Similarity/analogy",
      "enum": [
        "analogical"
      ],
      "type": "string"
    },
    {
      "description": "Enables/prerequisite",
      "enum": [
        "enabling"
      ],
      "type": "string"
    },
    {
      "description": "Thematic connection",
      "enum": [
        "thematic"
      ],
      "type": "string"
    }
  ],
  "title": "BindingType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BondChanges.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Changes to bond characteristics",
  "properties": {
    "new_relationship_type": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/RelationshipType.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "strength_delta": {
      "default": null,
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "trust_delta": {
      "default": null,
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "valence_delta": {
      "default": null,
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    }
  },
  "title": "BondChanges",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BondCharacteristics.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "DurationCategory": {
      "description": "Duration categories",
      "enum": [
        "new",
        "recent",
        "established",
        "long_term",
        "lifelong"
      ],
      "type": "string"
    },
    "InteractionFrequency": {
      "description": "Interaction frequency",
      "enum": [
        "daily",
        "weekly",
        "monthly",
        "quarterly",
        "yearly",
        "rarely"
      ],
      "type": "string"
    },
    "RelationshipDuration": {
      "description": "Relationship duration",
      "properties": {
        "category": {
          "allOf": [
            {
              "$ref": "#/definitions/DurationCategory"
            }
          ],
          "description": "Duration category"
        },
        "since": {
          "default": null,
          "description": "Start date if known",
          "type": [
            "string",
            "null"
          ]
        },
        "years": {
          "default": null,
          "description": "How long the relationship has existed",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "required": [
        "category"
      ],
      "type": "object"
    }
  },
  "description": "Bond characteristics",
  "properties": {
    "duration": {
      "anyOf": [
        {
          "$ref": "#/definitions/RelationshipDuration"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Duration of relationship"
    },
    "interaction_frequency": {
      "anyOf": [
        {
          "$ref": "#/definitions/InteractionFrequency"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Frequency of interaction"
    },
    "intimacy": {
      "description": "Intimacy level (0.0 distant to 1.0 close)",
      "format": "double",
      "type": "number"
    },
    "reciprocity": {
      "description": "Reciprocity (0.0 one-sided to 1.0 mutual)",
      "format": "double",
      "type": "number"
    },
    "relationship_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/RelationshipType.schema.json"
        }
      ],
      "description": "Type of relationship"
    },
    "strength": {
      "description": "Strength of relationship (0.0 weak to 1.0 strong)",
      "format": "double",
      "type": "number"
    },
    "trust": {
      "description": "Trust level (0.0 to 1.0)",
      "format": "double",
      "type": "number"
    },
    "valence": {
      "description": "Valence (-1.0 negative to 1.0 positive)",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "intimacy",
    "reciprocity",
    "relationship_type",
    "strength",
    "trust",
    "valence"
  ],
  "title": "BondCharacteristics",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BondEvidence.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BondIndicatorType": {
      "description": "Types of bond indicators",
      "oneOf": [
        {
          "description": "Explicit label (\"my friend\", \"my boss\")",
          "enum": [
            "explicit_label"
          ],
          "type": "string"
        },
        {
          "description": "Action indicating relationship (\"had dinner with\")",
          "enum": [
            "relational_action"
          ],
          "type": "string"
        },
        {
          "description": "Emotional language about entity",
          "enum": [
            "emotional_language"
          ],
          "type": "string"
        },
        {
          "description": "Possessive language (\"my\", \"our\")",
          "enum": [
            "possessive_language"
          ],
          "type": "string"
        },
        {
          "description": "Frequency indicators (\"always see\", \"often talk\")",
          "enum": [
            "frequency_indicator"
          ],
          "type": "string"
        },
        {
          "description": "Context from previous interactions",
          "enum": [
            "contextual_inference"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Evidence for bond detection",
  "properties": {
    "indicator_type": {
      "allOf": [
        {
          "$ref": "#/definitions/BondIndicatorType"
        }
      ],
      "description": "Type of indicator"
    },
    "indicators": {
      "default": [],
      "description": "Specific indicators found",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "trigger_text": {
      "description": "Text that indicates the relationship",
      "type": "string"
    }
  },
  "required": [
    "indicator_type",
    "trigger_text"
  ],
  "title": "BondEvidence",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BondHintInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ExistingBond": {
      "description": "An existing bond for context",
      "properties": {
        "head_thread_id": {
          "type": "string"
        },
        "id": {
          "type": "string"
        },
        "relationship_type": {
          "$ref": "../../codegen/primitives/RelationshipType.schema.json"
        },
        "strength": {
          "format": "double",
          "type": "number"
        },
        "tail_thread_id": {
          "type": "string"
        }
      },
      "required": [
        "head_thread_id",
        "id",
        "relationship_type",
        "strength",
        "tail_thread_id"
      ],
      "type": "object"
    }
  },
  "description": "Input for bond hint generation",
  "properties": {
    "known_bonds": {
      "default": [],
      "description": "Known bonds for context",
      "items": {
        "$ref": "#/definitions/ExistingBond"
      },
      "type": "array"
    },
    "segment": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/Segment.schema.json"
        }
      ],
      "description": "The segment containing relationship information"
    },
    "threads": {
      "description": "Detected threads in the segment",
      "items": {
        "$ref": "../../codegen/primitives/ThreadReference.schema.json"
      },
      "type": "array"
    }
  },
  "required": [
    "segment",
    "threads"
  ],
  "title": "BondHintInput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "input",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BondHintOutput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BondChanges": {
      "description": "Changes to bond characteristics",
      "properties": {
        "new_relationship_type": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/RelationshipType.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "strength_delta": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "trust_delta": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "valence_delta": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "BondCharacteristics": {
      "description": "Bond characteristics",
      "properties": {
        "duration": {
          "anyOf": [
            {
              "$ref": "#/definitions/RelationshipDuration"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Duration of relationship"
        },
        "interaction_frequency": {
          "anyOf": [
            {
              "$ref": "#/definitions/InteractionFrequency"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Frequency of interaction"
        },
        "intimacy": {
          "description": "Intimacy level (0.0 distant to 1.0 close)",
          "format": "double",
          "type": "number"
        },
        "reciprocity": {
          "description": "Reciprocity (0.0 one-sided to 1.0 mutual)",
          "format": "double",
          "type": "number"
        },
        "relationship_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/RelationshipType.schema.json"
            }
          ],
          "description": "Type of relationship"
        },
        "strength": {
          "description": "Strength of relationship (0.0 weak to 1.0 strong)",
          "format": "double",
          "type": "number"
        },
        "trust": {
          "description": "Trust level (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "valence": {
          "description": "Valence (-1.0 negative to 1.0 positive)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "intimacy",
        "reciprocity",
        "relationship_type",
        "strength",
        "trust",
        "valence"
      ],
      "type": "object"
    },
    "BondEvidence": {
      "description": "Evidence for bond detection",
      "properties": {
        "indicator_type": {
          "allOf": [
            {
              "$ref": "#/definitions/BondIndicatorType"
            }
          ],
          "description": "Type of indicator"
        },
        "indicators": {
          "default": [],
          "description": "Specific indicators found",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "trigger_text": {
          "description": "Text that indicates the relationship",
          "type": "string"
        }
      },
      "required": [
        "indicator_type",
        "trigger_text"
      ],
      "type": "object"
    },
    "BondIndicatorType": {
      "description": "Types of bond indicators",
      "oneOf": [
        {
          "description": "Explicit label (\"my friend\", \"my boss\")",
          "enum": [
            "explicit_label"
          ],
          "type": "string"
        },
        {
          "description": "Action indicating relationship (\"had dinner with\")",
          "enum": [
            "relational_action"
          ],
          "type": "string"
        },
        {
          "description": "Emotional language about entity",
          "enum": [
            "emotional_language"
          ],
          "type": "string"
        },
        {
          "description": "Possessive language (\"my\", \"our\")",
          "enum": [
            "possessive_language"
          ],
          "type": "string"
        },
        {
          "description": "Frequency indicators (\"always see\", \"often talk\")",
          "enum": [
            "frequency_indicator"
          ],
          "type": "string"
        },
        {
          "description": "Context from previous interactions",
          "enum": [
            "contextual_inference"
          ],
          "type": "string"
        }
      ]
    },
    "BondUpdate": {
      "description": "Update to an existing bond",
      "properties": {
        "bond_id": {
          "description": "ID of bond to update",
          "type": "string"
        },
        "changes": {
          "allOf": [
            {
              "$ref": "#/definitions/BondChanges"
            }
          ],
          "description": "Changes to apply"
        },
        "reason": {
          "description": "Reason for update",
          "type": "string"
        }
      },
      "required": [
        "bond_id",
        "changes",
        "reason"
      ],
      "type": "object"
    },
    "DetectedBond": {
      "description": "A detected bond between entities",
      "properties": {
        "characteristics": {
          "allOf": [
            {
              "$ref": "#/definitions/BondCharacteristics"
            }
          ],
          "description": "Bond characteristics"
        },
        "confidence": {
          "description": "Confidence in detection",
          "format": "double",
          "type": "number"
        },
        "evidence": {
          "allOf": [
            {
              "$ref": "#/definitions/BondEvidence"
            }
          ],
          "description": "Evidence for this bond"
        },
        "head": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadReference.schema.json"
            }
          ],
          "description": "Source entity (head)"
        },
        "tail": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadReference.schema.json"
            }
          ],
          "description": "Target entity (tail)"
        }
      },
      "required": [
        "characteristics",
        "confidence",
        "evidence",
        "head",
        "tail"
      ],
      "type": "object"
    },
    "DurationCategory": {
      "description": "Duration categories",
      "enum": [
        "new",
        "recent",
        "established",
        "long_term",
        "lifelong"
      ],
      "type": "string"
    },
    "InteractionFrequency": {
      "description": "Interaction frequency",
      "enum": [
        "daily",
        "weekly",
        "monthly",
        "quarterly",
        "yearly",
        "rarely"
      ],
      "type": "string"
    },
    "RelationshipDuration": {
      "description": "Relationship duration",
      "properties": {
        "category": {
          "allOf": [
            {
              "$ref": "#/definitions/DurationCategory"
            }
          ],
          "description": "Duration category"
        },
        "since": {
          "default": null,
          "description": "Start date if known",
          "type": [
            "string",
            "null"
          ]
        },
        "years": {
          "default": null,
          "description": "How long the relationship has existed",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "required": [
        "category"
      ],
      "type": "object"
    }
  },
  "description": "Output from bond hint generation",
  "properties": {
    "bond_updates": {
      "default": [],
      "description": "Updates to existing bonds",
      "items": {
        "$ref": "#/definitions/BondUpdate"
      },
      "type": "array"
    },
    "bonds": {
      "description": "Detected bonds",
      "items": {
        "$ref": "#/definitions/DetectedBond"
      },
      "type": "array"
    }
  },
  "required": [
    "bonds"
  ],
  "title": "BondHintOutput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "output",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BondHints.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Hints for relationship bonds",
  "properties": {
    "description": {
      "default": null,
      "description": "Description of relationship",
      "type": [
        "string",
        "null"
      ]
    },
    "reciprocity": {
      "default": 0.5,
      "description": "Reciprocity (0.0 one-way to 1.0 mutual)",
      "format": "double",
      "type": "number"
    },
    "relationship_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/RelationshipType.schema.json"
        }
      ],
      "description": "Relationship type"
    },
    "source": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/ThreadReference.schema.json"
        }
      ],
      "description": "Source entity (head of relationship)"
    },
    "strength": {
      "description": "Strength of relationship (0.0 to 1.0)",
      "format": "double",
      "type": "number"
    },
    "target": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/ThreadReference.schema.json"
        }
      ],
      "description": "Target entity (tail of relationship)"
    },
    "valence": {
      "description": "Valence of relationship (-1.0 to 1.0)",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "relationship_type",
    "source",
    "strength",
    "target",
    "valence"
  ],
  "title": "BondHints",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BondIndicatorType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of bond indicators",
  "oneOf": [
    {
      "description": "Explicit label (\"my friend\", \"my boss\")",
      "enum": [
        "explicit_label"
      ],
      "type": "string"
    },
    {
      "description": "Action indicating relationship (\"had dinner with\")",
      "enum": [
        "relational_action"
      ],
      "type": "string"
    },
    {
      "description": "Emotional language about entity",
      "enum": [
        "emotional_language"
      ],
      "type": "string"
    },
    {
      "description": "Possessive language (\"my\", \"our\")",
      "enum": [
        "possessive_language"
      ],
      "type": "string"
    },
    {
      "description": "Frequency indicators (\"always see\", \"often talk\")",
      "enum": [
        "frequency_indicator"
      ],
      "type": "string"
    },
    {
      "description": "Context from previous interactions",
      "enum": [
        "contextual_inference"
      ],
      "type": "string"
    }
  ],
  "title": "BondIndicatorType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BondUpdate.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BondChanges": {
      "description": "Changes to bond characteristics",
      "properties": {
        "new_relationship_type": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/RelationshipType.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "strength_delta": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "trust_delta": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "valence_delta": {
          "default": null,
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object"
    }
  },
  "description": "Update to an existing bond",
  "properties": {
    "bond_id": {
      "description": "ID of bond to update",
      "type": "string"
    },
    "changes": {
      "allOf": [
        {
          "$ref": "#/definitions/BondChanges"
        }
      ],
      "description": "Changes to apply"
    },
    "reason": {
      "description": "Reason for update",
      "type": "string"
    }
  },
  "required": [
    "bond_id",
    "changes",
    "reason"
  ],
  "title": "BondUpdate",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/BoundingBox.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Bounding box for object detection",
  "properties": {
    "height": {
      "format": "double",
      "type": "number"
    },
    "width": {
      "format": "double",
      "type": "number"
    },
    "x": {
      "format": "double",
      "type": "number"
    },
    "y": {
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "height",
    "width",
    "x",
    "y"
  ],
  "title": "BoundingBox",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ClassificationEvidence.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "EvidenceType": {
      "description": "Types of evidence for classification",
      "oneOf": [
        {
          "description": "Verb type (action vs state)",
          "enum": [
            "verb_type"
          ],
          "type": "string"
        },
        {
          "description": "Keywords detected",
          "enum": [
            "keywords"
          ],
          "type": "string"
        },
        {
          "description": "Temporal indicators",
          "enum": [
            "temporal"
          ],
          "type": "string"
        },
        {
          "description": "Emotional indicators",
          "enum": [
            "emotional"
          ],
          "type": "string"
        },
        {
          "description": "Entity mentions",
          "enum": [
            "entity_mention"
          ],
          "type": "string"
        },
        {
          "description": "Relational language",
          "enum": [
            "relational"
          ],
          "type": "string"
        },
        {
          "description": "Pattern indicators",
          "enum": [
            "pattern"
          ],
          "type": "string"
        },
        {
          "description": "Context from surrounding content",
          "enum": [
            "context"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Evidence for a classification",
  "properties": {
    "description": {
      "description": "Description of evidence",
      "type": "string"
    },
    "evidence_type": {
      "allOf": [
        {
          "$ref": "#/definitions/EvidenceType"
        }
      ],
      "description": "Type of evidence"
    },
    "weight": {
      "description": "How much this evidence contributes",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "description",
    "evidence_type",
    "weight"
  ],
  "title": "ClassificationEvidence",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ClassificationReasoning.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Reasoning behind classification",
  "properties": {
    "explanations": {
      "default": [],
      "description": "Why certain types were included/excluded",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "key_phrases": {
      "default": [],
      "description": "Key phrases that influenced classification",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "main_verb": {
      "default": null,
      "description": "Main verb identified",
      "type": [
        "string",
        "null"
      ]
    },
    "verb_category": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/VerbCategory.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Verb category"
    }
  },
  "title": "ClassificationReasoning",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ClassifiedPurpose.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A classified purpose with confidence",
  "properties": {
    "confidence": {
      "description": "Confidence score (0.0 to 1.0)",
      "format": "double",
      "type": "number"
    },
    "evidence": {
      "default": [],
      "description": "Evidence/reasoning for classification",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "purpose": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/ToolPurpose.schema.json"
        }
      ],
      "description": "The purpose of the message"
    }
  },
  "required": [
    "confidence",
    "purpose"
  ],
  "title": "ClassifiedPurpose",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/CommandAnalysis.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "CommandType": {
      "description": "Types of commands",
      "oneOf": [
        {
          "description": "Create something",
          "enum": [
            "CREATE"
          ],
          "type": "string"
        },
        {
          "description": "Update/modify",
          "enum": [
            "UPDATE"
          ],
          "type": "string"
        },
        {
          "description": "Delete/remove",
          "enum": [
            "DELETE"
          ],
          "type": "string"
        },
        {
          "description": "Link/connect entities",
          "enum": [
            "LINK"
          ],
          "type": "string"
        },
        {
          "description": "Unlink/disconnect entities",
          "enum": [
            "UNLINK"
          ],
          "type": "string"
        },
        {
          "description": "Export data",
          "enum": [
            "EXPORT"
          ],
          "type": "string"
        },
        {
          "description": "Import data",
          "enum": [
            "IMPORT"
          ],
          "type": "string"
        },
        {
          "description": "Configure settings",
          "enum": [
            "CONFIGURE"
          ],
          "type": "string"
        },
        {
          "description": "Unknown/custom command",
          "enum": [
            "CUSTOM"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Analysis of a command purpose",
  "properties": {
    "command_type": {
      "allOf": [
        {
          "$ref": "#/definitions/CommandType"
        }
      ],
      "description": "Command type"
    },
    "is_destructive": {
      "description": "Is this command destructive?",
      "type": "boolean"
    },
    "needs_confirmation": {
      "description": "Does this command need confirmation?",
      "type": "boolean"
    },
    "parameters": {
      "additionalProperties": true,
      "default": {},
      "description": "Command parameters",
      "type": "object"
    },
    "target": {
      "default": null,
      "description": "Target of the command",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "command_type",
    "is_destructive",
    "needs_confirmation"
  ],
  "title": "CommandAnalysis",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/CommandType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of commands",
  "oneOf": [
    {
      "description": "Create something",
      "enum": [
        "CREATE"
      ],
      "type": "string"
    },
    {
      "description": "Update/modify",
      "enum": [
        "UPDATE"
      ],
      "type": "string"
    },
    {
      "description": "Delete/remove",
      "enum": [
        "DELETE"
      ],
      "type": "string"
    },
    {
      "description": "Link/connect entities",
      "enum": [
        "LINK"
      ],
      "type": "string"
    },
    {
      "description": "Unlink/disconnect entities",
      "enum": [
        "UNLINK"
      ],
      "type": "string"
    },
    {
      "description": "Export data",
      "enum": [
        "EXPORT"
      ],
      "type": "string"
    },
    {
      "description": "Import data",
      "enum": [
        "IMPORT"
      ],
      "type": "string"
    },
    {
      "description": "Configure settings",
      "enum": [
        "CONFIGURE"
      ],
      "type": "string"
    },
    {
      "description": "Unknown/custom command",
      "enum": [
        "CUSTOM"
      ],
      "type": "string"
    }
  ],
  "title": "CommandType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ConditionOperator.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Condition operators",
  "enum": [
    "equals",
    "not_equals",
    "greater_than",
    "less_than",
    "contains",
    "not_contains",
    "is_null",
    "is_not_null",
    "in"
  ],
  "title": "ConditionOperator",
  "type": "string",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ConditionType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of conditions",
  "oneOf": [
    {
      "description": "Check output value",
      "enum": [
        "output_value"
      ],
      "type": "string"
    },
    {
      "description": "Check if step succeeded",
      "enum": [
        "step_success"
      ],
      "type": "string"
    },
    {
      "description": "Check if step failed",
      "enum": [
        "step_failed"
      ],
      "type": "string"
    },
    {
      "description": "Check output exists",
      "enum": [
        "output_exists"
      ],
      "type": "string"
    }
  ],
  "title": "ConditionType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ContextStrategy.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "How context flows between tools",
  "oneOf": [
    {
      "description": "Pass full context to every tool",
      "enum": [
        "full_context"
      ],
      "type": "string"
    },
    {
      "description": "Only pass relevant context (filtered)",
      "enum": [
        "filtered_context"
      ],
      "type": "string"
    },
    {
      "description": "Accumulate results as context grows",
      "enum": [
        "accumulating_context"
      ],
      "type": "string"
    },
    {
      "description": "Each step gets fresh context",
      "enum": [
        "isolated_context"
      ],
      "type": "string"
    }
  ],
  "title": "ContextStrategy",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ContextWindow.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Context window for binding analysis",
  "properties": {
    "following": {
      "default": [],
      "description": "Following content",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "preceding": {
      "default": [],
      "description": "Preceding content",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "time_span_hours": {
      "default": null,
      "description": "Time span in hours",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    }
  },
  "title": "ContextWindow",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/DetectedAction.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A detected action in vision",
  "properties": {
    "action": {
      "type": "string"
    },
    "actor": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "confidence": {
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "action",
    "confidence"
  ],
  "title": "DetectedAction",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/DetectedBinding.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BindingCharacteristics": {
      "description": "Binding characteristics",
      "properties": {
        "binding_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/BindingType.schema.json"
            }
          ],
          "description": "Type of cognitive binding"
        },
        "directionality": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/Directionality.schema.json"
            }
          ],
          "description": "Directionality"
        },
        "salience": {
          "description": "Salience (how notable/memorable)",
          "format": "double",
          "type": "number"
        },
        "semantic": {
          "anyOf": [
            {
              "$ref": "#/definitions/SemanticProperties"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Semantic properties"
        },
        "strength": {
          "description": "Strength of binding (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "temporal": {
          "anyOf": [
            {
              "$ref": "#/definitions/TemporalProperties"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Temporal properties"
        }
      },
      "required": [
        "binding_type",
        "directionality",
        "salience",
        "strength"
      ],
      "type": "object"
    },
    "BindingEvidence": {
      "description": "Evidence for a detected binding",
      "properties": {
        "evidence_type": {
          "allOf": [
            {
              "$ref": "#/definitions/BindingEvidenceType"
            }
          ],
          "description": "Type of evidence"
        },
        "explanation": {
          "description": "Explanation",
          "type": "string"
        },
        "markers": {
          "default": [],
          "description": "Specific markers found",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "trigger_text": {
          "description": "Text that triggered detection",
          "type": "string"
        }
      },
      "required": [
        "evidence_type",
        "explanation",
        "trigger_text"
      ],
      "type": "object"
    },
    "BindingEvidenceType": {
      "description": "Types of binding evidence",
      "oneOf": [
        {
          "description": "Explicit linguistic marker",
          "enum": [
            "linguistic_marker"
          ],
          "type": "string"
        },
        {
          "description": "Temporal proximity",
          "enum": [
            "temporal_proximity"
          ],
          "type": "string"
        },
        {
          "description": "Semantic similarity",
          "enum": [
            "semantic_similarity"
          ],
          "type": "string"
        },
        {
          "description": "Entity co-reference",
          "enum": [
            "co_reference"
          ],
          "type": "string"
        },
        {
          "description": "Emotional similarity",
          "enum": [
            "emotional_similarity"
          ],
          "type": "string"
        },
        {
          "description": "Narrative continuity",
          "enum": [
            "narrative_continuity"
          ],
          "type": "string"
        },
        {
          "description": "User explicit statement",
          "enum": [
            "explicit_statement"
          ],
          "type": "string"
        },
        {
          "description": "Inferred from context",
          "enum": [
            "contextual_inference"
          ],
          "type": "string"
        }
      ]
    },
    "EntityRef": {
      "description": "Reference to an entity for binding",
      "properties": {
        "content": {
          "description": "Content/description",
          "type": "string"
        },
        "entity_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/EntityType.schema.json"
            }
          ],
          "description": "Entity type"
        },
        "id": {
          "default": null,
          "description": "Entity ID (if existing)",
          "type": [
            "string",
            "null"
          ]
        },
        "timestamp": {
          "default": null,
          "description": "When created (for temporal binding)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "content",
        "entity_type"
      ],
      "type": "object"
    },
    "SemanticProperties": {
      "description": "Semantic properties of binding",
      "properties": {
        "relationship_description": {
          "default": null,
          "description": "Relationship description",
          "type": [
            "string",
            "null"
          ]
        },
        "shared_concepts": {
          "default": [],
          "description": "Shared concepts/topics",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "similarity": {
          "description": "Semantic similarity score",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "similarity"
      ],
      "type": "object"
    },
    "TemporalProperties": {
      "description": "Temporal properties of binding",
      "properties": {
        "gap": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/TimeGap.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Time gap between entities"
        },
        "recurring": {
          "default": false,
          "description": "Is this a recurring pattern?",
          "type": "boolean"
        },
        "relation": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/TemporalRelation.schema.json"
            }
          ],
          "description": "Time relation"
        }
      },
      "required": [
        "relation"
      ],
      "type": "object"
    }
  },
  "description": "A detected binding between entities",
  "properties": {
    "binding": {
      "allOf": [
        {
          "$ref": "#/definitions/BindingCharacteristics"
        }
      ],
      "description": "Binding characteristics"
    },
    "confidence": {
      "description": "Confidence in detection",
      "format": "double",
      "type": "number"
    },
    "evidence": {
      "allOf": [
        {
          "$ref": "#/definitions/BindingEvidence"
        }
      ],
      "description": "Evidence for the binding"
    },
    "source": {
      "allOf": [
        {
          "$ref": "#/definitions/EntityRef"
        }
      ],
      "description": "Source entity"
    },
    "target": {
      "allOf": [
        {
          "$ref": "#/definitions/EntityRef"
        }
      ],
      "description": "Target entity"
    }
  },
  "required": [
    "binding",
    "confidence",
    "evidence",
    "source",
    "target"
  ],
  "title": "DetectedBinding",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/DetectedBond.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BondCharacteristics": {
      "description": "Bond characteristics",
      "properties": {
        "duration": {
          "anyOf": [
            {
              "$ref": "#/definitions/RelationshipDuration"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Duration of relationship"
        },
        "interaction_frequency": {
          "anyOf": [
            {
              "$ref": "#/definitions/InteractionFrequency"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Frequency of interaction"
        },
        "intimacy": {
          "description": "Intimacy level (0.0 distant to 1.0 close)",
          "format": "double",
          "type": "number"
        },
        "reciprocity": {
          "description": "Reciprocity (0.0 one-sided to 1.0 mutual)",
          "format": "double",
          "type": "number"
        },
        "relationship_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/RelationshipType.schema.json"
            }
          ],
          "description": "Type of relationship"
        },
        "strength": {
          "description": "Strength of relationship (0.0 weak to 1.0 strong)",
          "format": "double",
          "type": "number"
        },
        "trust": {
          "description": "Trust level (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "valence": {
          "description": "Valence (-1.0 negative to 1.0 positive)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "intimacy",
        "reciprocity",
        "relationship_type",
        "strength",
        "trust",
        "valence"
      ],
      "type": "object"
    },
    "BondEvidence": {
      "description": "Evidence for bond detection",
      "properties": {
        "indicator_type": {
          "allOf": [
            {
              "$ref": "#/definitions/BondIndicatorType"
            }
          ],
          "description": "Type of indicator"
        },
        "indicators": {
          "default": [],
          "description": "Specific indicators found",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "trigger_text": {
          "description": "Text that indicates the relationship",
          "type": "string"
        }
      },
      "required": [
        "indicator_type",
        "trigger_text"
      ],
      "type": "object"
    },
    "BondIndicatorType": {
      "description": "Types of bond indicators",
      "oneOf": [
        {
          "description": "Explicit label (\"my friend\", \"my boss\")",
          "enum": [
            "explicit_label"
          ],
          "type": "string"
        },
        {
          "description": "Action indicating relationship (\"had dinner with\")",
          "enum": [
            "relational_action"
          ],
          "type": "string"
        },
        {
          "description": "Emotional language about entity",
          "enum": [
            "emotional_language"
          ],
          "type": "string"
        },
        {
          "description": "Possessive language (\"my\", \"our\")",
          "enum": [
            "possessive_language"
          ],
          "type": "string"
        },
        {
          "description": "Frequency indicators (\"always see\", \"often talk\")",
          "enum": [
            "frequency_indicator"
          ],
          "type": "string"
        },
        {
          "description": "Context from previous interactions",
          "enum": [
            "contextual_inference"
          ],
          "type": "string"
        }
      ]
    },
    "DurationCategory": {
      "description": "Duration categories",
      "enum": [
        "new",
        "recent",
        "established",
        "long_term",
        "lifelong"
      ],
      "type": "string"
    },
    "InteractionFrequency": {
      "description": "Interaction frequency",
      "enum": [
        "daily",
        "weekly",
        "monthly",
        "quarterly",
        "yearly",
        "rarely"
      ],
      "type": "string"
    },
    "RelationshipDuration": {
      "description": "Relationship duration",
      "properties": {
        "category": {
          "allOf": [
            {
              "$ref": "#/definitions/DurationCategory"
            }
          ],
          "description": "Duration category"
        },
        "since": {
          "default": null,
          "description": "Start date if known",
          "type": [
            "string",
            "null"
          ]
        },
        "years": {
          "default": null,
          "description": "How long the relationship has existed",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "required": [
        "category"
      ],
      "type": "object"
    }
  },
  "description": "A detected bond between entities",
  "properties": {
    "characteristics": {
      "allOf": [
        {
          "$ref": "#/definitions/BondCharacteristics"
        }
      ],
      "description": "Bond characteristics"
    },
    "confidence": {
      "description": "Confidence in detection",
      "format": "double",
      "type": "number"
    },
    "evidence": {
      "allOf": [
        {
          "$ref": "#/definitions/BondEvidence"
        }
      ],
      "description": "Evidence for this bond"
    },
    "head": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/ThreadReference.schema.json"
        }
      ],
      "description": "Source entity (head)"
    },
    "tail": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/ThreadReference.schema.json"
        }
      ],
      "description": "Target entity (tail)"
    }
  },
  "required": [
    "characteristics",
    "confidence",
    "evidence",
    "head",
    "tail"
  ],
  "title": "DetectedBond",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/DetectedEmotion.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A detected emotion in the content",
  "properties": {
    "emotion": {
      "description": "Emotion name",
      "type": "string"
    },
    "evidence": {
      "description": "Evidence for detection",
      "type": "string"
    },
    "intensity": {
      "description": "Intensity (0.0 to 1.0)",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "emotion",
    "evidence",
    "intensity"
  ],
  "title": "DetectedEmotion",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/DetectedObject.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BoundingBox": {
      "description": "Bounding box for object detection",
      "properties": {
        "height": {
          "format": "double",
          "type": "number"
        },
        "width": {
          "format": "double",
          "type": "number"
        },
        "x": {
          "format": "double",
          "type": "number"
        },
        "y": {
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "height",
        "width",
        "x",
        "y"
      ],
      "type": "object"
    }
  },
  "description": "A detected object in vision",
  "properties": {
    "bounding_box": {
      "anyOf": [
        {
          "$ref": "#/definitions/BoundingBox"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "confidence": {
      "format": "double",
      "type": "number"
    },
    "label": {
      "type": "string"
    }
  },
  "required": [
    "confidence",
    "label"
  ],
  "title": "DetectedObject",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/DetectedPerson.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BoundingBox": {
      "description": "Bounding box for object detection",
      "properties": {
        "height": {
          "format": "double",
          "type": "number"
        },
        "width": {
          "format": "double",
          "type": "number"
        },
        "x": {
          "format": "double",
          "type": "number"
        },
        "y": {
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "height",
        "width",
        "x",
        "y"
      ],
      "type": "object"
    }
  },
  "description": "A detected person in vision",
  "properties": {
    "bounding_box": {
      "anyOf": [
        {
          "$ref": "#/definitions/BoundingBox"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "emotion": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "face_id": {
      "default": null,
      "type": [
        "string",
        "null"
      ]
    }
  },
  "title": "DetectedPerson",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/DetectedThread.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "DetectionMethod": {
      "description": "How a thread was detected",
      "oneOf": [
        {
          "description": "Exact name match",
          "enum": [
            "exact_match"
          ],
          "type": "string"
        },
        {
          "description": "Alias match",
          "enum": [
            "alias_match"
          ],
          "type": "string"
        },
        {
          "description": "Fuzzy/similar match",
          "enum": [
            "fuzzy_match"
          ],
          "type": "string"
        },
        {
          "description": "Pronoun resolution from context",
          "enum": [
            "pronoun_resolution"
          ],
          "type": "string"
        },
        {
          "description": "Keyword match",
          "enum": [
            "keyword_match"
          ],
          "type": "string"
        },
        {
          "description": "Semantic similarity",
          "enum": [
            "semantic_match"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "A detected thread reference",
  "properties": {
    "confidence": {
      "description": "Confidence in match",
      "format": "double",
      "type": "number"
    },
    "detection_method": {
      "allOf": [
        {
          "$ref": "#/definitions/DetectionMethod"
        }
      ],
      "description": "How it was detected"
    },
    "role": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/ThreadRole.schema.json"
        }
      ],
      "description": "Role in this entity"
    },
    "thread": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/ThreadReference.schema.json"
        }
      ],
      "description": "The matched thread"
    },
    "trigger_text": {
      "description": "Text that triggered detection",
      "type": "string"
    }
  },
  "required": [
    "confidence",
    "detection_method",
    "role",
    "thread",
    "trigger_text"
  ],
  "title": "DetectedThread",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/DetectionMethod.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "How a thread was detected",
  "oneOf": [
    {
      "description": "Exact name match",
      "enum": [
        "exact_match"
      ],
      "type": "string"
    },
    {
      "description": "Alias match",
      "enum": [
        "alias_match"
      ],
      "type": "string"
    },
    {
      "description": "Fuzzy/similar match",
      "enum": [
        "fuzzy_match"
      ],
      "type": "string"
    },
    {
      "description": "Pronoun resolution from context",
      "enum": [
        "pronoun_resolution"
      ],
      "type": "string"
    },
    {
      "description": "Keyword match",
      "enum": [
        "keyword_match"
      ],
      "type": "string"
    },
    {
      "description": "Semantic similarity",
      "enum": [
        "semantic_match"
      ],
      "type": "string"
    }
  ],
  "title": "DetectionMethod",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/Directionality.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Directionality of binding",
  "oneOf": [
    {
      "description": "Only source  target",
      "enum": [
        "unidirectional"
      ],
      "type": "string"
    },
    {
      "description": "Both directions",
      "enum": [
        "bidirectional"
      ],
      "type": "string"
    },
    {
      "description": "No inherent direction",
      "enum": [
        "undirected"
      ],
      "type": "string"
    }
  ],
  "title": "Directionality",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/DurationCategory.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Duration categories",
  "enum": [
    "new",
    "recent",
    "established",
    "long_term",
    "lifelong"
  ],
  "title": "DurationCategory",
  "type": "string",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/EmotionalTone.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Emotional tone detected in segment",
  "properties": {
    "arousal": {
      "description": "Arousal (0.0 calm to 1.0 excited)",
      "format": "double",
      "type": "number"
    },
    "confidence": {
      "description": "Confidence in detection",
      "format": "double",
      "type": "number"
    },
    "primary": {
      "description": "Primary emotion",
      "type": "string"
    },
    "valence": {
      "description": "Valence (-1.0 negative to 1.0 positive)",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "arousal",
    "confidence",
    "primary",
    "valence"
  ],
  "title": "EmotionalTone",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/EntityClassification.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ClassificationEvidence": {
      "description": "Evidence for a classification",
      "properties": {
        "description": {
          "description": "Description of evidence",
          "type": "string"
        },
        "evidence_type": {
          "allOf": [
            {
              "$ref": "#/definitions/EvidenceType"
            }
          ],
          "description": "Type of evidence"
        },
        "weight": {
          "description": "How much this evidence contributes",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "description",
        "evidence_type",
        "weight"
      ],
      "type": "object"
    },
    "EvidenceType": {
      "description": "Types of evidence for classification",
      "oneOf": [
        {
          "description": "Verb type (action vs state)",
          "enum": [
            "verb_type"
          ],
          "type": "string"
        },
        {
          "description": "Keywords detected",
          "enum": [
            "keywords"
          ],
          "type": "string"
        },
        {
          "description": "Temporal indicators",
          "enum": [
            "temporal"
          ],
          "type": "string"
        },
        {
          "description": "Emotional indicators",
          "enum": [
            "emotional"
          ],
          "type": "string"
        },
        {
          "description": "Entity mentions",
          "enum": [
            "entity_mention"
          ],
          "type": "string"
        },
        {
          "description": "Relational language",
          "enum": [
            "relational"
          ],
          "type": "string"
        },
        {
          "description": "Pattern indicators",
          "enum": [
            "pattern"
          ],
          "type": "string"
        },
        {
          "description": "Context from surrounding content",
          "enum": [
            "context"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "A single entity classification with probability",
  "properties": {
    "entity_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/EntityType.schema.json"
        }
      ],
      "description": "Entity type"
    },
    "evidence": {
      "default": [],
      "description": "Evidence supporting this classification",
      "items": {
        "$ref": "#/definitions/ClassificationEvidence"
      },
      "type": "array"
    },
    "probability": {
      "description": "Probability (0.0 to 1.0)",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "entity_type",
    "probability"
  ],
  "title": "EntityClassification",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/EntityClassificationContext.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "EntityPatterns": {
      "description": "User's historical entity patterns",
      "properties": {
        "distribution": {
          "additionalProperties": {
            "format": "double",
            "type": "number"
          },
          "default": {},
          "description": "Distribution (entity_type -> frequency)",
          "type": "object"
        },
        "primary_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/EntityType.schema.json"
            }
          ],
          "description": "Most common entity type"
        }
      },
      "required": [
        "primary_type"
      ],
      "type": "object"
    }
  },
  "description": "Context for entity classification",
  "properties": {
    "following": {
      "default": null,
      "description": "Following segment content (for context)",
      "type": [
        "string",
        "null"
      ]
    },
    "known_threads": {
      "default": [],
      "description": "Known threads for reference",
      "items": {
        "$ref": "../../codegen/primitives/ThreadReference.schema.json"
      },
      "type": "array"
    },
    "preceding": {
      "default": null,
      "description": "Preceding segment content (for context)",
      "type": [
        "string",
        "null"
      ]
    },
    "user_patterns": {
      "anyOf": [
        {
          "$ref": "#/definitions/EntityPatterns"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "User's entity type distribution"
    }
  },
  "title": "EntityClassificationContext",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/EntityClassifierInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ClassifiedPurpose": {
      "description": "A classified purpose with confidence",
      "properties": {
        "confidence": {
          "description": "Confidence score (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "evidence": {
          "default": [],
          "description": "Evidence/reasoning for classification",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "purpose": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ToolPurpose.schema.json"
            }
          ],
          "description": "The purpose of the message"
        }
      },
      "required": [
        "confidence",
        "purpose"
      ],
      "type": "object"
    },
    "EntityClassificationContext": {
      "description": "Context for entity classification",
      "properties": {
        "following": {
          "default": null,
          "description": "Following segment content (for context)",
          "type": [
            "string",
            "null"
          ]
        },
        "known_threads": {
          "default": [],
          "description": "Known threads for reference",
          "items": {
            "$ref": "../../codegen/primitives/ThreadReference.schema.json"
          },
          "type": "array"
        },
        "preceding": {
          "default": null,
          "description": "Preceding segment content (for context)",
          "type": [
            "string",
            "null"
          ]
        },
        "user_patterns": {
          "anyOf": [
            {
              "$ref": "#/definitions/EntityPatterns"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's entity type distribution"
        }
      },
      "type": "object"
    },
    "EntityPatterns": {
      "description": "User's historical entity patterns",
      "properties": {
        "distribution": {
          "additionalProperties": {
            "format": "double",
            "type": "number"
          },
          "default": {},
          "description": "Distribution (entity_type -> frequency)",
          "type": "object"
        },
        "primary_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/EntityType.schema.json"
            }
          ],
          "description": "Most common entity type"
        }
      },
      "required": [
        "primary_type"
      ],
      "type": "object"
    }
  },
  "description": "Input for entity classification",
  "properties": {
    "context": {
      "anyOf": [
        {
          "$ref": "#/definitions/EntityClassificationContext"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Context for classification"
    },
    "purpose": {
      "allOf": [
        {
          "$ref": "#/definitions/ClassifiedPurpose"
        }
      ],
      "description": "Purpose classification result"
    },
    "segment": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/Segment.schema.json"
        }
      ],
      "description": "The segment to classify"
    }
  },
  "required": [
    "purpose",
    "segment"
  ],
  "title": "EntityClassifierInput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "input",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/EntityClassifierOutput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ClassificationEvidence": {
      "description": "Evidence for a classification",
      "properties": {
        "description": {
          "description": "Description of evidence",
          "type": "string"
        },
        "evidence_type": {
          "allOf": [
            {
              "$ref": "#/definitions/EvidenceType"
            }
          ],
          "description": "Type of evidence"
        },
        "weight": {
          "description": "How much this evidence contributes",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "description",
        "evidence_type",
        "weight"
      ],
      "type": "object"
    },
    "ClassificationReasoning": {
      "description": "Reasoning behind classification",
      "properties": {
        "explanations": {
          "default": [],
          "description": "Why certain types were included/excluded",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "key_phrases": {
          "default": [],
          "description": "Key phrases that influenced classification",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "main_verb": {
          "default": null,
          "description": "Main verb identified",
          "type": [
            "string",
            "null"
          ]
        },
        "verb_category": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/VerbCategory.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Verb category"
        }
      },
      "type": "object"
    },
    "EntityClassification": {
      "description": "A single entity classification with probability",
      "properties": {
        "entity_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/EntityType.schema.json"
            }
          ],
          "description": "Entity type"
        },
        "evidence": {
          "default": [],
          "description": "Evidence supporting this classification",
          "items": {
            "$ref": "#/definitions/ClassificationEvidence"
          },
          "type": "array"
        },
        "probability": {
          "description": "Probability (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "entity_type",
        "probability"
      ],
      "type": "object"
    },
    "EvidenceType": {
      "description": "Types of evidence for classification",
      "oneOf": [
        {
          "description": "Verb type (action vs state)",
          "enum": [
            "verb_type"
          ],
          "type": "string"
        },
        {
          "description": "Keywords detected",
          "enum": [
            "keywords"
          ],
          "type": "string"
        },
        {
          "description": "Temporal indicators",
          "enum": [
            "temporal"
          ],
          "type": "string"
        },
        {
          "description": "Emotional indicators",
          "enum": [
            "emotional"
          ],
          "type": "string"
        },
        {
          "description": "Entity mentions",
          "enum": [
            "entity_mention"
          ],
          "type": "string"
        },
        {
          "description": "Relational language",
          "enum": [
            "relational"
          ],
          "type": "string"
        },
        {
          "description": "Pattern indicators",
          "enum": [
            "pattern"
          ],
          "type": "string"
        },
        {
          "description": "Context from surrounding content",
          "enum": [
            "context"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Output from entity classification",
  "properties": {
    "classifications": {
      "description": "All classifications with probabilities (sorted by probability)",
      "items": {
        "$ref": "#/definitions/EntityClassification"
      },
      "type": "array"
    },
    "enriched_content": {
      "default": null,
      "description": "Enriched content (e.g., Pulse with context added)",
      "type": [
        "string",
        "null"
      ]
    },
    "primary_thread": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/ThreadReference.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Primary thread reference (main subject/actor)"
    },
    "reasoning": {
      "allOf": [
        {
          "$ref": "#/definitions/ClassificationReasoning"
        }
      ],
      "description": "Classification reasoning"
    },
    "secondary_threads": {
      "default": [],
      "description": "Secondary thread references",
      "items": {
        "$ref": "../../codegen/primitives/ThreadReference.schema.json"
      },
      "type": "array"
    },
    "temporal_marker": {
      "default": null,
      "description": "Temporal marker extracted",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "classifications",
    "reasoning"
  ],
  "title": "EntityClassifierOutput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "output",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/EntityContent.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Content for the spawned entity",
  "properties": {
    "enriched_text": {
      "default": null,
      "description": "Enriched/contextualized content",
      "type": [
        "string",
        "null"
      ]
    },
    "tags": {
      "default": [],
      "description": "Tags extracted",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "text": {
      "description": "Primary content text",
      "type": "string"
    },
    "title": {
      "default": null,
      "description": "Title/summary",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "text"
  ],
  "title": "EntityContent",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/EntityMention.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "An entity mention within a segment",
  "properties": {
    "confidence": {
      "description": "Confidence in detection",
      "format": "double",
      "type": "number"
    },
    "end": {
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "entity_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/EntityMentionType.schema.json"
        }
      ],
      "description": "Type of entity mentioned"
    },
    "resolved_id": {
      "default": null,
      "description": "Resolved entity ID (if matched to known entity)",
      "type": [
        "string",
        "null"
      ]
    },
    "start": {
      "description": "Position in segment",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "text": {
      "description": "The text of the mention",
      "type": "string"
    }
  },
  "required": [
    "confidence",
    "end",
    "entity_type",
    "start",
    "text"
  ],
  "title": "EntityMention",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/EntityMentionType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of entity mentions",
  "enum": [
    "PERSON",
    "PLACE",
    "ORGANIZATION",
    "DATE_TIME",
    "EVENT",
    "CONCEPT",
    "OBJECT",
    "ACTIVITY"
  ],
  "title": "EntityMentionType",
  "type": "string",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/EntityPatterns.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "User's historical entity patterns",
  "properties": {
    "distribution": {
      "additionalProperties": {
        "format": "double",
        "type": "number"
      },
      "default": {},
      "description": "Distribution (entity_type -> frequency)",
      "type": "object"
    },
    "primary_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/EntityType.schema.json"
        }
      ],
      "description": "Most common entity type"
    }
  },
  "required": [
    "primary_type"
  ],
  "title": "EntityPatterns",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/EntityRef.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Reference to an entity for binding",
  "properties": {
    "content": {
      "description": "Content/description",
      "type": "string"
    },
    "entity_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/EntityType.schema.json"
        }
      ],
      "description": "Entity type"
    },
    "id": {
      "default": null,
      "description": "Entity ID (if existing)",
      "type": [
        "string",
        "null"
      ]
    },
    "timestamp": {
      "default": null,
      "description": "When created (for temporal binding)",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "content",
    "entity_type"
  ],
  "title": "EntityRef",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/EntityReference.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Reference to an entity for binding",
  "properties": {
    "description": {
      "description": "Description for matching",
      "type": "string"
    },
    "entity_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/EntityType.schema.json"
        }
      ],
      "description": "Entity type"
    },
    "id": {
      "default": null,
      "description": "Entity ID (if existing)",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "description",
    "entity_type"
  ],
  "title": "EntityReference",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/EntityType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Entity types from the Symmetric Seven ontology",
  "oneOf": [
    {
      "description": "A specific event/action that happened (Narrative/External Particle) Linguistic marker: Action verbs (went, did, met, called)",
      "enum": [
        "MOMENT"
      ],
      "type": "string"
    },
    {
      "description": "Internal state/feeling/emotion (Internal Particle) Linguistic marker: State verbs + evaluative language (felt, was nice)",
      "enum": [
        "PULSE"
      ],
      "type": "string"
    },
    {
      "description": "Definition of person, place, or concept (Definitional/Object)",
      "enum": [
        "THREAD"
      ],
      "type": "string"
    },
    {
      "description": "Relationship between entities (Relational/Connection)",
      "enum": [
        "BOND"
      ],
      "type": "string"
    },
    {
      "description": "A recurring external pattern (External Wave)",
      "enum": [
        "MOTIF"
      ],
      "type": "string"
    },
    {
      "description": "A recurring internal pattern (Internal Wave)",
      "enum": [
        "FILAMENT"
      ],
      "type": "string"
    },
    {
      "description": "An active thematic goal (Intentional Wave)",
      "enum": [
        "FOCUS"
      ],
      "type": "string"
    },
    {
      "description": "A task or goal for the future (Operational/Intentional Particle)",
      "enum": [
        "INTENT"
      ],
      "type": "string"
    }
  ],
  "title": "EntityType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ErrorStrategy.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Error handling strategy",
  "oneOf": [
    {
      "description": "Fail the entire chain on any error",
      "enum": [
        "fail_fast"
      ],
      "type": "string"
    },
    {
      "description": "Continue with remaining steps",
      "enum": [
        "continue_on_error"
      ],
      "type": "string"
    },
    {
      "description": "Retry failed steps",
      "enum": [
        "retry_on_error"
      ],
      "type": "string"
    },
    {
      "description": "Use fallback tool",
      "enum": [
        "use_fallback"
      ],
      "type": "string"
    }
  ],
  "title": "ErrorStrategy",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/EvidenceType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of evidence for classification",
  "oneOf": [
    {
      "description": "Verb type (action vs state)",
      "enum": [
        "verb_type"
      ],
      "type": "string"
    },
    {
      "description": "Keywords detected",
      "enum": [
        "keywords"
      ],
      "type": "string"
    },
    {
      "description": "Temporal indicators",
      "enum": [
        "temporal"
      ],
      "type": "string"
    },
    {
      "description": "Emotional indicators",
      "enum": [
        "emotional"
      ],
      "type": "string"
    },
    {
      "description": "Entity mentions",
      "enum": [
        "entity_mention"
      ],
      "type": "string"
    },
    {
      "description": "Relational language",
      "enum": [
        "relational"
      ],
      "type": "string"
    },
    {
      "description": "Pattern indicators",
      "enum": [
        "pattern"
      ],
      "type": "string"
    },
    {
      "description": "Context from surrounding content",
      "enum": [
        "context"
      ],
      "type": "string"
    }
  ],
  "title": "EvidenceType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ExecutionOrder.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Execution order types",
  "oneOf": [
    {
      "description": "Execute in sequence",
      "enum": [
        "sequential"
      ],
      "type": "string"
    },
    {
      "description": "Execute in parallel with other parallel steps",
      "enum": [
        "parallel"
      ],
      "type": "string"
    },
    {
      "description": "Execute only if condition is met",
      "enum": [
        "conditional"
      ],
      "type": "string"
    },
    {
      "description": "Execute as fallback if previous failed",
      "enum": [
        "fallback"
      ],
      "type": "string"
    }
  ],
  "title": "ExecutionOrder",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ExistingBond.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "An existing bond for context",
  "properties": {
    "head_thread_id": {
      "type": "string"
    },
    "id": {
      "type": "string"
    },
    "relationship_type": {
      "$ref": "../../codegen/primitives/RelationshipType.schema.json"
    },
    "strength": {
      "format": "double",
      "type": "number"
    },
    "tail_thread_id": {
      "type": "string"
    }
  },
  "required": [
    "head_thread_id",
    "id",
    "relationship_type",
    "strength",
    "tail_thread_id"
  ],
  "title": "ExistingBond",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/FilterOperator.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Filter operators",
  "enum": [
    "equals",
    "not_equals",
    "contains",
    "starts_with",
    "ends_with",
    "greater_than",
    "less_than",
    "between",
    "in",
    "not_in"
  ],
  "title": "FilterOperator",
  "type": "string",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/GateInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Input schema for the FatesGate system - entry point to the Fates pipeline.",
  "properties": {
    "context": {
      "$ref": "../../codegen/components/RequestContext.schema.json",
      "description": "Additional request context"
    },
    "message": {
      "$ref": "../../codegen/primitives/PlainTextObject.schema.json",
      "description": "The incoming message to process"
    },
    "thread_id": {
      "$ref": "../../codegen/primitives/UUID.schema.json",
      "description": "Thread identifier for context"
    }
  },
  "required": [
    "message",
    "thread_id"
  ],
  "title": "GateInput",
  "type": "object",
  "x-familiar-kind": "tool-payload",
  "x-familiar-queue": "daemon-queue",
  "x-familiar-role": "input",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-daemon.node.json"
  },
  "x-familiar-system": {
    "$ref": "../systems/FatesGate.system.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/GateOutput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Output schema for the FatesGate system - classification and routing result.",
  "properties": {
    "classification": {
      "description": "Classification result from the Gate",
      "enum": [
        "MOMENT",
        "THREAD",
        "BOND",
        "PULSE",
        "UNKNOWN"
      ],
      "type": "string"
    },
    "confidence": {
      "description": "Classification confidence score",
      "maximum": 1,
      "minimum": 0,
      "type": "number"
    },
    "next_fate": {
      "description": "Which Fate to route to next",
      "enum": [
        "MORTA",
        "DECIMA",
        "NONA",
        "COMPLETE"
      ],
      "type": "string"
    },
    "shuttle_id": {
      "$ref": "../../codegen/primitives/UUID.schema.json",
      "description": "ID of the created Shuttle for pipeline routing"
    }
  },
  "required": [
    "classification",
    "shuttle_id"
  ],
  "title": "GateOutput",
  "type": "object",
  "x-familiar-kind": "tool-payload",
  "x-familiar-role": "output",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  },
  "x-familiar-system": {
    "$ref": "../systems/FatesGate.system.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/GraphUpdateType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of graph updates",
  "oneOf": [
    {
      "description": "Add new binding",
      "enum": [
        "add_binding"
      ],
      "type": "string"
    },
    {
      "description": "Strengthen existing binding",
      "enum": [
        "strengthen_binding"
      ],
      "type": "string"
    },
    {
      "description": "Weaken existing binding",
      "enum": [
        "weaken_binding"
      ],
      "type": "string"
    },
    {
      "description": "Remove binding",
      "enum": [
        "remove_binding"
      ],
      "type": "string"
    },
    {
      "description": "Merge duplicate bindings",
      "enum": [
        "merge_bindings"
      ],
      "type": "string"
    }
  ],
  "title": "GraphUpdateType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/IdentifiedVerb.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "VerbTense": {
      "description": "Verb tenses",
      "enum": [
        "past",
        "present",
        "future",
        "habitual"
      ],
      "type": "string"
    }
  },
  "description": "An identified verb with analysis",
  "properties": {
    "category": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/VerbCategory.schema.json"
        }
      ],
      "description": "Verb category"
    },
    "is_main": {
      "description": "Is this the main verb?",
      "type": "boolean"
    },
    "tense": {
      "anyOf": [
        {
          "$ref": "#/definitions/VerbTense"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Tense"
    },
    "text": {
      "description": "The verb text",
      "type": "string"
    }
  },
  "required": [
    "category",
    "is_main",
    "text"
  ],
  "title": "IdentifiedVerb",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/InputMapping.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "InputTransform": {
      "description": "Transforms for input mapping",
      "oneOf": [
        {
          "description": "Direct pass-through",
          "properties": {
            "type": {
              "enum": [
                "identity"
              ],
              "type": "string"
            }
          },
          "required": [
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Extract array item",
          "properties": {
            "index": {
              "format": "uint",
              "minimum": 0.0,
              "type": "integer"
            },
            "type": {
              "enum": [
                "array_item"
              ],
              "type": "string"
            }
          },
          "required": [
            "index",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Filter array by condition",
          "properties": {
            "path": {
              "type": "string"
            },
            "type": {
              "enum": [
                "array_filter"
              ],
              "type": "string"
            },
            "value": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "type",
            "value"
          ],
          "type": "object"
        },
        {
          "description": "Map array items",
          "properties": {
            "template": {
              "type": "string"
            },
            "type": {
              "enum": [
                "array_map"
              ],
              "type": "string"
            }
          },
          "required": [
            "template",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Concatenate strings",
          "properties": {
            "separator": {
              "type": "string"
            },
            "type": {
              "enum": [
                "concat"
              ],
              "type": "string"
            }
          },
          "required": [
            "separator",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Custom transform function",
          "properties": {
            "function": {
              "type": "string"
            },
            "type": {
              "enum": [
                "custom"
              ],
              "type": "string"
            }
          },
          "required": [
            "function",
            "type"
          ],
          "type": "object"
        }
      ]
    }
  },
  "description": "Input mapping from previous step output",
  "properties": {
    "from_path": {
      "description": "Path in source output",
      "type": "string"
    },
    "from_step": {
      "description": "Source step ID",
      "type": "string"
    },
    "to_path": {
      "description": "Path in this step's input",
      "type": "string"
    },
    "transform": {
      "anyOf": [
        {
          "$ref": "#/definitions/InputTransform"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Transform to apply"
    }
  },
  "required": [
    "from_path",
    "from_step",
    "to_path"
  ],
  "title": "InputMapping",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/InputTransform.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Transforms for input mapping",
  "oneOf": [
    {
      "description": "Direct pass-through",
      "properties": {
        "type": {
          "enum": [
            "identity"
          ],
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Extract array item",
      "properties": {
        "index": {
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "type": {
          "enum": [
            "array_item"
          ],
          "type": "string"
        }
      },
      "required": [
        "index",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Filter array by condition",
      "properties": {
        "path": {
          "type": "string"
        },
        "type": {
          "enum": [
            "array_filter"
          ],
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "required": [
        "path",
        "type",
        "value"
      ],
      "type": "object"
    },
    {
      "description": "Map array items",
      "properties": {
        "template": {
          "type": "string"
        },
        "type": {
          "enum": [
            "array_map"
          ],
          "type": "string"
        }
      },
      "required": [
        "template",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Concatenate strings",
      "properties": {
        "separator": {
          "type": "string"
        },
        "type": {
          "enum": [
            "concat"
          ],
          "type": "string"
        }
      },
      "required": [
        "separator",
        "type"
      ],
      "type": "object"
    },
    {
      "description": "Custom transform function",
      "properties": {
        "function": {
          "type": "string"
        },
        "type": {
          "enum": [
            "custom"
          ],
          "type": "string"
        }
      },
      "required": [
        "function",
        "type"
      ],
      "type": "object"
    }
  ],
  "title": "InputTransform",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/InteractionFrequency.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Interaction frequency",
  "enum": [
    "daily",
    "weekly",
    "monthly",
    "quarterly",
    "yearly",
    "rarely"
  ],
  "title": "InteractionFrequency",
  "type": "string",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/KnownEntity.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Known entity for reference resolution",
  "properties": {
    "aliases": {
      "default": [],
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "entity_type": {
      "type": "string"
    },
    "id": {
      "type": "string"
    },
    "name": {
      "type": "string"
    }
  },
  "required": [
    "entity_type",
    "id",
    "name"
  ],
  "title": "KnownEntity",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/LinguisticAnalysis.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "IdentifiedVerb": {
      "description": "An identified verb with analysis",
      "properties": {
        "category": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/VerbCategory.schema.json"
            }
          ],
          "description": "Verb category"
        },
        "is_main": {
          "description": "Is this the main verb?",
          "type": "boolean"
        },
        "tense": {
          "anyOf": [
            {
              "$ref": "#/definitions/VerbTense"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Tense"
        },
        "text": {
          "description": "The verb text",
          "type": "string"
        }
      },
      "required": [
        "category",
        "is_main",
        "text"
      ],
      "type": "object"
    },
    "VerbTense": {
      "description": "Verb tenses",
      "enum": [
        "past",
        "present",
        "future",
        "habitual"
      ],
      "type": "string"
    }
  },
  "description": "Result of linguistic analysis for classification",
  "properties": {
    "modifiers": {
      "default": [],
      "description": "Adverbs/modifiers that affect classification",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "objects": {
      "default": [],
      "description": "Objects identified",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "subjects": {
      "default": [],
      "description": "Subjects identified",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "verbs": {
      "description": "Identified verbs",
      "items": {
        "$ref": "#/definitions/IdentifiedVerb"
      },
      "type": "array"
    }
  },
  "required": [
    "verbs"
  ],
  "title": "LinguisticAnalysis",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/Modality.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Supported input modalities",
  "enum": [
    "text",
    "audio",
    "vision",
    "video"
  ],
  "title": "Modality",
  "type": "string",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ModalityInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Input container for different modalities",
  "oneOf": [
    {
      "properties": {
        "content": {
          "type": "string"
        },
        "language": {
          "default": null,
          "type": [
            "string",
            "null"
          ]
        },
        "modality": {
          "enum": [
            "text"
          ],
          "type": "string"
        }
      },
      "required": [
        "content",
        "modality"
      ],
      "type": "object"
    },
    {
      "properties": {
        "data": {
          "description": "Base64 encoded audio data",
          "type": "string"
        },
        "duration_seconds": {
          "default": null,
          "description": "Duration in seconds",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "format": {
          "description": "Audio format (mp3, wav, etc.)",
          "type": "string"
        },
        "modality": {
          "enum": [
            "audio"
          ],
          "type": "string"
        }
      },
      "required": [
        "data",
        "format",
        "modality"
      ],
      "type": "object"
    },
    {
      "properties": {
        "data": {
          "description": "Base64 encoded image data",
          "type": "string"
        },
        "format": {
          "description": "Image format (png, jpg, etc.)",
          "type": "string"
        },
        "height": {
          "default": null,
          "format": "uint32",
          "minimum": 0.0,
          "type": [
            "integer",
            "null"
          ]
        },
        "modality": {
          "enum": [
            "vision"
          ],
          "type": "string"
        },
        "width": {
          "default": null,
          "description": "Image dimensions",
          "format": "uint32",
          "minimum": 0.0,
          "type": [
            "integer",
            "null"
          ]
        }
      },
      "required": [
        "data",
        "format",
        "modality"
      ],
      "type": "object"
    },
    {
      "properties": {
        "data": {
          "description": "Base64 encoded video data or URL",
          "type": "string"
        },
        "duration_seconds": {
          "default": null,
          "description": "Duration in seconds",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "format": {
          "description": "Video format (mp4, webm, etc.)",
          "type": "string"
        },
        "fps": {
          "default": null,
          "description": "Frame rate",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "modality": {
          "enum": [
            "video"
          ],
          "type": "string"
        }
      },
      "required": [
        "data",
        "format",
        "modality"
      ],
      "type": "object"
    }
  ],
  "title": "ModalityInput",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "input",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ParameterConstraints.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Validation constraints for parameters",
  "properties": {
    "allowed_values": {
      "default": null,
      "description": "Allowed values (enum constraint)",
      "items": {
        "type": "string"
      },
      "type": [
        "array",
        "null"
      ]
    },
    "max": {
      "default": null,
      "description": "Maximum value (for numbers) or length (for strings/arrays)",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "min": {
      "default": null,
      "description": "Minimum value (for numbers) or length (for strings/arrays)",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    },
    "pattern": {
      "default": null,
      "description": "Regex pattern for string validation",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "title": "ParameterConstraints",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ParameterType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Supported parameter types",
  "oneOf": [
    {
      "enum": [
        "string",
        "integer",
        "float",
        "boolean",
        "array",
        "object"
      ],
      "type": "string"
    },
    {
      "description": "Reference to another entity",
      "enum": [
        "entity_ref"
      ],
      "type": "string"
    },
    {
      "description": "Base64 encoded binary data",
      "enum": [
        "binary"
      ],
      "type": "string"
    }
  ],
  "title": "ParameterType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ParsedTemporal.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Parsed temporal information",
  "properties": {
    "date": {
      "default": null,
      "description": "ISO 8601 date if specific",
      "type": [
        "string",
        "null"
      ]
    },
    "relative_days": {
      "default": null,
      "description": "Relative offset (e.g., -1 for \"yesterday\")",
      "format": "int32",
      "type": [
        "integer",
        "null"
      ]
    },
    "time_of_day": {
      "default": null,
      "description": "Time of day if mentioned",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "title": "ParsedTemporal",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/PhysicsAnalysis.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "DetectedEmotion": {
      "description": "A detected emotion in the content",
      "properties": {
        "emotion": {
          "description": "Emotion name",
          "type": "string"
        },
        "evidence": {
          "description": "Evidence for detection",
          "type": "string"
        },
        "intensity": {
          "description": "Intensity (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "emotion",
        "evidence",
        "intensity"
      ],
      "type": "object"
    }
  },
  "description": "Analysis that led to physics values",
  "properties": {
    "certainty_indicators": {
      "default": [],
      "description": "Certainty indicators",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "emotions": {
      "default": [],
      "description": "Detected emotions",
      "items": {
        "$ref": "#/definitions/DetectedEmotion"
      },
      "type": "array"
    },
    "reasoning": {
      "description": "Overall reasoning",
      "type": "string"
    },
    "significance_indicators": {
      "default": [],
      "description": "Significance indicators",
      "items": {
        "type": "string"
      },
      "type": "array"
    }
  },
  "required": [
    "reasoning"
  ],
  "title": "PhysicsAnalysis",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/PhysicsHintInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "VAEPosition": {
      "description": "VAE space position (quantized for physics)",
      "properties": {
        "x": {
          "description": "X: Valence (emotional polarity)",
          "format": "int64",
          "type": "integer"
        },
        "y": {
          "description": "Y: Arousal (energy/activation)",
          "format": "int64",
          "type": "integer"
        },
        "z": {
          "description": "Z: Epistemic (certainty)",
          "format": "int64",
          "type": "integer"
        }
      },
      "required": [
        "x",
        "y",
        "z"
      ],
      "type": "object"
    }
  },
  "description": "Input for physics hint generation",
  "properties": {
    "content": {
      "description": "Content text",
      "type": "string"
    },
    "entity_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/EntityType.schema.json"
        }
      ],
      "description": "Entity type being spawned"
    },
    "previous_positions": {
      "default": [],
      "description": "Previous entity positions for continuity",
      "items": {
        "$ref": "#/definitions/VAEPosition"
      },
      "type": "array"
    },
    "segment": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/Segment.schema.json"
        }
      ],
      "description": "The segment to analyze"
    }
  },
  "required": [
    "content",
    "entity_type",
    "segment"
  ],
  "title": "PhysicsHintInput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "input",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/PhysicsHintOutput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "DetectedEmotion": {
      "description": "A detected emotion in the content",
      "properties": {
        "emotion": {
          "description": "Emotion name",
          "type": "string"
        },
        "evidence": {
          "description": "Evidence for detection",
          "type": "string"
        },
        "intensity": {
          "description": "Intensity (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "emotion",
        "evidence",
        "intensity"
      ],
      "type": "object"
    },
    "PhysicsAnalysis": {
      "description": "Analysis that led to physics values",
      "properties": {
        "certainty_indicators": {
          "default": [],
          "description": "Certainty indicators",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "emotions": {
          "default": [],
          "description": "Detected emotions",
          "items": {
            "$ref": "#/definitions/DetectedEmotion"
          },
          "type": "array"
        },
        "reasoning": {
          "description": "Overall reasoning",
          "type": "string"
        },
        "significance_indicators": {
          "default": [],
          "description": "Significance indicators",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "reasoning"
      ],
      "type": "object"
    },
    "PhysicsHintValues": {
      "description": "Physics hint values",
      "properties": {
        "arousal": {
          "description": "Arousal/activation: 0.0 (calm/low energy) to 1.0 (excited/high energy) Maps to Y-axis in VAE space",
          "format": "double",
          "type": "number"
        },
        "energy": {
          "description": "Energy level for simulation",
          "format": "double",
          "type": "number"
        },
        "epistemic": {
          "description": "Epistemic certainty: 0.0 (uncertain) to 1.0 (certain) Maps to Z-axis in VAE space",
          "format": "double",
          "type": "number"
        },
        "significance": {
          "description": "Significance/mass: 0.0 (trivial) to 1.0 (very important) Affects physics simulation weight",
          "format": "double",
          "type": "number"
        },
        "temperature": {
          "description": "Temperature (volatility/changeability)",
          "format": "double",
          "type": "number"
        },
        "valence": {
          "description": "Emotional valence: -1.0 (very negative) to 1.0 (very positive) Maps to X-axis in VAE space",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "arousal",
        "energy",
        "epistemic",
        "significance",
        "temperature",
        "valence"
      ],
      "type": "object"
    },
    "VAEPosition": {
      "description": "VAE space position (quantized for physics)",
      "properties": {
        "x": {
          "description": "X: Valence (emotional polarity)",
          "format": "int64",
          "type": "integer"
        },
        "y": {
          "description": "Y: Arousal (energy/activation)",
          "format": "int64",
          "type": "integer"
        },
        "z": {
          "description": "Z: Epistemic (certainty)",
          "format": "int64",
          "type": "integer"
        }
      },
      "required": [
        "x",
        "y",
        "z"
      ],
      "type": "object"
    }
  },
  "description": "Output from physics hint generation",
  "properties": {
    "analysis": {
      "allOf": [
        {
          "$ref": "#/definitions/PhysicsAnalysis"
        }
      ],
      "description": "Analysis that led to these values"
    },
    "hints": {
      "allOf": [
        {
          "$ref": "#/definitions/PhysicsHintValues"
        }
      ],
      "description": "The computed physics hints"
    },
    "position": {
      "allOf": [
        {
          "$ref": "#/definitions/VAEPosition"
        }
      ],
      "description": "Computed VAE position"
    }
  },
  "required": [
    "analysis",
    "hints",
    "position"
  ],
  "title": "PhysicsHintOutput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "output",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/PhysicsHintValues.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Physics hint values",
  "properties": {
    "arousal": {
      "description": "Arousal/activation: 0.0 (calm/low energy) to 1.0 (excited/high energy) Maps to Y-axis in VAE space",
      "format": "double",
      "type": "number"
    },
    "energy": {
      "description": "Energy level for simulation",
      "format": "double",
      "type": "number"
    },
    "epistemic": {
      "description": "Epistemic certainty: 0.0 (uncertain) to 1.0 (certain) Maps to Z-axis in VAE space",
      "format": "double",
      "type": "number"
    },
    "significance": {
      "description": "Significance/mass: 0.0 (trivial) to 1.0 (very important) Affects physics simulation weight",
      "format": "double",
      "type": "number"
    },
    "temperature": {
      "description": "Temperature (volatility/changeability)",
      "format": "double",
      "type": "number"
    },
    "valence": {
      "description": "Emotional valence: -1.0 (very negative) to 1.0 (very positive) Maps to X-axis in VAE space",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "arousal",
    "energy",
    "epistemic",
    "significance",
    "temperature",
    "valence"
  ],
  "title": "PhysicsHintValues",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/PhysicsHints.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Hints for physics/VAE space positioning",
  "properties": {
    "arousal": {
      "description": "Arousal: 0.0 (calm) to 1.0 (excited/energized)",
      "format": "double",
      "type": "number"
    },
    "certainty": {
      "default": 0.5,
      "description": "Epistemic certainty: 0.0 (uncertain) to 1.0 (certain)",
      "format": "double",
      "type": "number"
    },
    "reasoning": {
      "default": null,
      "description": "Reasoning for physics values",
      "type": [
        "string",
        "null"
      ]
    },
    "significance": {
      "description": "Significance/mass: 0.0 (trivial) to 1.0 (very important)",
      "format": "double",
      "type": "number"
    },
    "valence": {
      "description": "Valence: -1.0 (negative) to 1.0 (positive)",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "arousal",
    "significance",
    "valence"
  ],
  "title": "PhysicsHints",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/PipelineTrigger.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TriggerType": {
      "description": "Types of triggers",
      "oneOf": [
        {
          "description": "Match on purpose type",
          "enum": [
            "purpose"
          ],
          "type": "string"
        },
        {
          "description": "Match on modality",
          "enum": [
            "modality"
          ],
          "type": "string"
        },
        {
          "description": "Match on entity type",
          "enum": [
            "entity_type"
          ],
          "type": "string"
        },
        {
          "description": "Match on keyword",
          "enum": [
            "keyword"
          ],
          "type": "string"
        },
        {
          "description": "Custom condition",
          "enum": [
            "custom"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Trigger for pipeline selection",
  "properties": {
    "priority": {
      "default": 0,
      "description": "Priority (higher = checked first)",
      "format": "uint32",
      "minimum": 0.0,
      "type": "integer"
    },
    "trigger_type": {
      "allOf": [
        {
          "$ref": "#/definitions/TriggerType"
        }
      ],
      "description": "Trigger type"
    },
    "value": {
      "description": "Value to match",
      "type": "string"
    }
  },
  "required": [
    "trigger_type",
    "value"
  ],
  "title": "PipelineTrigger",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/PipelineType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of standard pipelines",
  "oneOf": [
    {
      "description": "Memory recording: Segment  Classify  Spawn  Hints  Store",
      "enum": [
        "memory_recording"
      ],
      "type": "string"
    },
    {
      "description": "Query: Parse  Search  Format  Return",
      "enum": [
        "query"
      ],
      "type": "string"
    },
    {
      "description": "Analysis: Parse  Search  Analyze  Synthesize",
      "enum": [
        "analysis"
      ],
      "type": "string"
    },
    {
      "description": "Command: Parse  Validate  Execute  Confirm",
      "enum": [
        "command"
      ],
      "type": "string"
    },
    {
      "description": "Conversation: Understand  Respond",
      "enum": [
        "conversation"
      ],
      "type": "string"
    },
    {
      "description": "Multi-modal: Route  Process per modality  Merge",
      "enum": [
        "multi_modal"
      ],
      "type": "string"
    }
  ],
  "title": "PipelineType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/PurposeClassifierInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ClassifiedPurpose": {
      "description": "A classified purpose with confidence",
      "properties": {
        "confidence": {
          "description": "Confidence score (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "evidence": {
          "default": [],
          "description": "Evidence/reasoning for classification",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "purpose": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ToolPurpose.schema.json"
            }
          ],
          "description": "The purpose of the message"
        }
      },
      "required": [
        "confidence",
        "purpose"
      ],
      "type": "object"
    },
    "PurposeContext": {
      "description": "Context for purpose classification",
      "properties": {
        "conversation_history": {
          "default": [],
          "description": "Previous messages in conversation",
          "items": {
            "$ref": "../../codegen/primitives/ConversationTurn.schema.json"
          },
          "type": "array"
        },
        "previous_classifications": {
          "default": [],
          "description": "Previous classifications detected",
          "items": {
            "$ref": "#/definitions/ClassifiedPurpose"
          },
          "type": "array"
        },
        "user_patterns": {
          "anyOf": [
            {
              "$ref": "#/definitions/UserPurposePatterns"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's typical patterns (if known)"
        }
      },
      "type": "object"
    },
    "UserPurposePatterns": {
      "description": "User's historical purpose patterns",
      "properties": {
        "primary_purpose": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ToolPurpose.schema.json"
            }
          ],
          "description": "Most common purpose"
        },
        "purpose_distribution": {
          "additionalProperties": {
            "format": "double",
            "type": "number"
          },
          "default": {},
          "description": "Distribution of purposes (purpose -> frequency)",
          "type": "object"
        }
      },
      "required": [
        "primary_purpose"
      ],
      "type": "object"
    }
  },
  "description": "Input for purpose classification",
  "properties": {
    "context": {
      "anyOf": [
        {
          "$ref": "#/definitions/PurposeContext"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Conversation context for better classification"
    },
    "segment": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/Segment.schema.json"
        }
      ],
      "description": "The segment to classify"
    }
  },
  "required": [
    "segment"
  ],
  "title": "PurposeClassifierInput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "input",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/PurposeClassifierOutput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ClassifiedPurpose": {
      "description": "A classified purpose with confidence",
      "properties": {
        "confidence": {
          "description": "Confidence score (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "evidence": {
          "default": [],
          "description": "Evidence/reasoning for classification",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "purpose": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ToolPurpose.schema.json"
            }
          ],
          "description": "The purpose of the message"
        }
      },
      "required": [
        "confidence",
        "purpose"
      ],
      "type": "object"
    },
    "CommandAnalysis": {
      "description": "Analysis of a command purpose",
      "properties": {
        "command_type": {
          "allOf": [
            {
              "$ref": "#/definitions/CommandType"
            }
          ],
          "description": "Command type"
        },
        "is_destructive": {
          "description": "Is this command destructive?",
          "type": "boolean"
        },
        "needs_confirmation": {
          "description": "Does this command need confirmation?",
          "type": "boolean"
        },
        "parameters": {
          "additionalProperties": true,
          "default": {},
          "description": "Command parameters",
          "type": "object"
        },
        "target": {
          "default": null,
          "description": "Target of the command",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "command_type",
        "is_destructive",
        "needs_confirmation"
      ],
      "type": "object"
    },
    "CommandType": {
      "description": "Types of commands",
      "oneOf": [
        {
          "description": "Create something",
          "enum": [
            "CREATE"
          ],
          "type": "string"
        },
        {
          "description": "Update/modify",
          "enum": [
            "UPDATE"
          ],
          "type": "string"
        },
        {
          "description": "Delete/remove",
          "enum": [
            "DELETE"
          ],
          "type": "string"
        },
        {
          "description": "Link/connect entities",
          "enum": [
            "LINK"
          ],
          "type": "string"
        },
        {
          "description": "Unlink/disconnect entities",
          "enum": [
            "UNLINK"
          ],
          "type": "string"
        },
        {
          "description": "Export data",
          "enum": [
            "EXPORT"
          ],
          "type": "string"
        },
        {
          "description": "Import data",
          "enum": [
            "IMPORT"
          ],
          "type": "string"
        },
        {
          "description": "Configure settings",
          "enum": [
            "CONFIGURE"
          ],
          "type": "string"
        },
        {
          "description": "Unknown/custom command",
          "enum": [
            "CUSTOM"
          ],
          "type": "string"
        }
      ]
    },
    "FilterOperator": {
      "description": "Filter operators",
      "enum": [
        "equals",
        "not_equals",
        "contains",
        "starts_with",
        "ends_with",
        "greater_than",
        "less_than",
        "between",
        "in",
        "not_in"
      ],
      "type": "string"
    },
    "PurposePipeline": {
      "description": "Processing pipeline category",
      "oneOf": [
        {
          "description": "Memory recording: Segment  Classify  Spawn  Store",
          "enum": [
            "recording"
          ],
          "type": "string"
        },
        {
          "description": "Data retrieval: Parse  Search  Format  Return",
          "enum": [
            "retrieval"
          ],
          "type": "string"
        },
        {
          "description": "Analysis: Parse  Search  Analyze  Synthesize",
          "enum": [
            "analysis"
          ],
          "type": "string"
        },
        {
          "description": "System action: Parse  Validate  Execute  Confirm",
          "enum": [
            "action"
          ],
          "type": "string"
        },
        {
          "description": "Conversation: Respond appropriately",
          "enum": [
            "conversational"
          ],
          "type": "string"
        }
      ]
    },
    "QueryAnalysis": {
      "description": "Analysis of a query purpose",
      "properties": {
        "filters": {
          "default": [],
          "description": "Filters to apply",
          "items": {
            "$ref": "#/definitions/QueryFilter"
          },
          "type": "array"
        },
        "query_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/QueryType.schema.json"
            }
          ],
          "description": "Type of query"
        },
        "search_terms": {
          "description": "Extracted search terms",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "target": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/QueryTarget.schema.json"
            }
          ],
          "description": "What the query is targeting"
        }
      },
      "required": [
        "query_type",
        "search_terms",
        "target"
      ],
      "type": "object"
    },
    "QueryFilter": {
      "description": "A filter for queries",
      "properties": {
        "field": {
          "description": "Field to filter on",
          "type": "string"
        },
        "operator": {
          "allOf": [
            {
              "$ref": "#/definitions/FilterOperator"
            }
          ],
          "description": "Filter operator"
        },
        "value": {
          "description": "Filter value"
        }
      },
      "required": [
        "field",
        "operator",
        "value"
      ],
      "type": "object"
    }
  },
  "description": "Output from purpose classification",
  "properties": {
    "command_analysis": {
      "anyOf": [
        {
          "$ref": "#/definitions/CommandAnalysis"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Command analysis (if purpose is Command)"
    },
    "pipeline": {
      "allOf": [
        {
          "$ref": "#/definitions/PurposePipeline"
        }
      ],
      "description": "Recommended processing pipeline"
    },
    "primary": {
      "allOf": [
        {
          "$ref": "#/definitions/ClassifiedPurpose"
        }
      ],
      "description": "Primary classified purpose"
    },
    "query_analysis": {
      "anyOf": [
        {
          "$ref": "#/definitions/QueryAnalysis"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Query analysis (if purpose is Query-related)"
    },
    "secondary": {
      "default": [],
      "description": "Secondary purposes (if multi-purpose detected)",
      "items": {
        "$ref": "#/definitions/ClassifiedPurpose"
      },
      "type": "array"
    }
  },
  "required": [
    "pipeline",
    "primary"
  ],
  "title": "PurposeClassifierOutput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "output",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/PurposeContext.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ClassifiedPurpose": {
      "description": "A classified purpose with confidence",
      "properties": {
        "confidence": {
          "description": "Confidence score (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "evidence": {
          "default": [],
          "description": "Evidence/reasoning for classification",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "purpose": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ToolPurpose.schema.json"
            }
          ],
          "description": "The purpose of the message"
        }
      },
      "required": [
        "confidence",
        "purpose"
      ],
      "type": "object"
    },
    "UserPurposePatterns": {
      "description": "User's historical purpose patterns",
      "properties": {
        "primary_purpose": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ToolPurpose.schema.json"
            }
          ],
          "description": "Most common purpose"
        },
        "purpose_distribution": {
          "additionalProperties": {
            "format": "double",
            "type": "number"
          },
          "default": {},
          "description": "Distribution of purposes (purpose -> frequency)",
          "type": "object"
        }
      },
      "required": [
        "primary_purpose"
      ],
      "type": "object"
    }
  },
  "description": "Context for purpose classification",
  "properties": {
    "conversation_history": {
      "default": [],
      "description": "Previous messages in conversation",
      "items": {
        "$ref": "../../codegen/primitives/ConversationTurn.schema.json"
      },
      "type": "array"
    },
    "previous_classifications": {
      "default": [],
      "description": "Previous classifications detected",
      "items": {
        "$ref": "#/definitions/ClassifiedPurpose"
      },
      "type": "array"
    },
    "user_patterns": {
      "anyOf": [
        {
          "$ref": "#/definitions/UserPurposePatterns"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "User's typical patterns (if known)"
    }
  },
  "title": "PurposeContext",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/PurposePipeline.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Processing pipeline category",
  "oneOf": [
    {
      "description": "Memory recording: Segment  Classify  Spawn  Store",
      "enum": [
        "recording"
      ],
      "type": "string"
    },
    {
      "description": "Data retrieval: Parse  Search  Format  Return",
      "enum": [
        "retrieval"
      ],
      "type": "string"
    },
    {
      "description": "Analysis: Parse  Search  Analyze  Synthesize",
      "enum": [
        "analysis"
      ],
      "type": "string"
    },
    {
      "description": "System action: Parse  Validate  Execute  Confirm",
      "enum": [
        "action"
      ],
      "type": "string"
    },
    {
      "description": "Conversation: Respond appropriately",
      "enum": [
        "conversational"
      ],
      "type": "string"
    }
  ],
  "title": "PurposePipeline",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/QueryAnalysis.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "FilterOperator": {
      "description": "Filter operators",
      "enum": [
        "equals",
        "not_equals",
        "contains",
        "starts_with",
        "ends_with",
        "greater_than",
        "less_than",
        "between",
        "in",
        "not_in"
      ],
      "type": "string"
    },
    "QueryFilter": {
      "description": "A filter for queries",
      "properties": {
        "field": {
          "description": "Field to filter on",
          "type": "string"
        },
        "operator": {
          "allOf": [
            {
              "$ref": "#/definitions/FilterOperator"
            }
          ],
          "description": "Filter operator"
        },
        "value": {
          "description": "Filter value"
        }
      },
      "required": [
        "field",
        "operator",
        "value"
      ],
      "type": "object"
    }
  },
  "description": "Analysis of a query purpose",
  "properties": {
    "filters": {
      "default": [],
      "description": "Filters to apply",
      "items": {
        "$ref": "#/definitions/QueryFilter"
      },
      "type": "array"
    },
    "query_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/QueryType.schema.json"
        }
      ],
      "description": "Type of query"
    },
    "search_terms": {
      "description": "Extracted search terms",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "target": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/QueryTarget.schema.json"
        }
      ],
      "description": "What the query is targeting"
    }
  },
  "required": [
    "query_type",
    "search_terms",
    "target"
  ],
  "title": "QueryAnalysis",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/QueryFilter.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "FilterOperator": {
      "description": "Filter operators",
      "enum": [
        "equals",
        "not_equals",
        "contains",
        "starts_with",
        "ends_with",
        "greater_than",
        "less_than",
        "between",
        "in",
        "not_in"
      ],
      "type": "string"
    }
  },
  "description": "A filter for queries",
  "properties": {
    "field": {
      "description": "Field to filter on",
      "type": "string"
    },
    "operator": {
      "allOf": [
        {
          "$ref": "#/definitions/FilterOperator"
        }
      ],
      "description": "Filter operator"
    },
    "value": {
      "description": "Filter value"
    }
  },
  "required": [
    "field",
    "operator",
    "value"
  ],
  "title": "QueryFilter",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/RecentThread.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A recently referenced thread",
  "properties": {
    "mention_count": {
      "description": "Mention count in recent context",
      "format": "uint32",
      "minimum": 0.0,
      "type": "integer"
    },
    "recency": {
      "description": "How recently mentioned (in messages)",
      "format": "uint32",
      "minimum": 0.0,
      "type": "integer"
    },
    "thread": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/ThreadReference.schema.json"
        }
      ],
      "description": "Thread reference"
    }
  },
  "required": [
    "mention_count",
    "recency",
    "thread"
  ],
  "title": "RecentThread",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/RelationshipDuration.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "DurationCategory": {
      "description": "Duration categories",
      "enum": [
        "new",
        "recent",
        "established",
        "long_term",
        "lifelong"
      ],
      "type": "string"
    }
  },
  "description": "Relationship duration",
  "properties": {
    "category": {
      "allOf": [
        {
          "$ref": "#/definitions/DurationCategory"
        }
      ],
      "description": "Duration category"
    },
    "since": {
      "default": null,
      "description": "Start date if known",
      "type": [
        "string",
        "null"
      ]
    },
    "years": {
      "default": null,
      "description": "How long the relationship has existed",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    }
  },
  "required": [
    "category"
  ],
  "title": "RelationshipDuration",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/RelationshipType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of relationships",
  "enum": [
    "family",
    "friend",
    "close_friend",
    "best_friend",
    "romantic",
    "ex_romantic",
    "spouse",
    "parent",
    "child",
    "sibling",
    "colleague",
    "manager",
    "direct_report",
    "mentor",
    "mentee",
    "client",
    "vendor",
    "partner",
    "acquaintance",
    "neighbor",
    "classmate",
    "teammate",
    "adversary",
    "rival",
    "service_provider",
    "other"
  ],
  "title": "RelationshipType",
  "type": "string",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/Segment.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A segmented unit of content",
  "properties": {
    "boundaries": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/SegmentBoundaries.schema.json"
        }
      ],
      "description": "Segment boundaries"
    },
    "confidence": {
      "description": "Confidence in segmentation decision",
      "format": "double",
      "type": "number"
    },
    "content": {
      "description": "The segmented content",
      "type": "string"
    },
    "features": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/SegmentFeatures.schema.json"
        }
      ],
      "description": "Extracted features"
    },
    "id": {
      "description": "Unique segment ID",
      "type": "string"
    },
    "index": {
      "description": "Index in the sequence",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "modality": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/Modality.schema.json"
        }
      ],
      "description": "Original modality"
    }
  },
  "required": [
    "boundaries",
    "confidence",
    "content",
    "features",
    "id",
    "index",
    "modality"
  ],
  "title": "Segment",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SegmentBoundaries.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Boundaries of a segment within the original input",
  "properties": {
    "end": {
      "description": "End position",
      "format": "uint64",
      "minimum": 0.0,
      "type": "integer"
    },
    "speaker_id": {
      "default": null,
      "description": "For audio/video: speaker ID if detected",
      "type": [
        "string",
        "null"
      ]
    },
    "start": {
      "description": "Start position (char index for text, milliseconds for audio/video)",
      "format": "uint64",
      "minimum": 0.0,
      "type": "integer"
    }
  },
  "required": [
    "end",
    "start"
  ],
  "title": "SegmentBoundaries",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SegmentFeatures.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Extracted features from a segment",
  "properties": {
    "emotional_tone": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/EmotionalTone.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Emotional tone (if detectable)"
    },
    "keywords": {
      "default": [],
      "description": "Keywords extracted",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "language": {
      "default": null,
      "description": "Language detected",
      "type": [
        "string",
        "null"
      ]
    },
    "mentions": {
      "default": [],
      "description": "Entity mentions found",
      "items": {
        "$ref": "../../codegen/primitives/EntityMention.schema.json"
      },
      "type": "array"
    },
    "subject": {
      "default": null,
      "description": "Primary subject/actor mentioned",
      "type": [
        "string",
        "null"
      ]
    },
    "temporal_markers": {
      "default": [],
      "description": "Temporal markers detected",
      "items": {
        "$ref": "../../codegen/primitives/TemporalMarker.schema.json"
      },
      "type": "array"
    }
  },
  "title": "SegmentFeatures",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SegmentationConfig.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Configuration for segmentation behavior",
  "properties": {
    "extract_entities": {
      "default": true,
      "description": "Whether to extract entity mentions",
      "type": "boolean"
    },
    "extract_temporal": {
      "default": true,
      "description": "Whether to extract temporal markers",
      "type": "boolean"
    },
    "language": {
      "default": null,
      "description": "Language hint (ISO 639-1)",
      "type": [
        "string",
        "null"
      ]
    },
    "max_segments": {
      "default": 20,
      "description": "Maximum number of segments to produce",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "min_segment_length": {
      "default": null,
      "description": "Minimum segment length (chars for text, seconds for audio/video)",
      "format": "double",
      "type": [
        "number",
        "null"
      ]
    }
  },
  "title": "SegmentationConfig",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SegmentationContext.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "KnownEntity": {
      "description": "Known entity for reference resolution",
      "properties": {
        "aliases": {
          "default": [],
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "entity_type": {
          "type": "string"
        },
        "id": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "entity_type",
        "id",
        "name"
      ],
      "type": "object"
    }
  },
  "description": "Context for segmentation",
  "properties": {
    "current_speaker": {
      "default": null,
      "description": "Current speaker (if known)",
      "type": [
        "string",
        "null"
      ]
    },
    "known_entities": {
      "default": [],
      "description": "Known entities for reference resolution",
      "items": {
        "$ref": "#/definitions/KnownEntity"
      },
      "type": "array"
    },
    "previous_segments": {
      "default": [],
      "description": "Previous segments in the conversation",
      "items": {
        "$ref": "../../codegen/primitives/Segment.schema.json"
      },
      "type": "array"
    },
    "tenant_id": {
      "description": "Tenant ID for multi-tenancy",
      "type": "string"
    }
  },
  "required": [
    "tenant_id"
  ],
  "title": "SegmentationContext",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SegmentationInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "KnownEntity": {
      "description": "Known entity for reference resolution",
      "properties": {
        "aliases": {
          "default": [],
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "entity_type": {
          "type": "string"
        },
        "id": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "entity_type",
        "id",
        "name"
      ],
      "type": "object"
    },
    "ModalityInput": {
      "description": "Input container for different modalities",
      "oneOf": [
        {
          "properties": {
            "content": {
              "type": "string"
            },
            "language": {
              "default": null,
              "type": [
                "string",
                "null"
              ]
            },
            "modality": {
              "enum": [
                "text"
              ],
              "type": "string"
            }
          },
          "required": [
            "content",
            "modality"
          ],
          "type": "object"
        },
        {
          "properties": {
            "data": {
              "description": "Base64 encoded audio data",
              "type": "string"
            },
            "duration_seconds": {
              "default": null,
              "description": "Duration in seconds",
              "format": "double",
              "type": [
                "number",
                "null"
              ]
            },
            "format": {
              "description": "Audio format (mp3, wav, etc.)",
              "type": "string"
            },
            "modality": {
              "enum": [
                "audio"
              ],
              "type": "string"
            }
          },
          "required": [
            "data",
            "format",
            "modality"
          ],
          "type": "object"
        },
        {
          "properties": {
            "data": {
              "description": "Base64 encoded image data",
              "type": "string"
            },
            "format": {
              "description": "Image format (png, jpg, etc.)",
              "type": "string"
            },
            "height": {
              "default": null,
              "format": "uint32",
              "minimum": 0.0,
              "type": [
                "integer",
                "null"
              ]
            },
            "modality": {
              "enum": [
                "vision"
              ],
              "type": "string"
            },
            "width": {
              "default": null,
              "description": "Image dimensions",
              "format": "uint32",
              "minimum": 0.0,
              "type": [
                "integer",
                "null"
              ]
            }
          },
          "required": [
            "data",
            "format",
            "modality"
          ],
          "type": "object"
        },
        {
          "properties": {
            "data": {
              "description": "Base64 encoded video data or URL",
              "type": "string"
            },
            "duration_seconds": {
              "default": null,
              "description": "Duration in seconds",
              "format": "double",
              "type": [
                "number",
                "null"
              ]
            },
            "format": {
              "description": "Video format (mp4, webm, etc.)",
              "type": "string"
            },
            "fps": {
              "default": null,
              "description": "Frame rate",
              "format": "double",
              "type": [
                "number",
                "null"
              ]
            },
            "modality": {
              "enum": [
                "video"
              ],
              "type": "string"
            }
          },
          "required": [
            "data",
            "format",
            "modality"
          ],
          "type": "object"
        }
      ]
    },
    "SegmentationConfig": {
      "description": "Configuration for segmentation behavior",
      "properties": {
        "extract_entities": {
          "default": true,
          "description": "Whether to extract entity mentions",
          "type": "boolean"
        },
        "extract_temporal": {
          "default": true,
          "description": "Whether to extract temporal markers",
          "type": "boolean"
        },
        "language": {
          "default": null,
          "description": "Language hint (ISO 639-1)",
          "type": [
            "string",
            "null"
          ]
        },
        "max_segments": {
          "default": 20,
          "description": "Maximum number of segments to produce",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "min_segment_length": {
          "default": null,
          "description": "Minimum segment length (chars for text, seconds for audio/video)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "SegmentationContext": {
      "description": "Context for segmentation",
      "properties": {
        "current_speaker": {
          "default": null,
          "description": "Current speaker (if known)",
          "type": [
            "string",
            "null"
          ]
        },
        "known_entities": {
          "default": [],
          "description": "Known entities for reference resolution",
          "items": {
            "$ref": "#/definitions/KnownEntity"
          },
          "type": "array"
        },
        "previous_segments": {
          "default": [],
          "description": "Previous segments in the conversation",
          "items": {
            "$ref": "../../codegen/primitives/Segment.schema.json"
          },
          "type": "array"
        },
        "tenant_id": {
          "description": "Tenant ID for multi-tenancy",
          "type": "string"
        }
      },
      "required": [
        "tenant_id"
      ],
      "type": "object"
    }
  },
  "description": "Input for segmentation tools",
  "properties": {
    "config": {
      "allOf": [
        {
          "$ref": "#/definitions/SegmentationConfig"
        }
      ],
      "default": {
        "extract_entities": true,
        "extract_temporal": true,
        "language": null,
        "max_segments": 20,
        "min_segment_length": null
      },
      "description": "Configuration options"
    },
    "context": {
      "anyOf": [
        {
          "$ref": "#/definitions/SegmentationContext"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Context from conversation/session"
    },
    "input": {
      "allOf": [
        {
          "$ref": "#/definitions/ModalityInput"
        }
      ],
      "description": "The input to segment"
    }
  },
  "required": [
    "input"
  ],
  "title": "SegmentationInput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "input",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SegmentationMetadata.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Metadata about the segmentation",
  "properties": {
    "entity_count": {
      "description": "Total entities mentioned",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "language": {
      "default": null,
      "description": "Primary language detected",
      "type": [
        "string",
        "null"
      ]
    },
    "modality": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/Modality.schema.json"
        }
      ],
      "description": "Input modality"
    },
    "segment_count": {
      "description": "Total segments produced",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "speaker_count": {
      "default": null,
      "description": "Number of unique speakers (for audio/video)",
      "format": "uint",
      "minimum": 0.0,
      "type": [
        "integer",
        "null"
      ]
    },
    "temporal_count": {
      "description": "Total temporal markers found",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    }
  },
  "required": [
    "entity_count",
    "modality",
    "segment_count",
    "temporal_count"
  ],
  "title": "SegmentationMetadata",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SegmentationOutput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "SegmentationMetadata": {
      "description": "Metadata about the segmentation",
      "properties": {
        "entity_count": {
          "description": "Total entities mentioned",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "language": {
          "default": null,
          "description": "Primary language detected",
          "type": [
            "string",
            "null"
          ]
        },
        "modality": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/Modality.schema.json"
            }
          ],
          "description": "Input modality"
        },
        "segment_count": {
          "description": "Total segments produced",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "speaker_count": {
          "default": null,
          "description": "Number of unique speakers (for audio/video)",
          "format": "uint",
          "minimum": 0.0,
          "type": [
            "integer",
            "null"
          ]
        },
        "temporal_count": {
          "description": "Total temporal markers found",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        }
      },
      "required": [
        "entity_count",
        "modality",
        "segment_count",
        "temporal_count"
      ],
      "type": "object"
    }
  },
  "description": "Output from segmentation tools",
  "properties": {
    "metadata": {
      "allOf": [
        {
          "$ref": "#/definitions/SegmentationMetadata"
        }
      ],
      "description": "Overall segmentation metadata"
    },
    "segments": {
      "description": "The resulting segments",
      "items": {
        "$ref": "../../codegen/primitives/Segment.schema.json"
      },
      "type": "array"
    }
  },
  "required": [
    "metadata",
    "segments"
  ],
  "title": "SegmentationOutput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "output",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SemanticProperties.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Semantic properties of binding",
  "properties": {
    "relationship_description": {
      "default": null,
      "description": "Relationship description",
      "type": [
        "string",
        "null"
      ]
    },
    "shared_concepts": {
      "default": [],
      "description": "Shared concepts/topics",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "similarity": {
      "description": "Semantic similarity score",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "similarity"
  ],
  "title": "SemanticProperties",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SpawnAction.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Action to take for spawn",
  "oneOf": [
    {
      "description": "Auto-spawn without user confirmation",
      "enum": [
        "auto_spawn"
      ],
      "type": "string"
    },
    {
      "description": "Suggest to user for review",
      "enum": [
        "suggest"
      ],
      "type": "string"
    },
    {
      "description": "Skip but log for analysis",
      "enum": [
        "skip"
      ],
      "type": "string"
    },
    {
      "description": "Request clarification from user",
      "enum": [
        "clarify"
      ],
      "type": "string"
    }
  ],
  "title": "SpawnAction",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SpawnConfig.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Configuration for spawn decisions",
  "properties": {
    "auto_spawn_enabled": {
      "default": true,
      "description": "Whether to auto-spawn high confidence entities",
      "type": "boolean"
    },
    "high_confidence_threshold": {
      "default": 0.8,
      "description": "High confidence threshold (auto-spawn above this)",
      "format": "double",
      "type": "number"
    },
    "low_confidence_threshold": {
      "default": 0.3,
      "description": "Low confidence threshold (skip below this)",
      "format": "double",
      "type": "number"
    },
    "manual_only_types": {
      "default": [],
      "description": "Entity types that should never auto-spawn",
      "items": {
        "$ref": "../../codegen/primitives/EntityType.schema.json"
      },
      "type": "array"
    },
    "max_entities_per_segment": {
      "default": 3,
      "description": "Maximum entities to spawn from one segment",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "medium_confidence_threshold": {
      "default": 0.5,
      "description": "Medium confidence threshold (suggest above this)",
      "format": "double",
      "type": "number"
    }
  },
  "title": "SpawnConfig",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SpawnHints.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BindingHints": {
      "description": "Hints for cognitive binding between entities",
      "properties": {
        "binding_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/BindingType.schema.json"
            }
          ],
          "description": "Type of cognitive binding"
        },
        "context": {
          "default": null,
          "description": "Context explaining the binding",
          "type": [
            "string",
            "null"
          ]
        },
        "directionality": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/Directionality.schema.json"
            }
          ],
          "description": "Directionality of binding"
        },
        "source": {
          "allOf": [
            {
              "$ref": "#/definitions/EntityReference"
            }
          ],
          "description": "Source entity"
        },
        "strength": {
          "description": "Strength of binding (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "target": {
          "allOf": [
            {
              "$ref": "#/definitions/EntityReference"
            }
          ],
          "description": "Target entity"
        },
        "temporal": {
          "anyOf": [
            {
              "$ref": "#/definitions/TemporalBinding"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Temporal aspect of binding"
        }
      },
      "required": [
        "binding_type",
        "directionality",
        "source",
        "strength",
        "target"
      ],
      "type": "object"
    },
    "BondHints": {
      "description": "Hints for relationship bonds",
      "properties": {
        "description": {
          "default": null,
          "description": "Description of relationship",
          "type": [
            "string",
            "null"
          ]
        },
        "reciprocity": {
          "default": 0.5,
          "description": "Reciprocity (0.0 one-way to 1.0 mutual)",
          "format": "double",
          "type": "number"
        },
        "relationship_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/RelationshipType.schema.json"
            }
          ],
          "description": "Relationship type"
        },
        "source": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadReference.schema.json"
            }
          ],
          "description": "Source entity (head of relationship)"
        },
        "strength": {
          "description": "Strength of relationship (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "target": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadReference.schema.json"
            }
          ],
          "description": "Target entity (tail of relationship)"
        },
        "valence": {
          "description": "Valence of relationship (-1.0 to 1.0)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "relationship_type",
        "source",
        "strength",
        "target",
        "valence"
      ],
      "type": "object"
    },
    "EntityReference": {
      "description": "Reference to an entity for binding",
      "properties": {
        "description": {
          "description": "Description for matching",
          "type": "string"
        },
        "entity_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/EntityType.schema.json"
            }
          ],
          "description": "Entity type"
        },
        "id": {
          "default": null,
          "description": "Entity ID (if existing)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "description",
        "entity_type"
      ],
      "type": "object"
    },
    "PhysicsHints": {
      "description": "Hints for physics/VAE space positioning",
      "properties": {
        "arousal": {
          "description": "Arousal: 0.0 (calm) to 1.0 (excited/energized)",
          "format": "double",
          "type": "number"
        },
        "certainty": {
          "default": 0.5,
          "description": "Epistemic certainty: 0.0 (uncertain) to 1.0 (certain)",
          "format": "double",
          "type": "number"
        },
        "reasoning": {
          "default": null,
          "description": "Reasoning for physics values",
          "type": [
            "string",
            "null"
          ]
        },
        "significance": {
          "description": "Significance/mass: 0.0 (trivial) to 1.0 (very important)",
          "format": "double",
          "type": "number"
        },
        "valence": {
          "description": "Valence: -1.0 (negative) to 1.0 (positive)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "arousal",
        "significance",
        "valence"
      ],
      "type": "object"
    },
    "TemporalBinding": {
      "description": "Temporal aspect of binding",
      "properties": {
        "gap": {
          "default": null,
          "description": "Time gap (if known)",
          "type": [
            "string",
            "null"
          ]
        },
        "relation": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/TemporalRelation.schema.json"
            }
          ],
          "description": "Time relationship"
        }
      },
      "required": [
        "relation"
      ],
      "type": "object"
    },
    "ThreadHints": {
      "description": "Hints for thread/narrative connections",
      "properties": {
        "create_if_missing": {
          "default": false,
          "description": "Should create new thread if no match?",
          "type": "boolean"
        },
        "keywords": {
          "default": [],
          "description": "Keywords for thread matching",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "primary_subject": {
          "description": "Primary subject/actor",
          "type": "string"
        },
        "related_threads": {
          "default": [],
          "description": "Related threads to link",
          "items": {
            "$ref": "../../codegen/primitives/ThreadReference.schema.json"
          },
          "type": "array"
        },
        "thread_role": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadRole.schema.json"
            }
          ],
          "description": "Role of entity in narrative"
        }
      },
      "required": [
        "primary_subject",
        "thread_role"
      ],
      "type": "object"
    }
  },
  "description": "All hints for a spawned entity",
  "properties": {
    "binding": {
      "anyOf": [
        {
          "$ref": "#/definitions/BindingHints"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Binding hints for cognitive connections"
    },
    "bond": {
      "anyOf": [
        {
          "$ref": "#/definitions/BondHints"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Bond hints for relationships"
    },
    "physics": {
      "allOf": [
        {
          "$ref": "#/definitions/PhysicsHints"
        }
      ],
      "description": "Physics hints for VAE space positioning"
    },
    "thread": {
      "allOf": [
        {
          "$ref": "#/definitions/ThreadHints"
        }
      ],
      "description": "Thread hints for narrative connections"
    }
  },
  "required": [
    "physics",
    "thread"
  ],
  "title": "SpawnHints",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SpawnSuggesterInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ClassificationEvidence": {
      "description": "Evidence for a classification",
      "properties": {
        "description": {
          "description": "Description of evidence",
          "type": "string"
        },
        "evidence_type": {
          "allOf": [
            {
              "$ref": "#/definitions/EvidenceType"
            }
          ],
          "description": "Type of evidence"
        },
        "weight": {
          "description": "How much this evidence contributes",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "description",
        "evidence_type",
        "weight"
      ],
      "type": "object"
    },
    "ClassificationReasoning": {
      "description": "Reasoning behind classification",
      "properties": {
        "explanations": {
          "default": [],
          "description": "Why certain types were included/excluded",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "key_phrases": {
          "default": [],
          "description": "Key phrases that influenced classification",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "main_verb": {
          "default": null,
          "description": "Main verb identified",
          "type": [
            "string",
            "null"
          ]
        },
        "verb_category": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/VerbCategory.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Verb category"
        }
      },
      "type": "object"
    },
    "EntityClassification": {
      "description": "A single entity classification with probability",
      "properties": {
        "entity_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/EntityType.schema.json"
            }
          ],
          "description": "Entity type"
        },
        "evidence": {
          "default": [],
          "description": "Evidence supporting this classification",
          "items": {
            "$ref": "#/definitions/ClassificationEvidence"
          },
          "type": "array"
        },
        "probability": {
          "description": "Probability (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "entity_type",
        "probability"
      ],
      "type": "object"
    },
    "EntityClassifierOutput": {
      "description": "Output from entity classification",
      "properties": {
        "classifications": {
          "description": "All classifications with probabilities (sorted by probability)",
          "items": {
            "$ref": "#/definitions/EntityClassification"
          },
          "type": "array"
        },
        "enriched_content": {
          "default": null,
          "description": "Enriched content (e.g., Pulse with context added)",
          "type": [
            "string",
            "null"
          ]
        },
        "primary_thread": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/ThreadReference.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Primary thread reference (main subject/actor)"
        },
        "reasoning": {
          "allOf": [
            {
              "$ref": "#/definitions/ClassificationReasoning"
            }
          ],
          "description": "Classification reasoning"
        },
        "secondary_threads": {
          "default": [],
          "description": "Secondary thread references",
          "items": {
            "$ref": "../../codegen/primitives/ThreadReference.schema.json"
          },
          "type": "array"
        },
        "temporal_marker": {
          "default": null,
          "description": "Temporal marker extracted",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "classifications",
        "reasoning"
      ],
      "type": "object"
    },
    "EvidenceType": {
      "description": "Types of evidence for classification",
      "oneOf": [
        {
          "description": "Verb type (action vs state)",
          "enum": [
            "verb_type"
          ],
          "type": "string"
        },
        {
          "description": "Keywords detected",
          "enum": [
            "keywords"
          ],
          "type": "string"
        },
        {
          "description": "Temporal indicators",
          "enum": [
            "temporal"
          ],
          "type": "string"
        },
        {
          "description": "Emotional indicators",
          "enum": [
            "emotional"
          ],
          "type": "string"
        },
        {
          "description": "Entity mentions",
          "enum": [
            "entity_mention"
          ],
          "type": "string"
        },
        {
          "description": "Relational language",
          "enum": [
            "relational"
          ],
          "type": "string"
        },
        {
          "description": "Pattern indicators",
          "enum": [
            "pattern"
          ],
          "type": "string"
        },
        {
          "description": "Context from surrounding content",
          "enum": [
            "context"
          ],
          "type": "string"
        }
      ]
    },
    "SpawnConfig": {
      "description": "Configuration for spawn decisions",
      "properties": {
        "auto_spawn_enabled": {
          "default": true,
          "description": "Whether to auto-spawn high confidence entities",
          "type": "boolean"
        },
        "high_confidence_threshold": {
          "default": 0.8,
          "description": "High confidence threshold (auto-spawn above this)",
          "format": "double",
          "type": "number"
        },
        "low_confidence_threshold": {
          "default": 0.3,
          "description": "Low confidence threshold (skip below this)",
          "format": "double",
          "type": "number"
        },
        "manual_only_types": {
          "default": [],
          "description": "Entity types that should never auto-spawn",
          "items": {
            "$ref": "../../codegen/primitives/EntityType.schema.json"
          },
          "type": "array"
        },
        "max_entities_per_segment": {
          "default": 3,
          "description": "Maximum entities to spawn from one segment",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "medium_confidence_threshold": {
          "default": 0.5,
          "description": "Medium confidence threshold (suggest above this)",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    }
  },
  "description": "Input for spawn suggestion tool",
  "properties": {
    "classification": {
      "allOf": [
        {
          "$ref": "#/definitions/EntityClassifierOutput"
        }
      ],
      "description": "Entity classification result"
    },
    "config": {
      "allOf": [
        {
          "$ref": "#/definitions/SpawnConfig"
        }
      ],
      "default": {
        "auto_spawn_enabled": true,
        "high_confidence_threshold": 0.8,
        "low_confidence_threshold": 0.3,
        "manual_only_types": [],
        "max_entities_per_segment": 3,
        "medium_confidence_threshold": 0.5
      },
      "description": "Spawn configuration"
    },
    "segment": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/Segment.schema.json"
        }
      ],
      "description": "Original segment"
    }
  },
  "required": [
    "classification",
    "segment"
  ],
  "title": "SpawnSuggesterInput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "input",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SpawnSuggesterOutput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BindingHints": {
      "description": "Hints for cognitive binding between entities",
      "properties": {
        "binding_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/BindingType.schema.json"
            }
          ],
          "description": "Type of cognitive binding"
        },
        "context": {
          "default": null,
          "description": "Context explaining the binding",
          "type": [
            "string",
            "null"
          ]
        },
        "directionality": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/Directionality.schema.json"
            }
          ],
          "description": "Directionality of binding"
        },
        "source": {
          "allOf": [
            {
              "$ref": "#/definitions/EntityReference"
            }
          ],
          "description": "Source entity"
        },
        "strength": {
          "description": "Strength of binding (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "target": {
          "allOf": [
            {
              "$ref": "#/definitions/EntityReference"
            }
          ],
          "description": "Target entity"
        },
        "temporal": {
          "anyOf": [
            {
              "$ref": "#/definitions/TemporalBinding"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Temporal aspect of binding"
        }
      },
      "required": [
        "binding_type",
        "directionality",
        "source",
        "strength",
        "target"
      ],
      "type": "object"
    },
    "BondHints": {
      "description": "Hints for relationship bonds",
      "properties": {
        "description": {
          "default": null,
          "description": "Description of relationship",
          "type": [
            "string",
            "null"
          ]
        },
        "reciprocity": {
          "default": 0.5,
          "description": "Reciprocity (0.0 one-way to 1.0 mutual)",
          "format": "double",
          "type": "number"
        },
        "relationship_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/RelationshipType.schema.json"
            }
          ],
          "description": "Relationship type"
        },
        "source": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadReference.schema.json"
            }
          ],
          "description": "Source entity (head of relationship)"
        },
        "strength": {
          "description": "Strength of relationship (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "target": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadReference.schema.json"
            }
          ],
          "description": "Target entity (tail of relationship)"
        },
        "valence": {
          "description": "Valence of relationship (-1.0 to 1.0)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "relationship_type",
        "source",
        "strength",
        "target",
        "valence"
      ],
      "type": "object"
    },
    "EntityContent": {
      "description": "Content for the spawned entity",
      "properties": {
        "enriched_text": {
          "default": null,
          "description": "Enriched/contextualized content",
          "type": [
            "string",
            "null"
          ]
        },
        "tags": {
          "default": [],
          "description": "Tags extracted",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "text": {
          "description": "Primary content text",
          "type": "string"
        },
        "title": {
          "default": null,
          "description": "Title/summary",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "text"
      ],
      "type": "object"
    },
    "EntityReference": {
      "description": "Reference to an entity for binding",
      "properties": {
        "description": {
          "description": "Description for matching",
          "type": "string"
        },
        "entity_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/EntityType.schema.json"
            }
          ],
          "description": "Entity type"
        },
        "id": {
          "default": null,
          "description": "Entity ID (if existing)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "description",
        "entity_type"
      ],
      "type": "object"
    },
    "PhysicsHints": {
      "description": "Hints for physics/VAE space positioning",
      "properties": {
        "arousal": {
          "description": "Arousal: 0.0 (calm) to 1.0 (excited/energized)",
          "format": "double",
          "type": "number"
        },
        "certainty": {
          "default": 0.5,
          "description": "Epistemic certainty: 0.0 (uncertain) to 1.0 (certain)",
          "format": "double",
          "type": "number"
        },
        "reasoning": {
          "default": null,
          "description": "Reasoning for physics values",
          "type": [
            "string",
            "null"
          ]
        },
        "significance": {
          "description": "Significance/mass: 0.0 (trivial) to 1.0 (very important)",
          "format": "double",
          "type": "number"
        },
        "valence": {
          "description": "Valence: -1.0 (negative) to 1.0 (positive)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "arousal",
        "significance",
        "valence"
      ],
      "type": "object"
    },
    "SpawnAction": {
      "description": "Action to take for spawn",
      "oneOf": [
        {
          "description": "Auto-spawn without user confirmation",
          "enum": [
            "auto_spawn"
          ],
          "type": "string"
        },
        {
          "description": "Suggest to user for review",
          "enum": [
            "suggest"
          ],
          "type": "string"
        },
        {
          "description": "Skip but log for analysis",
          "enum": [
            "skip"
          ],
          "type": "string"
        },
        {
          "description": "Request clarification from user",
          "enum": [
            "clarify"
          ],
          "type": "string"
        }
      ]
    },
    "SpawnHints": {
      "description": "All hints for a spawned entity",
      "properties": {
        "binding": {
          "anyOf": [
            {
              "$ref": "#/definitions/BindingHints"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Binding hints for cognitive connections"
        },
        "bond": {
          "anyOf": [
            {
              "$ref": "#/definitions/BondHints"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Bond hints for relationships"
        },
        "physics": {
          "allOf": [
            {
              "$ref": "#/definitions/PhysicsHints"
            }
          ],
          "description": "Physics hints for VAE space positioning"
        },
        "thread": {
          "allOf": [
            {
              "$ref": "#/definitions/ThreadHints"
            }
          ],
          "description": "Thread hints for narrative connections"
        }
      },
      "required": [
        "physics",
        "thread"
      ],
      "type": "object"
    },
    "SpawnSuggestion": {
      "description": "A suggestion to spawn an entity",
      "properties": {
        "action": {
          "allOf": [
            {
              "$ref": "#/definitions/SpawnAction"
            }
          ],
          "description": "Spawn action"
        },
        "confidence": {
          "description": "Confidence in this spawn",
          "format": "double",
          "type": "number"
        },
        "content": {
          "allOf": [
            {
              "$ref": "#/definitions/EntityContent"
            }
          ],
          "description": "Content to use for entity"
        },
        "entity_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/EntityType.schema.json"
            }
          ],
          "description": "Entity type to spawn"
        },
        "hints": {
          "allOf": [
            {
              "$ref": "#/definitions/SpawnHints"
            }
          ],
          "description": "All hints for the entity"
        },
        "reason": {
          "description": "Reason for suggestion",
          "type": "string"
        }
      },
      "required": [
        "action",
        "confidence",
        "content",
        "entity_type",
        "hints",
        "reason"
      ],
      "type": "object"
    },
    "SpawnSummary": {
      "description": "Summary of spawn decisions",
      "properties": {
        "auto_spawn_count": {
          "description": "Auto-spawn count",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "primary_type": {
          "anyOf": [
            {
              "$ref": "../../codegen/primitives/EntityType.schema.json"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Primary entity type suggested"
        },
        "review_count": {
          "description": "Needs review count",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "skipped_count": {
          "description": "Skipped count",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        },
        "total_suggestions": {
          "description": "Total suggestions",
          "format": "uint",
          "minimum": 0.0,
          "type": "integer"
        }
      },
      "required": [
        "auto_spawn_count",
        "review_count",
        "skipped_count",
        "total_suggestions"
      ],
      "type": "object"
    },
    "TemporalBinding": {
      "description": "Temporal aspect of binding",
      "properties": {
        "gap": {
          "default": null,
          "description": "Time gap (if known)",
          "type": [
            "string",
            "null"
          ]
        },
        "relation": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/TemporalRelation.schema.json"
            }
          ],
          "description": "Time relationship"
        }
      },
      "required": [
        "relation"
      ],
      "type": "object"
    },
    "ThreadHints": {
      "description": "Hints for thread/narrative connections",
      "properties": {
        "create_if_missing": {
          "default": false,
          "description": "Should create new thread if no match?",
          "type": "boolean"
        },
        "keywords": {
          "default": [],
          "description": "Keywords for thread matching",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "primary_subject": {
          "description": "Primary subject/actor",
          "type": "string"
        },
        "related_threads": {
          "default": [],
          "description": "Related threads to link",
          "items": {
            "$ref": "../../codegen/primitives/ThreadReference.schema.json"
          },
          "type": "array"
        },
        "thread_role": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadRole.schema.json"
            }
          ],
          "description": "Role of entity in narrative"
        }
      },
      "required": [
        "primary_subject",
        "thread_role"
      ],
      "type": "object"
    }
  },
  "description": "Output from spawn suggestion tool",
  "properties": {
    "suggestions": {
      "description": "Entities to spawn",
      "items": {
        "$ref": "#/definitions/SpawnSuggestion"
      },
      "type": "array"
    },
    "summary": {
      "allOf": [
        {
          "$ref": "#/definitions/SpawnSummary"
        }
      ],
      "description": "Overall spawn decision summary"
    }
  },
  "required": [
    "suggestions",
    "summary"
  ],
  "title": "SpawnSuggesterOutput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "output",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SpawnSuggestion.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BindingHints": {
      "description": "Hints for cognitive binding between entities",
      "properties": {
        "binding_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/BindingType.schema.json"
            }
          ],
          "description": "Type of cognitive binding"
        },
        "context": {
          "default": null,
          "description": "Context explaining the binding",
          "type": [
            "string",
            "null"
          ]
        },
        "directionality": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/Directionality.schema.json"
            }
          ],
          "description": "Directionality of binding"
        },
        "source": {
          "allOf": [
            {
              "$ref": "#/definitions/EntityReference"
            }
          ],
          "description": "Source entity"
        },
        "strength": {
          "description": "Strength of binding (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "target": {
          "allOf": [
            {
              "$ref": "#/definitions/EntityReference"
            }
          ],
          "description": "Target entity"
        },
        "temporal": {
          "anyOf": [
            {
              "$ref": "#/definitions/TemporalBinding"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Temporal aspect of binding"
        }
      },
      "required": [
        "binding_type",
        "directionality",
        "source",
        "strength",
        "target"
      ],
      "type": "object"
    },
    "BondHints": {
      "description": "Hints for relationship bonds",
      "properties": {
        "description": {
          "default": null,
          "description": "Description of relationship",
          "type": [
            "string",
            "null"
          ]
        },
        "reciprocity": {
          "default": 0.5,
          "description": "Reciprocity (0.0 one-way to 1.0 mutual)",
          "format": "double",
          "type": "number"
        },
        "relationship_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/RelationshipType.schema.json"
            }
          ],
          "description": "Relationship type"
        },
        "source": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadReference.schema.json"
            }
          ],
          "description": "Source entity (head of relationship)"
        },
        "strength": {
          "description": "Strength of relationship (0.0 to 1.0)",
          "format": "double",
          "type": "number"
        },
        "target": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadReference.schema.json"
            }
          ],
          "description": "Target entity (tail of relationship)"
        },
        "valence": {
          "description": "Valence of relationship (-1.0 to 1.0)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "relationship_type",
        "source",
        "strength",
        "target",
        "valence"
      ],
      "type": "object"
    },
    "EntityContent": {
      "description": "Content for the spawned entity",
      "properties": {
        "enriched_text": {
          "default": null,
          "description": "Enriched/contextualized content",
          "type": [
            "string",
            "null"
          ]
        },
        "tags": {
          "default": [],
          "description": "Tags extracted",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "text": {
          "description": "Primary content text",
          "type": "string"
        },
        "title": {
          "default": null,
          "description": "Title/summary",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "text"
      ],
      "type": "object"
    },
    "EntityReference": {
      "description": "Reference to an entity for binding",
      "properties": {
        "description": {
          "description": "Description for matching",
          "type": "string"
        },
        "entity_type": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/EntityType.schema.json"
            }
          ],
          "description": "Entity type"
        },
        "id": {
          "default": null,
          "description": "Entity ID (if existing)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "description",
        "entity_type"
      ],
      "type": "object"
    },
    "PhysicsHints": {
      "description": "Hints for physics/VAE space positioning",
      "properties": {
        "arousal": {
          "description": "Arousal: 0.0 (calm) to 1.0 (excited/energized)",
          "format": "double",
          "type": "number"
        },
        "certainty": {
          "default": 0.5,
          "description": "Epistemic certainty: 0.0 (uncertain) to 1.0 (certain)",
          "format": "double",
          "type": "number"
        },
        "reasoning": {
          "default": null,
          "description": "Reasoning for physics values",
          "type": [
            "string",
            "null"
          ]
        },
        "significance": {
          "description": "Significance/mass: 0.0 (trivial) to 1.0 (very important)",
          "format": "double",
          "type": "number"
        },
        "valence": {
          "description": "Valence: -1.0 (negative) to 1.0 (positive)",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "arousal",
        "significance",
        "valence"
      ],
      "type": "object"
    },
    "SpawnAction": {
      "description": "Action to take for spawn",
      "oneOf": [
        {
          "description": "Auto-spawn without user confirmation",
          "enum": [
            "auto_spawn"
          ],
          "type": "string"
        },
        {
          "description": "Suggest to user for review",
          "enum": [
            "suggest"
          ],
          "type": "string"
        },
        {
          "description": "Skip but log for analysis",
          "enum": [
            "skip"
          ],
          "type": "string"
        },
        {
          "description": "Request clarification from user",
          "enum": [
            "clarify"
          ],
          "type": "string"
        }
      ]
    },
    "SpawnHints": {
      "description": "All hints for a spawned entity",
      "properties": {
        "binding": {
          "anyOf": [
            {
              "$ref": "#/definitions/BindingHints"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Binding hints for cognitive connections"
        },
        "bond": {
          "anyOf": [
            {
              "$ref": "#/definitions/BondHints"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Bond hints for relationships"
        },
        "physics": {
          "allOf": [
            {
              "$ref": "#/definitions/PhysicsHints"
            }
          ],
          "description": "Physics hints for VAE space positioning"
        },
        "thread": {
          "allOf": [
            {
              "$ref": "#/definitions/ThreadHints"
            }
          ],
          "description": "Thread hints for narrative connections"
        }
      },
      "required": [
        "physics",
        "thread"
      ],
      "type": "object"
    },
    "TemporalBinding": {
      "description": "Temporal aspect of binding",
      "properties": {
        "gap": {
          "default": null,
          "description": "Time gap (if known)",
          "type": [
            "string",
            "null"
          ]
        },
        "relation": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/TemporalRelation.schema.json"
            }
          ],
          "description": "Time relationship"
        }
      },
      "required": [
        "relation"
      ],
      "type": "object"
    },
    "ThreadHints": {
      "description": "Hints for thread/narrative connections",
      "properties": {
        "create_if_missing": {
          "default": false,
          "description": "Should create new thread if no match?",
          "type": "boolean"
        },
        "keywords": {
          "default": [],
          "description": "Keywords for thread matching",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "primary_subject": {
          "description": "Primary subject/actor",
          "type": "string"
        },
        "related_threads": {
          "default": [],
          "description": "Related threads to link",
          "items": {
            "$ref": "../../codegen/primitives/ThreadReference.schema.json"
          },
          "type": "array"
        },
        "thread_role": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadRole.schema.json"
            }
          ],
          "description": "Role of entity in narrative"
        }
      },
      "required": [
        "primary_subject",
        "thread_role"
      ],
      "type": "object"
    }
  },
  "description": "A suggestion to spawn an entity",
  "properties": {
    "action": {
      "allOf": [
        {
          "$ref": "#/definitions/SpawnAction"
        }
      ],
      "description": "Spawn action"
    },
    "confidence": {
      "description": "Confidence in this spawn",
      "format": "double",
      "type": "number"
    },
    "content": {
      "allOf": [
        {
          "$ref": "#/definitions/EntityContent"
        }
      ],
      "description": "Content to use for entity"
    },
    "entity_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/EntityType.schema.json"
        }
      ],
      "description": "Entity type to spawn"
    },
    "hints": {
      "allOf": [
        {
          "$ref": "#/definitions/SpawnHints"
        }
      ],
      "description": "All hints for the entity"
    },
    "reason": {
      "description": "Reason for suggestion",
      "type": "string"
    }
  },
  "required": [
    "action",
    "confidence",
    "content",
    "entity_type",
    "hints",
    "reason"
  ],
  "title": "SpawnSuggestion",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SpawnSummary.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Summary of spawn decisions",
  "properties": {
    "auto_spawn_count": {
      "description": "Auto-spawn count",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "primary_type": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/EntityType.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Primary entity type suggested"
    },
    "review_count": {
      "description": "Needs review count",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "skipped_count": {
      "description": "Skipped count",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    },
    "total_suggestions": {
      "description": "Total suggestions",
      "format": "uint",
      "minimum": 0.0,
      "type": "integer"
    }
  },
  "required": [
    "auto_spawn_count",
    "review_count",
    "skipped_count",
    "total_suggestions"
  ],
  "title": "SpawnSummary",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/StandardPipeline.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ConditionOperator": {
      "description": "Condition operators",
      "enum": [
        "equals",
        "not_equals",
        "greater_than",
        "less_than",
        "contains",
        "not_contains",
        "is_null",
        "is_not_null",
        "in"
      ],
      "type": "string"
    },
    "ConditionType": {
      "description": "Types of conditions",
      "oneOf": [
        {
          "description": "Check output value",
          "enum": [
            "output_value"
          ],
          "type": "string"
        },
        {
          "description": "Check if step succeeded",
          "enum": [
            "step_success"
          ],
          "type": "string"
        },
        {
          "description": "Check if step failed",
          "enum": [
            "step_failed"
          ],
          "type": "string"
        },
        {
          "description": "Check output exists",
          "enum": [
            "output_exists"
          ],
          "type": "string"
        }
      ]
    },
    "ContextStrategy": {
      "description": "How context flows between tools",
      "oneOf": [
        {
          "description": "Pass full context to every tool",
          "enum": [
            "full_context"
          ],
          "type": "string"
        },
        {
          "description": "Only pass relevant context (filtered)",
          "enum": [
            "filtered_context"
          ],
          "type": "string"
        },
        {
          "description": "Accumulate results as context grows",
          "enum": [
            "accumulating_context"
          ],
          "type": "string"
        },
        {
          "description": "Each step gets fresh context",
          "enum": [
            "isolated_context"
          ],
          "type": "string"
        }
      ]
    },
    "ErrorStrategy": {
      "description": "Error handling strategy",
      "oneOf": [
        {
          "description": "Fail the entire chain on any error",
          "enum": [
            "fail_fast"
          ],
          "type": "string"
        },
        {
          "description": "Continue with remaining steps",
          "enum": [
            "continue_on_error"
          ],
          "type": "string"
        },
        {
          "description": "Retry failed steps",
          "enum": [
            "retry_on_error"
          ],
          "type": "string"
        },
        {
          "description": "Use fallback tool",
          "enum": [
            "use_fallback"
          ],
          "type": "string"
        }
      ]
    },
    "ExecutionOrder": {
      "description": "Execution order types",
      "oneOf": [
        {
          "description": "Execute in sequence",
          "enum": [
            "sequential"
          ],
          "type": "string"
        },
        {
          "description": "Execute in parallel with other parallel steps",
          "enum": [
            "parallel"
          ],
          "type": "string"
        },
        {
          "description": "Execute only if condition is met",
          "enum": [
            "conditional"
          ],
          "type": "string"
        },
        {
          "description": "Execute as fallback if previous failed",
          "enum": [
            "fallback"
          ],
          "type": "string"
        }
      ]
    },
    "InputMapping": {
      "description": "Input mapping from previous step output",
      "properties": {
        "from_path": {
          "description": "Path in source output",
          "type": "string"
        },
        "from_step": {
          "description": "Source step ID",
          "type": "string"
        },
        "to_path": {
          "description": "Path in this step's input",
          "type": "string"
        },
        "transform": {
          "anyOf": [
            {
              "$ref": "#/definitions/InputTransform"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Transform to apply"
        }
      },
      "required": [
        "from_path",
        "from_step",
        "to_path"
      ],
      "type": "object"
    },
    "InputTransform": {
      "description": "Transforms for input mapping",
      "oneOf": [
        {
          "description": "Direct pass-through",
          "properties": {
            "type": {
              "enum": [
                "identity"
              ],
              "type": "string"
            }
          },
          "required": [
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Extract array item",
          "properties": {
            "index": {
              "format": "uint",
              "minimum": 0.0,
              "type": "integer"
            },
            "type": {
              "enum": [
                "array_item"
              ],
              "type": "string"
            }
          },
          "required": [
            "index",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Filter array by condition",
          "properties": {
            "path": {
              "type": "string"
            },
            "type": {
              "enum": [
                "array_filter"
              ],
              "type": "string"
            },
            "value": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "type",
            "value"
          ],
          "type": "object"
        },
        {
          "description": "Map array items",
          "properties": {
            "template": {
              "type": "string"
            },
            "type": {
              "enum": [
                "array_map"
              ],
              "type": "string"
            }
          },
          "required": [
            "template",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Concatenate strings",
          "properties": {
            "separator": {
              "type": "string"
            },
            "type": {
              "enum": [
                "concat"
              ],
              "type": "string"
            }
          },
          "required": [
            "separator",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Custom transform function",
          "properties": {
            "function": {
              "type": "string"
            },
            "type": {
              "enum": [
                "custom"
              ],
              "type": "string"
            }
          },
          "required": [
            "function",
            "type"
          ],
          "type": "object"
        }
      ]
    },
    "PipelineTrigger": {
      "description": "Trigger for pipeline selection",
      "properties": {
        "priority": {
          "default": 0,
          "description": "Priority (higher = checked first)",
          "format": "uint32",
          "minimum": 0.0,
          "type": "integer"
        },
        "trigger_type": {
          "allOf": [
            {
              "$ref": "#/definitions/TriggerType"
            }
          ],
          "description": "Trigger type"
        },
        "value": {
          "description": "Value to match",
          "type": "string"
        }
      },
      "required": [
        "trigger_type",
        "value"
      ],
      "type": "object"
    },
    "PipelineType": {
      "description": "Types of standard pipelines",
      "oneOf": [
        {
          "description": "Memory recording: Segment  Classify  Spawn  Hints  Store",
          "enum": [
            "memory_recording"
          ],
          "type": "string"
        },
        {
          "description": "Query: Parse  Search  Format  Return",
          "enum": [
            "query"
          ],
          "type": "string"
        },
        {
          "description": "Analysis: Parse  Search  Analyze  Synthesize",
          "enum": [
            "analysis"
          ],
          "type": "string"
        },
        {
          "description": "Command: Parse  Validate  Execute  Confirm",
          "enum": [
            "command"
          ],
          "type": "string"
        },
        {
          "description": "Conversation: Understand  Respond",
          "enum": [
            "conversation"
          ],
          "type": "string"
        },
        {
          "description": "Multi-modal: Route  Process per modality  Merge",
          "enum": [
            "multi_modal"
          ],
          "type": "string"
        }
      ]
    },
    "StepCondition": {
      "description": "Condition for conditional execution",
      "properties": {
        "condition_type": {
          "allOf": [
            {
              "$ref": "#/definitions/ConditionType"
            }
          ],
          "description": "Type of condition"
        },
        "operator": {
          "allOf": [
            {
              "$ref": "#/definitions/ConditionOperator"
            }
          ],
          "description": "Operator"
        },
        "path": {
          "description": "Path to check",
          "type": "string"
        },
        "source_step": {
          "description": "Source step to check",
          "type": "string"
        },
        "value": {
          "description": "Value to compare"
        }
      },
      "required": [
        "condition_type",
        "operator",
        "path",
        "source_step",
        "value"
      ],
      "type": "object"
    },
    "ToolChain": {
      "description": "A chain of tools to execute",
      "properties": {
        "context_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/ContextStrategy"
            }
          ],
          "description": "How context flows between steps"
        },
        "description": {
          "description": "Description",
          "type": "string"
        },
        "error_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/ErrorStrategy"
            }
          ],
          "description": "Error handling strategy"
        },
        "id": {
          "description": "Chain identifier",
          "type": "string"
        },
        "name": {
          "description": "Human-readable name",
          "type": "string"
        },
        "steps": {
          "description": "Steps in the chain",
          "items": {
            "$ref": "#/definitions/ToolChainStep"
          },
          "type": "array"
        }
      },
      "required": [
        "context_strategy",
        "description",
        "error_strategy",
        "id",
        "name",
        "steps"
      ],
      "type": "object"
    },
    "ToolChainStep": {
      "description": "A step in a tool chain",
      "properties": {
        "condition": {
          "anyOf": [
            {
              "$ref": "#/definitions/StepCondition"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Condition for execution (if conditional)"
        },
        "execution_order": {
          "allOf": [
            {
              "$ref": "#/definitions/ExecutionOrder"
            }
          ],
          "description": "Execution order"
        },
        "id": {
          "description": "Step identifier",
          "type": "string"
        },
        "input_mapping": {
          "default": [],
          "description": "Input mapping from previous steps",
          "items": {
            "$ref": "#/definitions/InputMapping"
          },
          "type": "array"
        },
        "parallel_with": {
          "default": [],
          "description": "Steps to run in parallel with this one",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "required": {
          "default": true,
          "description": "Whether step is required or optional",
          "type": "boolean"
        },
        "timeout_ms": {
          "default": null,
          "description": "Timeout in milliseconds",
          "format": "uint64",
          "minimum": 0.0,
          "type": [
            "integer",
            "null"
          ]
        },
        "tool": {
          "description": "Tool to execute",
          "type": "string"
        }
      },
      "required": [
        "execution_order",
        "id",
        "tool"
      ],
      "type": "object"
    },
    "TriggerType": {
      "description": "Types of triggers",
      "oneOf": [
        {
          "description": "Match on purpose type",
          "enum": [
            "purpose"
          ],
          "type": "string"
        },
        {
          "description": "Match on modality",
          "enum": [
            "modality"
          ],
          "type": "string"
        },
        {
          "description": "Match on entity type",
          "enum": [
            "entity_type"
          ],
          "type": "string"
        },
        {
          "description": "Match on keyword",
          "enum": [
            "keyword"
          ],
          "type": "string"
        },
        {
          "description": "Custom condition",
          "enum": [
            "custom"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Standard processing pipeline definitions",
  "properties": {
    "chain": {
      "allOf": [
        {
          "$ref": "#/definitions/ToolChain"
        }
      ],
      "description": "The tool chain"
    },
    "pipeline_type": {
      "allOf": [
        {
          "$ref": "#/definitions/PipelineType"
        }
      ],
      "description": "Pipeline type"
    },
    "triggers": {
      "description": "When to use this pipeline",
      "items": {
        "$ref": "#/definitions/PipelineTrigger"
      },
      "type": "array"
    }
  },
  "required": [
    "chain",
    "pipeline_type",
    "triggers"
  ],
  "title": "StandardPipeline",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/StepCondition.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ConditionOperator": {
      "description": "Condition operators",
      "enum": [
        "equals",
        "not_equals",
        "greater_than",
        "less_than",
        "contains",
        "not_contains",
        "is_null",
        "is_not_null",
        "in"
      ],
      "type": "string"
    },
    "ConditionType": {
      "description": "Types of conditions",
      "oneOf": [
        {
          "description": "Check output value",
          "enum": [
            "output_value"
          ],
          "type": "string"
        },
        {
          "description": "Check if step succeeded",
          "enum": [
            "step_success"
          ],
          "type": "string"
        },
        {
          "description": "Check if step failed",
          "enum": [
            "step_failed"
          ],
          "type": "string"
        },
        {
          "description": "Check output exists",
          "enum": [
            "output_exists"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Condition for conditional execution",
  "properties": {
    "condition_type": {
      "allOf": [
        {
          "$ref": "#/definitions/ConditionType"
        }
      ],
      "description": "Type of condition"
    },
    "operator": {
      "allOf": [
        {
          "$ref": "#/definitions/ConditionOperator"
        }
      ],
      "description": "Operator"
    },
    "path": {
      "description": "Path to check",
      "type": "string"
    },
    "source_step": {
      "description": "Source step to check",
      "type": "string"
    },
    "value": {
      "description": "Value to compare"
    }
  },
  "required": [
    "condition_type",
    "operator",
    "path",
    "source_step",
    "value"
  ],
  "title": "StepCondition",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SubjectReference.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "SubjectType": {
      "description": "Types of subjects",
      "oneOf": [
        {
          "description": "The user themselves",
          "enum": [
            "self_"
          ],
          "type": "string"
        },
        {
          "description": "Another person",
          "enum": [
            "person"
          ],
          "type": "string"
        },
        {
          "description": "A place",
          "enum": [
            "place"
          ],
          "type": "string"
        },
        {
          "description": "An organization",
          "enum": [
            "organization"
          ],
          "type": "string"
        },
        {
          "description": "A concept/topic",
          "enum": [
            "concept"
          ],
          "type": "string"
        },
        {
          "description": "An event",
          "enum": [
            "event"
          ],
          "type": "string"
        },
        {
          "description": "An object/thing",
          "enum": [
            "object"
          ],
          "type": "string"
        },
        {
          "description": "Unknown/other",
          "enum": [
            "other"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Reference to a subject",
  "properties": {
    "confidence": {
      "description": "Confidence in identification",
      "format": "double",
      "type": "number"
    },
    "name": {
      "description": "Name/label of subject",
      "type": "string"
    },
    "subject_type": {
      "allOf": [
        {
          "$ref": "#/definitions/SubjectType"
        }
      ],
      "description": "Type of subject"
    },
    "thread_id": {
      "default": null,
      "description": "Matched thread ID (if resolved)",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "confidence",
    "name",
    "subject_type"
  ],
  "title": "SubjectReference",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SubjectType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of subjects",
  "oneOf": [
    {
      "description": "The user themselves",
      "enum": [
        "self_"
      ],
      "type": "string"
    },
    {
      "description": "Another person",
      "enum": [
        "person"
      ],
      "type": "string"
    },
    {
      "description": "A place",
      "enum": [
        "place"
      ],
      "type": "string"
    },
    {
      "description": "An organization",
      "enum": [
        "organization"
      ],
      "type": "string"
    },
    {
      "description": "A concept/topic",
      "enum": [
        "concept"
      ],
      "type": "string"
    },
    {
      "description": "An event",
      "enum": [
        "event"
      ],
      "type": "string"
    },
    {
      "description": "An object/thing",
      "enum": [
        "object"
      ],
      "type": "string"
    },
    {
      "description": "Unknown/other",
      "enum": [
        "other"
      ],
      "type": "string"
    }
  ],
  "title": "SubjectType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/SuggestedThread.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "SubjectType": {
      "description": "Types of subjects",
      "oneOf": [
        {
          "description": "The user themselves",
          "enum": [
            "self_"
          ],
          "type": "string"
        },
        {
          "description": "Another person",
          "enum": [
            "person"
          ],
          "type": "string"
        },
        {
          "description": "A place",
          "enum": [
            "place"
          ],
          "type": "string"
        },
        {
          "description": "An organization",
          "enum": [
            "organization"
          ],
          "type": "string"
        },
        {
          "description": "A concept/topic",
          "enum": [
            "concept"
          ],
          "type": "string"
        },
        {
          "description": "An event",
          "enum": [
            "event"
          ],
          "type": "string"
        },
        {
          "description": "An object/thing",
          "enum": [
            "object"
          ],
          "type": "string"
        },
        {
          "description": "Unknown/other",
          "enum": [
            "other"
          ],
          "type": "string"
        }
      ]
    },
    "ThreadCategory": {
      "description": "Categories for threads",
      "oneOf": [
        {
          "description": "People (friends, family, colleagues)",
          "enum": [
            "people"
          ],
          "type": "string"
        },
        {
          "description": "Places (home, work, cities)",
          "enum": [
            "places"
          ],
          "type": "string"
        },
        {
          "description": "Activities (hobbies, work tasks)",
          "enum": [
            "activities"
          ],
          "type": "string"
        },
        {
          "description": "Projects (ongoing endeavors)",
          "enum": [
            "projects"
          ],
          "type": "string"
        },
        {
          "description": "Topics (interests, subjects)",
          "enum": [
            "topics"
          ],
          "type": "string"
        },
        {
          "description": "Events (recurring or one-time)",
          "enum": [
            "events"
          ],
          "type": "string"
        },
        {
          "description": "Groups (teams, organizations)",
          "enum": [
            "groups"
          ],
          "type": "string"
        },
        {
          "description": "Health (physical, mental)",
          "enum": [
            "health"
          ],
          "type": "string"
        },
        {
          "description": "Finance (money, investments)",
          "enum": [
            "finance"
          ],
          "type": "string"
        },
        {
          "description": "Relationships",
          "enum": [
            "relationships"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "A suggested new thread to create",
  "properties": {
    "aliases": {
      "default": [],
      "description": "Aliases to register",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "category": {
      "allOf": [
        {
          "$ref": "#/definitions/ThreadCategory"
        }
      ],
      "description": "Category"
    },
    "confidence": {
      "description": "Confidence in suggestion",
      "format": "double",
      "type": "number"
    },
    "name": {
      "description": "Suggested name",
      "type": "string"
    },
    "reason": {
      "description": "Why this thread should be created",
      "type": "string"
    },
    "thread_type": {
      "allOf": [
        {
          "$ref": "#/definitions/SubjectType"
        }
      ],
      "description": "Type of thread"
    }
  },
  "required": [
    "category",
    "confidence",
    "name",
    "reason",
    "thread_type"
  ],
  "title": "SuggestedThread",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/TemporalBinding.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Temporal aspect of binding",
  "properties": {
    "gap": {
      "default": null,
      "description": "Time gap (if known)",
      "type": [
        "string",
        "null"
      ]
    },
    "relation": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/TemporalRelation.schema.json"
        }
      ],
      "description": "Time relationship"
    }
  },
  "required": [
    "relation"
  ],
  "title": "TemporalBinding",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/TemporalMarker.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A temporal marker in the segment",
  "properties": {
    "marker_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/TemporalMarkerType.schema.json"
        }
      ],
      "description": "Type of temporal reference"
    },
    "parsed": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/ParsedTemporal.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Parsed temporal value (if parseable)"
    },
    "text": {
      "description": "The text of the marker",
      "type": "string"
    }
  },
  "required": [
    "marker_type",
    "text"
  ],
  "title": "TemporalMarker",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/TemporalMarkerType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of temporal markers",
  "oneOf": [
    {
      "description": "Specific date (January 5th)",
      "enum": [
        "absolute"
      ],
      "type": "string"
    },
    {
      "description": "Relative reference (yesterday, last week)",
      "enum": [
        "relative"
      ],
      "type": "string"
    },
    {
      "description": "Duration (for 2 hours)",
      "enum": [
        "duration"
      ],
      "type": "string"
    },
    {
      "description": "Frequency (every day, weekly)",
      "enum": [
        "frequency"
      ],
      "type": "string"
    },
    {
      "description": "Time of day (in the morning)",
      "enum": [
        "time_of_day"
      ],
      "type": "string"
    }
  ],
  "title": "TemporalMarkerType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/TemporalProperties.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Temporal properties of binding",
  "properties": {
    "gap": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/TimeGap.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Time gap between entities"
    },
    "recurring": {
      "default": false,
      "description": "Is this a recurring pattern?",
      "type": "boolean"
    },
    "relation": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/TemporalRelation.schema.json"
        }
      ],
      "description": "Time relation"
    }
  },
  "required": [
    "relation"
  ],
  "title": "TemporalProperties",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/TemporalRelation.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Temporal relationships",
  "enum": [
    "before",
    "after",
    "during",
    "simultaneous",
    "overlapping"
  ],
  "title": "TemporalRelation",
  "type": "string",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/TemporalScope.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Temporal scope for queries",
  "properties": {
    "end": {
      "default": null,
      "description": "End of range",
      "type": [
        "string",
        "null"
      ]
    },
    "relative": {
      "default": null,
      "description": "Relative scope (today, this_week, all_time)",
      "type": [
        "string",
        "null"
      ]
    },
    "start": {
      "default": null,
      "description": "Start of range (ISO 8601 or relative)",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "title": "TemporalScope",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ThreadCategory.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Categories for threads",
  "oneOf": [
    {
      "description": "People (friends, family, colleagues)",
      "enum": [
        "people"
      ],
      "type": "string"
    },
    {
      "description": "Places (home, work, cities)",
      "enum": [
        "places"
      ],
      "type": "string"
    },
    {
      "description": "Activities (hobbies, work tasks)",
      "enum": [
        "activities"
      ],
      "type": "string"
    },
    {
      "description": "Projects (ongoing endeavors)",
      "enum": [
        "projects"
      ],
      "type": "string"
    },
    {
      "description": "Topics (interests, subjects)",
      "enum": [
        "topics"
      ],
      "type": "string"
    },
    {
      "description": "Events (recurring or one-time)",
      "enum": [
        "events"
      ],
      "type": "string"
    },
    {
      "description": "Groups (teams, organizations)",
      "enum": [
        "groups"
      ],
      "type": "string"
    },
    {
      "description": "Health (physical, mental)",
      "enum": [
        "health"
      ],
      "type": "string"
    },
    {
      "description": "Finance (money, investments)",
      "enum": [
        "finance"
      ],
      "type": "string"
    },
    {
      "description": "Relationships",
      "enum": [
        "relationships"
      ],
      "type": "string"
    }
  ],
  "title": "ThreadCategory",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ThreadHintInput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "RecentThread": {
      "description": "A recently referenced thread",
      "properties": {
        "mention_count": {
          "description": "Mention count in recent context",
          "format": "uint32",
          "minimum": 0.0,
          "type": "integer"
        },
        "recency": {
          "description": "How recently mentioned (in messages)",
          "format": "uint32",
          "minimum": 0.0,
          "type": "integer"
        },
        "thread": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadReference.schema.json"
            }
          ],
          "description": "Thread reference"
        }
      },
      "required": [
        "mention_count",
        "recency",
        "thread"
      ],
      "type": "object"
    }
  },
  "description": "Input for thread hint generation",
  "properties": {
    "entity_type": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/EntityType.schema.json"
        }
      ],
      "description": "Entity type being spawned"
    },
    "known_threads": {
      "default": [],
      "description": "Known threads for matching",
      "items": {
        "$ref": "../../codegen/primitives/ThreadReference.schema.json"
      },
      "type": "array"
    },
    "recent_threads": {
      "default": [],
      "description": "Recent threads for context",
      "items": {
        "$ref": "#/definitions/RecentThread"
      },
      "type": "array"
    },
    "segment": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/Segment.schema.json"
        }
      ],
      "description": "The segment to analyze"
    }
  },
  "required": [
    "entity_type",
    "segment"
  ],
  "title": "ThreadHintInput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "input",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ThreadHintOutput.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "DetectedThread": {
      "description": "A detected thread reference",
      "properties": {
        "confidence": {
          "description": "Confidence in match",
          "format": "double",
          "type": "number"
        },
        "detection_method": {
          "allOf": [
            {
              "$ref": "#/definitions/DetectionMethod"
            }
          ],
          "description": "How it was detected"
        },
        "role": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadRole.schema.json"
            }
          ],
          "description": "Role in this entity"
        },
        "thread": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadReference.schema.json"
            }
          ],
          "description": "The matched thread"
        },
        "trigger_text": {
          "description": "Text that triggered detection",
          "type": "string"
        }
      },
      "required": [
        "confidence",
        "detection_method",
        "role",
        "thread",
        "trigger_text"
      ],
      "type": "object"
    },
    "DetectionMethod": {
      "description": "How a thread was detected",
      "oneOf": [
        {
          "description": "Exact name match",
          "enum": [
            "exact_match"
          ],
          "type": "string"
        },
        {
          "description": "Alias match",
          "enum": [
            "alias_match"
          ],
          "type": "string"
        },
        {
          "description": "Fuzzy/similar match",
          "enum": [
            "fuzzy_match"
          ],
          "type": "string"
        },
        {
          "description": "Pronoun resolution from context",
          "enum": [
            "pronoun_resolution"
          ],
          "type": "string"
        },
        {
          "description": "Keyword match",
          "enum": [
            "keyword_match"
          ],
          "type": "string"
        },
        {
          "description": "Semantic similarity",
          "enum": [
            "semantic_match"
          ],
          "type": "string"
        }
      ]
    },
    "SubjectReference": {
      "description": "Reference to a subject",
      "properties": {
        "confidence": {
          "description": "Confidence in identification",
          "format": "double",
          "type": "number"
        },
        "name": {
          "description": "Name/label of subject",
          "type": "string"
        },
        "subject_type": {
          "allOf": [
            {
              "$ref": "#/definitions/SubjectType"
            }
          ],
          "description": "Type of subject"
        },
        "thread_id": {
          "default": null,
          "description": "Matched thread ID (if resolved)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "confidence",
        "name",
        "subject_type"
      ],
      "type": "object"
    },
    "SubjectType": {
      "description": "Types of subjects",
      "oneOf": [
        {
          "description": "The user themselves",
          "enum": [
            "self_"
          ],
          "type": "string"
        },
        {
          "description": "Another person",
          "enum": [
            "person"
          ],
          "type": "string"
        },
        {
          "description": "A place",
          "enum": [
            "place"
          ],
          "type": "string"
        },
        {
          "description": "An organization",
          "enum": [
            "organization"
          ],
          "type": "string"
        },
        {
          "description": "A concept/topic",
          "enum": [
            "concept"
          ],
          "type": "string"
        },
        {
          "description": "An event",
          "enum": [
            "event"
          ],
          "type": "string"
        },
        {
          "description": "An object/thing",
          "enum": [
            "object"
          ],
          "type": "string"
        },
        {
          "description": "Unknown/other",
          "enum": [
            "other"
          ],
          "type": "string"
        }
      ]
    },
    "SuggestedThread": {
      "description": "A suggested new thread to create",
      "properties": {
        "aliases": {
          "default": [],
          "description": "Aliases to register",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "category": {
          "allOf": [
            {
              "$ref": "#/definitions/ThreadCategory"
            }
          ],
          "description": "Category"
        },
        "confidence": {
          "description": "Confidence in suggestion",
          "format": "double",
          "type": "number"
        },
        "name": {
          "description": "Suggested name",
          "type": "string"
        },
        "reason": {
          "description": "Why this thread should be created",
          "type": "string"
        },
        "thread_type": {
          "allOf": [
            {
              "$ref": "#/definitions/SubjectType"
            }
          ],
          "description": "Type of thread"
        }
      },
      "required": [
        "category",
        "confidence",
        "name",
        "reason",
        "thread_type"
      ],
      "type": "object"
    },
    "ThreadCategory": {
      "description": "Categories for threads",
      "oneOf": [
        {
          "description": "People (friends, family, colleagues)",
          "enum": [
            "people"
          ],
          "type": "string"
        },
        {
          "description": "Places (home, work, cities)",
          "enum": [
            "places"
          ],
          "type": "string"
        },
        {
          "description": "Activities (hobbies, work tasks)",
          "enum": [
            "activities"
          ],
          "type": "string"
        },
        {
          "description": "Projects (ongoing endeavors)",
          "enum": [
            "projects"
          ],
          "type": "string"
        },
        {
          "description": "Topics (interests, subjects)",
          "enum": [
            "topics"
          ],
          "type": "string"
        },
        {
          "description": "Events (recurring or one-time)",
          "enum": [
            "events"
          ],
          "type": "string"
        },
        {
          "description": "Groups (teams, organizations)",
          "enum": [
            "groups"
          ],
          "type": "string"
        },
        {
          "description": "Health (physical, mental)",
          "enum": [
            "health"
          ],
          "type": "string"
        },
        {
          "description": "Finance (money, investments)",
          "enum": [
            "finance"
          ],
          "type": "string"
        },
        {
          "description": "Relationships",
          "enum": [
            "relationships"
          ],
          "type": "string"
        }
      ]
    },
    "ThreadHintValues": {
      "description": "Thread hint values",
      "properties": {
        "categories": {
          "default": [],
          "description": "Thread categories",
          "items": {
            "$ref": "#/definitions/ThreadCategory"
          },
          "type": "array"
        },
        "create_if_missing": {
          "default": false,
          "description": "Whether to create thread if no match found",
          "type": "boolean"
        },
        "keywords": {
          "default": [],
          "description": "Keywords for thread matching",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "primary_subject": {
          "allOf": [
            {
              "$ref": "#/definitions/SubjectReference"
            }
          ],
          "description": "Primary subject/actor (who/what is the main focus)"
        },
        "related_threads": {
          "default": [],
          "description": "Related threads",
          "items": {
            "$ref": "../../codegen/primitives/ThreadReference.schema.json"
          },
          "type": "array"
        },
        "thread_role": {
          "allOf": [
            {
              "$ref": "../../codegen/primitives/ThreadRole.schema.json"
            }
          ],
          "description": "Role of entity relative to thread"
        }
      },
      "required": [
        "primary_subject",
        "thread_role"
      ],
      "type": "object"
    }
  },
  "description": "Output from thread hint generation",
  "properties": {
    "detected_threads": {
      "description": "Detected thread references",
      "items": {
        "$ref": "#/definitions/DetectedThread"
      },
      "type": "array"
    },
    "hints": {
      "allOf": [
        {
          "$ref": "#/definitions/ThreadHintValues"
        }
      ],
      "description": "Thread hints"
    },
    "suggested_threads": {
      "default": [],
      "description": "Suggested new threads to create",
      "items": {
        "$ref": "#/definitions/SuggestedThread"
      },
      "type": "array"
    }
  },
  "required": [
    "detected_threads",
    "hints"
  ],
  "title": "ThreadHintOutput",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-role": "output",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ThreadHintValues.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "SubjectReference": {
      "description": "Reference to a subject",
      "properties": {
        "confidence": {
          "description": "Confidence in identification",
          "format": "double",
          "type": "number"
        },
        "name": {
          "description": "Name/label of subject",
          "type": "string"
        },
        "subject_type": {
          "allOf": [
            {
              "$ref": "#/definitions/SubjectType"
            }
          ],
          "description": "Type of subject"
        },
        "thread_id": {
          "default": null,
          "description": "Matched thread ID (if resolved)",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "confidence",
        "name",
        "subject_type"
      ],
      "type": "object"
    },
    "SubjectType": {
      "description": "Types of subjects",
      "oneOf": [
        {
          "description": "The user themselves",
          "enum": [
            "self_"
          ],
          "type": "string"
        },
        {
          "description": "Another person",
          "enum": [
            "person"
          ],
          "type": "string"
        },
        {
          "description": "A place",
          "enum": [
            "place"
          ],
          "type": "string"
        },
        {
          "description": "An organization",
          "enum": [
            "organization"
          ],
          "type": "string"
        },
        {
          "description": "A concept/topic",
          "enum": [
            "concept"
          ],
          "type": "string"
        },
        {
          "description": "An event",
          "enum": [
            "event"
          ],
          "type": "string"
        },
        {
          "description": "An object/thing",
          "enum": [
            "object"
          ],
          "type": "string"
        },
        {
          "description": "Unknown/other",
          "enum": [
            "other"
          ],
          "type": "string"
        }
      ]
    },
    "ThreadCategory": {
      "description": "Categories for threads",
      "oneOf": [
        {
          "description": "People (friends, family, colleagues)",
          "enum": [
            "people"
          ],
          "type": "string"
        },
        {
          "description": "Places (home, work, cities)",
          "enum": [
            "places"
          ],
          "type": "string"
        },
        {
          "description": "Activities (hobbies, work tasks)",
          "enum": [
            "activities"
          ],
          "type": "string"
        },
        {
          "description": "Projects (ongoing endeavors)",
          "enum": [
            "projects"
          ],
          "type": "string"
        },
        {
          "description": "Topics (interests, subjects)",
          "enum": [
            "topics"
          ],
          "type": "string"
        },
        {
          "description": "Events (recurring or one-time)",
          "enum": [
            "events"
          ],
          "type": "string"
        },
        {
          "description": "Groups (teams, organizations)",
          "enum": [
            "groups"
          ],
          "type": "string"
        },
        {
          "description": "Health (physical, mental)",
          "enum": [
            "health"
          ],
          "type": "string"
        },
        {
          "description": "Finance (money, investments)",
          "enum": [
            "finance"
          ],
          "type": "string"
        },
        {
          "description": "Relationships",
          "enum": [
            "relationships"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Thread hint values",
  "properties": {
    "categories": {
      "default": [],
      "description": "Thread categories",
      "items": {
        "$ref": "#/definitions/ThreadCategory"
      },
      "type": "array"
    },
    "create_if_missing": {
      "default": false,
      "description": "Whether to create thread if no match found",
      "type": "boolean"
    },
    "keywords": {
      "default": [],
      "description": "Keywords for thread matching",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "primary_subject": {
      "allOf": [
        {
          "$ref": "#/definitions/SubjectReference"
        }
      ],
      "description": "Primary subject/actor (who/what is the main focus)"
    },
    "related_threads": {
      "default": [],
      "description": "Related threads",
      "items": {
        "$ref": "../../codegen/primitives/ThreadReference.schema.json"
      },
      "type": "array"
    },
    "thread_role": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/ThreadRole.schema.json"
        }
      ],
      "description": "Role of entity relative to thread"
    }
  },
  "required": [
    "primary_subject",
    "thread_role"
  ],
  "title": "ThreadHintValues",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ThreadHints.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Hints for thread/narrative connections",
  "properties": {
    "create_if_missing": {
      "default": false,
      "description": "Should create new thread if no match?",
      "type": "boolean"
    },
    "keywords": {
      "default": [],
      "description": "Keywords for thread matching",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "primary_subject": {
      "description": "Primary subject/actor",
      "type": "string"
    },
    "related_threads": {
      "default": [],
      "description": "Related threads to link",
      "items": {
        "$ref": "../../codegen/primitives/ThreadReference.schema.json"
      },
      "type": "array"
    },
    "thread_role": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/ThreadRole.schema.json"
        }
      ],
      "description": "Role of entity in narrative"
    }
  },
  "required": [
    "primary_subject",
    "thread_role"
  ],
  "title": "ThreadHints",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ThreadReference.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Reference to an existing thread",
  "properties": {
    "aliases": {
      "default": [],
      "description": "Aliases for matching",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "id": {
      "description": "Thread ID",
      "type": "string"
    },
    "name": {
      "description": "Thread name/label",
      "type": "string"
    },
    "thread_type": {
      "description": "Thread type (person, place, concept, etc.)",
      "type": "string"
    }
  },
  "required": [
    "id",
    "name",
    "thread_type"
  ],
  "title": "ThreadReference",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ThreadRelation.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ThreadRelationType": {
      "description": "Types of thread relations",
      "oneOf": [
        {
          "description": "Part of (belongs to)",
          "enum": [
            "part_of"
          ],
          "type": "string"
        },
        {
          "description": "Contains (has parts)",
          "enum": [
            "contains"
          ],
          "type": "string"
        },
        {
          "description": "Related to (general association)",
          "enum": [
            "related_to"
          ],
          "type": "string"
        },
        {
          "description": "Causes / leads to",
          "enum": [
            "causes_of"
          ],
          "type": "string"
        },
        {
          "description": "Opposite of",
          "enum": [
            "opposite_of"
          ],
          "type": "string"
        },
        {
          "description": "Same as (alias)",
          "enum": [
            "same_as"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Thread relationship in the graph",
  "properties": {
    "relation_type": {
      "allOf": [
        {
          "$ref": "#/definitions/ThreadRelationType"
        }
      ],
      "description": "Type of relation"
    },
    "source_id": {
      "description": "Source thread",
      "type": "string"
    },
    "strength": {
      "description": "Strength (0.0 to 1.0)",
      "format": "double",
      "type": "number"
    },
    "target_id": {
      "description": "Target thread",
      "type": "string"
    }
  },
  "required": [
    "relation_type",
    "source_id",
    "strength",
    "target_id"
  ],
  "title": "ThreadRelation",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ThreadRelationType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of thread relations",
  "oneOf": [
    {
      "description": "Part of (belongs to)",
      "enum": [
        "part_of"
      ],
      "type": "string"
    },
    {
      "description": "Contains (has parts)",
      "enum": [
        "contains"
      ],
      "type": "string"
    },
    {
      "description": "Related to (general association)",
      "enum": [
        "related_to"
      ],
      "type": "string"
    },
    {
      "description": "Causes / leads to",
      "enum": [
        "causes_of"
      ],
      "type": "string"
    },
    {
      "description": "Opposite of",
      "enum": [
        "opposite_of"
      ],
      "type": "string"
    },
    {
      "description": "Same as (alias)",
      "enum": [
        "same_as"
      ],
      "type": "string"
    }
  ],
  "title": "ThreadRelationType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ThreadRole.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Role of entity relative to threads",
  "oneOf": [
    {
      "description": "Entity is the actor/doer",
      "enum": [
        "actor"
      ],
      "type": "string"
    },
    {
      "description": "Entity is the subject being discussed",
      "enum": [
        "subject"
      ],
      "type": "string"
    },
    {
      "description": "Entity is observing/witnessing",
      "enum": [
        "observer"
      ],
      "type": "string"
    },
    {
      "description": "Entity is the target of action",
      "enum": [
        "target"
      ],
      "type": "string"
    },
    {
      "description": "Entity is setting/location",
      "enum": [
        "setting"
      ],
      "type": "string"
    },
    {
      "description": "Entity is an instrument/tool",
      "enum": [
        "instrument"
      ],
      "type": "string"
    }
  ],
  "title": "ThreadRole",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/TimeGap.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Time gap between entities",
  "properties": {
    "approximate": {
      "description": "Is this approximate?",
      "type": "boolean"
    },
    "unit": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/TimeUnit.schema.json"
        }
      ],
      "description": "Duration unit"
    },
    "value": {
      "description": "Duration value",
      "format": "double",
      "type": "number"
    }
  },
  "required": [
    "approximate",
    "unit",
    "value"
  ],
  "title": "TimeGap",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/TimeUnit.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Time units",
  "enum": [
    "seconds",
    "minutes",
    "hours",
    "days",
    "weeks",
    "months",
    "years"
  ],
  "title": "TimeUnit",
  "type": "string",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ToolCategory.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Categories of tools",
  "oneOf": [
    {
      "description": "Segmentation tools (break input into units)",
      "enum": [
        "segmentation"
      ],
      "type": "string"
    },
    {
      "description": "Classification tools (label content)",
      "enum": [
        "classification"
      ],
      "type": "string"
    },
    {
      "description": "Spawn tools (create entities)",
      "enum": [
        "spawn"
      ],
      "type": "string"
    },
    {
      "description": "Hint generation tools",
      "enum": [
        "hints"
      ],
      "type": "string"
    },
    {
      "description": "Search and retrieval tools",
      "enum": [
        "retrieval"
      ],
      "type": "string"
    },
    {
      "description": "Orchestration tools",
      "enum": [
        "orchestration"
      ],
      "type": "string"
    }
  ],
  "title": "ToolCategory",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ToolChain.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ConditionOperator": {
      "description": "Condition operators",
      "enum": [
        "equals",
        "not_equals",
        "greater_than",
        "less_than",
        "contains",
        "not_contains",
        "is_null",
        "is_not_null",
        "in"
      ],
      "type": "string"
    },
    "ConditionType": {
      "description": "Types of conditions",
      "oneOf": [
        {
          "description": "Check output value",
          "enum": [
            "output_value"
          ],
          "type": "string"
        },
        {
          "description": "Check if step succeeded",
          "enum": [
            "step_success"
          ],
          "type": "string"
        },
        {
          "description": "Check if step failed",
          "enum": [
            "step_failed"
          ],
          "type": "string"
        },
        {
          "description": "Check output exists",
          "enum": [
            "output_exists"
          ],
          "type": "string"
        }
      ]
    },
    "ContextStrategy": {
      "description": "How context flows between tools",
      "oneOf": [
        {
          "description": "Pass full context to every tool",
          "enum": [
            "full_context"
          ],
          "type": "string"
        },
        {
          "description": "Only pass relevant context (filtered)",
          "enum": [
            "filtered_context"
          ],
          "type": "string"
        },
        {
          "description": "Accumulate results as context grows",
          "enum": [
            "accumulating_context"
          ],
          "type": "string"
        },
        {
          "description": "Each step gets fresh context",
          "enum": [
            "isolated_context"
          ],
          "type": "string"
        }
      ]
    },
    "ErrorStrategy": {
      "description": "Error handling strategy",
      "oneOf": [
        {
          "description": "Fail the entire chain on any error",
          "enum": [
            "fail_fast"
          ],
          "type": "string"
        },
        {
          "description": "Continue with remaining steps",
          "enum": [
            "continue_on_error"
          ],
          "type": "string"
        },
        {
          "description": "Retry failed steps",
          "enum": [
            "retry_on_error"
          ],
          "type": "string"
        },
        {
          "description": "Use fallback tool",
          "enum": [
            "use_fallback"
          ],
          "type": "string"
        }
      ]
    },
    "ExecutionOrder": {
      "description": "Execution order types",
      "oneOf": [
        {
          "description": "Execute in sequence",
          "enum": [
            "sequential"
          ],
          "type": "string"
        },
        {
          "description": "Execute in parallel with other parallel steps",
          "enum": [
            "parallel"
          ],
          "type": "string"
        },
        {
          "description": "Execute only if condition is met",
          "enum": [
            "conditional"
          ],
          "type": "string"
        },
        {
          "description": "Execute as fallback if previous failed",
          "enum": [
            "fallback"
          ],
          "type": "string"
        }
      ]
    },
    "InputMapping": {
      "description": "Input mapping from previous step output",
      "properties": {
        "from_path": {
          "description": "Path in source output",
          "type": "string"
        },
        "from_step": {
          "description": "Source step ID",
          "type": "string"
        },
        "to_path": {
          "description": "Path in this step's input",
          "type": "string"
        },
        "transform": {
          "anyOf": [
            {
              "$ref": "#/definitions/InputTransform"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Transform to apply"
        }
      },
      "required": [
        "from_path",
        "from_step",
        "to_path"
      ],
      "type": "object"
    },
    "InputTransform": {
      "description": "Transforms for input mapping",
      "oneOf": [
        {
          "description": "Direct pass-through",
          "properties": {
            "type": {
              "enum": [
                "identity"
              ],
              "type": "string"
            }
          },
          "required": [
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Extract array item",
          "properties": {
            "index": {
              "format": "uint",
              "minimum": 0.0,
              "type": "integer"
            },
            "type": {
              "enum": [
                "array_item"
              ],
              "type": "string"
            }
          },
          "required": [
            "index",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Filter array by condition",
          "properties": {
            "path": {
              "type": "string"
            },
            "type": {
              "enum": [
                "array_filter"
              ],
              "type": "string"
            },
            "value": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "type",
            "value"
          ],
          "type": "object"
        },
        {
          "description": "Map array items",
          "properties": {
            "template": {
              "type": "string"
            },
            "type": {
              "enum": [
                "array_map"
              ],
              "type": "string"
            }
          },
          "required": [
            "template",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Concatenate strings",
          "properties": {
            "separator": {
              "type": "string"
            },
            "type": {
              "enum": [
                "concat"
              ],
              "type": "string"
            }
          },
          "required": [
            "separator",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Custom transform function",
          "properties": {
            "function": {
              "type": "string"
            },
            "type": {
              "enum": [
                "custom"
              ],
              "type": "string"
            }
          },
          "required": [
            "function",
            "type"
          ],
          "type": "object"
        }
      ]
    },
    "StepCondition": {
      "description": "Condition for conditional execution",
      "properties": {
        "condition_type": {
          "allOf": [
            {
              "$ref": "#/definitions/ConditionType"
            }
          ],
          "description": "Type of condition"
        },
        "operator": {
          "allOf": [
            {
              "$ref": "#/definitions/ConditionOperator"
            }
          ],
          "description": "Operator"
        },
        "path": {
          "description": "Path to check",
          "type": "string"
        },
        "source_step": {
          "description": "Source step to check",
          "type": "string"
        },
        "value": {
          "description": "Value to compare"
        }
      },
      "required": [
        "condition_type",
        "operator",
        "path",
        "source_step",
        "value"
      ],
      "type": "object"
    },
    "ToolChainStep": {
      "description": "A step in a tool chain",
      "properties": {
        "condition": {
          "anyOf": [
            {
              "$ref": "#/definitions/StepCondition"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Condition for execution (if conditional)"
        },
        "execution_order": {
          "allOf": [
            {
              "$ref": "#/definitions/ExecutionOrder"
            }
          ],
          "description": "Execution order"
        },
        "id": {
          "description": "Step identifier",
          "type": "string"
        },
        "input_mapping": {
          "default": [],
          "description": "Input mapping from previous steps",
          "items": {
            "$ref": "#/definitions/InputMapping"
          },
          "type": "array"
        },
        "parallel_with": {
          "default": [],
          "description": "Steps to run in parallel with this one",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "required": {
          "default": true,
          "description": "Whether step is required or optional",
          "type": "boolean"
        },
        "timeout_ms": {
          "default": null,
          "description": "Timeout in milliseconds",
          "format": "uint64",
          "minimum": 0.0,
          "type": [
            "integer",
            "null"
          ]
        },
        "tool": {
          "description": "Tool to execute",
          "type": "string"
        }
      },
      "required": [
        "execution_order",
        "id",
        "tool"
      ],
      "type": "object"
    }
  },
  "description": "A chain of tools to execute",
  "properties": {
    "context_strategy": {
      "allOf": [
        {
          "$ref": "#/definitions/ContextStrategy"
        }
      ],
      "description": "How context flows between steps"
    },
    "description": {
      "description": "Description",
      "type": "string"
    },
    "error_strategy": {
      "allOf": [
        {
          "$ref": "#/definitions/ErrorStrategy"
        }
      ],
      "description": "Error handling strategy"
    },
    "id": {
      "description": "Chain identifier",
      "type": "string"
    },
    "name": {
      "description": "Human-readable name",
      "type": "string"
    },
    "steps": {
      "description": "Steps in the chain",
      "items": {
        "$ref": "#/definitions/ToolChainStep"
      },
      "type": "array"
    }
  },
  "required": [
    "context_strategy",
    "description",
    "error_strategy",
    "id",
    "name",
    "steps"
  ],
  "title": "ToolChain",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ToolChainStep.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ConditionOperator": {
      "description": "Condition operators",
      "enum": [
        "equals",
        "not_equals",
        "greater_than",
        "less_than",
        "contains",
        "not_contains",
        "is_null",
        "is_not_null",
        "in"
      ],
      "type": "string"
    },
    "ConditionType": {
      "description": "Types of conditions",
      "oneOf": [
        {
          "description": "Check output value",
          "enum": [
            "output_value"
          ],
          "type": "string"
        },
        {
          "description": "Check if step succeeded",
          "enum": [
            "step_success"
          ],
          "type": "string"
        },
        {
          "description": "Check if step failed",
          "enum": [
            "step_failed"
          ],
          "type": "string"
        },
        {
          "description": "Check output exists",
          "enum": [
            "output_exists"
          ],
          "type": "string"
        }
      ]
    },
    "ExecutionOrder": {
      "description": "Execution order types",
      "oneOf": [
        {
          "description": "Execute in sequence",
          "enum": [
            "sequential"
          ],
          "type": "string"
        },
        {
          "description": "Execute in parallel with other parallel steps",
          "enum": [
            "parallel"
          ],
          "type": "string"
        },
        {
          "description": "Execute only if condition is met",
          "enum": [
            "conditional"
          ],
          "type": "string"
        },
        {
          "description": "Execute as fallback if previous failed",
          "enum": [
            "fallback"
          ],
          "type": "string"
        }
      ]
    },
    "InputMapping": {
      "description": "Input mapping from previous step output",
      "properties": {
        "from_path": {
          "description": "Path in source output",
          "type": "string"
        },
        "from_step": {
          "description": "Source step ID",
          "type": "string"
        },
        "to_path": {
          "description": "Path in this step's input",
          "type": "string"
        },
        "transform": {
          "anyOf": [
            {
              "$ref": "#/definitions/InputTransform"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Transform to apply"
        }
      },
      "required": [
        "from_path",
        "from_step",
        "to_path"
      ],
      "type": "object"
    },
    "InputTransform": {
      "description": "Transforms for input mapping",
      "oneOf": [
        {
          "description": "Direct pass-through",
          "properties": {
            "type": {
              "enum": [
                "identity"
              ],
              "type": "string"
            }
          },
          "required": [
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Extract array item",
          "properties": {
            "index": {
              "format": "uint",
              "minimum": 0.0,
              "type": "integer"
            },
            "type": {
              "enum": [
                "array_item"
              ],
              "type": "string"
            }
          },
          "required": [
            "index",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Filter array by condition",
          "properties": {
            "path": {
              "type": "string"
            },
            "type": {
              "enum": [
                "array_filter"
              ],
              "type": "string"
            },
            "value": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "type",
            "value"
          ],
          "type": "object"
        },
        {
          "description": "Map array items",
          "properties": {
            "template": {
              "type": "string"
            },
            "type": {
              "enum": [
                "array_map"
              ],
              "type": "string"
            }
          },
          "required": [
            "template",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Concatenate strings",
          "properties": {
            "separator": {
              "type": "string"
            },
            "type": {
              "enum": [
                "concat"
              ],
              "type": "string"
            }
          },
          "required": [
            "separator",
            "type"
          ],
          "type": "object"
        },
        {
          "description": "Custom transform function",
          "properties": {
            "function": {
              "type": "string"
            },
            "type": {
              "enum": [
                "custom"
              ],
              "type": "string"
            }
          },
          "required": [
            "function",
            "type"
          ],
          "type": "object"
        }
      ]
    },
    "StepCondition": {
      "description": "Condition for conditional execution",
      "properties": {
        "condition_type": {
          "allOf": [
            {
              "$ref": "#/definitions/ConditionType"
            }
          ],
          "description": "Type of condition"
        },
        "operator": {
          "allOf": [
            {
              "$ref": "#/definitions/ConditionOperator"
            }
          ],
          "description": "Operator"
        },
        "path": {
          "description": "Path to check",
          "type": "string"
        },
        "source_step": {
          "description": "Source step to check",
          "type": "string"
        },
        "value": {
          "description": "Value to compare"
        }
      },
      "required": [
        "condition_type",
        "operator",
        "path",
        "source_step",
        "value"
      ],
      "type": "object"
    }
  },
  "description": "A step in a tool chain",
  "properties": {
    "condition": {
      "anyOf": [
        {
          "$ref": "#/definitions/StepCondition"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Condition for execution (if conditional)"
    },
    "execution_order": {
      "allOf": [
        {
          "$ref": "#/definitions/ExecutionOrder"
        }
      ],
      "description": "Execution order"
    },
    "id": {
      "description": "Step identifier",
      "type": "string"
    },
    "input_mapping": {
      "default": [],
      "description": "Input mapping from previous steps",
      "items": {
        "$ref": "#/definitions/InputMapping"
      },
      "type": "array"
    },
    "parallel_with": {
      "default": [],
      "description": "Steps to run in parallel with this one",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "required": {
      "default": true,
      "description": "Whether step is required or optional",
      "type": "boolean"
    },
    "timeout_ms": {
      "default": null,
      "description": "Timeout in milliseconds",
      "format": "uint64",
      "minimum": 0.0,
      "type": [
        "integer",
        "null"
      ]
    },
    "tool": {
      "description": "Tool to execute",
      "type": "string"
    }
  },
  "required": [
    "execution_order",
    "id",
    "tool"
  ],
  "title": "ToolChainStep",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ToolDefinition.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ParameterConstraints": {
      "description": "Validation constraints for parameters",
      "properties": {
        "allowed_values": {
          "default": null,
          "description": "Allowed values (enum constraint)",
          "items": {
            "type": "string"
          },
          "type": [
            "array",
            "null"
          ]
        },
        "max": {
          "default": null,
          "description": "Maximum value (for numbers) or length (for strings/arrays)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "min": {
          "default": null,
          "description": "Minimum value (for numbers) or length (for strings/arrays)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "pattern": {
          "default": null,
          "description": "Regex pattern for string validation",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "ParameterType": {
      "description": "Supported parameter types",
      "oneOf": [
        {
          "enum": [
            "string",
            "integer",
            "float",
            "boolean",
            "array",
            "object"
          ],
          "type": "string"
        },
        {
          "description": "Reference to another entity",
          "enum": [
            "entity_ref"
          ],
          "type": "string"
        },
        {
          "description": "Base64 encoded binary data",
          "enum": [
            "binary"
          ],
          "type": "string"
        }
      ]
    },
    "ToolCategory": {
      "description": "Categories of tools",
      "oneOf": [
        {
          "description": "Segmentation tools (break input into units)",
          "enum": [
            "segmentation"
          ],
          "type": "string"
        },
        {
          "description": "Classification tools (label content)",
          "enum": [
            "classification"
          ],
          "type": "string"
        },
        {
          "description": "Spawn tools (create entities)",
          "enum": [
            "spawn"
          ],
          "type": "string"
        },
        {
          "description": "Hint generation tools",
          "enum": [
            "hints"
          ],
          "type": "string"
        },
        {
          "description": "Search and retrieval tools",
          "enum": [
            "retrieval"
          ],
          "type": "string"
        },
        {
          "description": "Orchestration tools",
          "enum": [
            "orchestration"
          ],
          "type": "string"
        }
      ]
    },
    "ToolParameter": {
      "description": "Parameter definition with type and validation",
      "properties": {
        "constraints": {
          "anyOf": [
            {
              "$ref": "#/definitions/ParameterConstraints"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Validation constraints"
        },
        "default_value": {
          "default": null,
          "description": "Default value if not provided"
        },
        "description": {
          "description": "Description of what this parameter does",
          "type": "string"
        },
        "name": {
          "description": "Parameter name",
          "type": "string"
        },
        "param_type": {
          "allOf": [
            {
              "$ref": "#/definitions/ParameterType"
            }
          ],
          "description": "Data type"
        },
        "required": {
          "description": "Whether this parameter is required",
          "type": "boolean"
        }
      },
      "required": [
        "description",
        "name",
        "param_type",
        "required"
      ],
      "type": "object"
    }
  },
  "description": "Base schema for all tools",
  "properties": {
    "category": {
      "allOf": [
        {
          "$ref": "#/definitions/ToolCategory"
        }
      ],
      "description": "Category for organization"
    },
    "description": {
      "description": "Human-readable description",
      "type": "string"
    },
    "estimated_latency_ms": {
      "default": null,
      "description": "Estimated latency in milliseconds",
      "format": "uint32",
      "minimum": 0.0,
      "type": [
        "integer",
        "null"
      ]
    },
    "name": {
      "description": "Unique identifier for the tool",
      "type": "string"
    },
    "parallelizable": {
      "description": "Whether this tool can run in parallel with others",
      "type": "boolean"
    },
    "parameters": {
      "description": "Input parameters schema",
      "items": {
        "$ref": "#/definitions/ToolParameter"
      },
      "type": "array"
    },
    "version": {
      "description": "Version string (semver)",
      "type": "string"
    }
  },
  "required": [
    "category",
    "description",
    "name",
    "parallelizable",
    "parameters",
    "version"
  ],
  "title": "ToolDefinition",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ToolError.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ToolErrorCode": {
      "description": "Error codes for tool failures",
      "oneOf": [
        {
          "description": "Invalid input parameters",
          "enum": [
            "INVALID_INPUT"
          ],
          "type": "string"
        },
        {
          "description": "Missing required parameter",
          "enum": [
            "MISSING_PARAMETER"
          ],
          "type": "string"
        },
        {
          "description": "Parameter validation failed",
          "enum": [
            "VALIDATION_FAILED"
          ],
          "type": "string"
        },
        {
          "description": "Tool execution timed out",
          "enum": [
            "TIMEOUT"
          ],
          "type": "string"
        },
        {
          "description": "Rate limit exceeded",
          "enum": [
            "RATE_LIMITED"
          ],
          "type": "string"
        },
        {
          "description": "External service unavailable",
          "enum": [
            "SERVICE_UNAVAILABLE"
          ],
          "type": "string"
        },
        {
          "description": "LLM API error",
          "enum": [
            "LLM_ERROR"
          ],
          "type": "string"
        },
        {
          "description": "Internal tool error",
          "enum": [
            "INTERNAL_ERROR"
          ],
          "type": "string"
        },
        {
          "description": "Resource not found",
          "enum": [
            "NOT_FOUND"
          ],
          "type": "string"
        },
        {
          "description": "Permission denied",
          "enum": [
            "PERMISSION_DENIED"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Error types for tool failures",
  "properties": {
    "code": {
      "allOf": [
        {
          "$ref": "#/definitions/ToolErrorCode"
        }
      ],
      "description": "Error code for programmatic handling"
    },
    "details": {
      "default": null,
      "description": "Additional error details"
    },
    "message": {
      "description": "Human-readable error message",
      "type": "string"
    },
    "retryable": {
      "description": "Whether this error is retryable",
      "type": "boolean"
    }
  },
  "required": [
    "code",
    "message",
    "retryable"
  ],
  "title": "ToolError",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ToolErrorCode.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Error codes for tool failures",
  "oneOf": [
    {
      "description": "Invalid input parameters",
      "enum": [
        "INVALID_INPUT"
      ],
      "type": "string"
    },
    {
      "description": "Missing required parameter",
      "enum": [
        "MISSING_PARAMETER"
      ],
      "type": "string"
    },
    {
      "description": "Parameter validation failed",
      "enum": [
        "VALIDATION_FAILED"
      ],
      "type": "string"
    },
    {
      "description": "Tool execution timed out",
      "enum": [
        "TIMEOUT"
      ],
      "type": "string"
    },
    {
      "description": "Rate limit exceeded",
      "enum": [
        "RATE_LIMITED"
      ],
      "type": "string"
    },
    {
      "description": "External service unavailable",
      "enum": [
        "SERVICE_UNAVAILABLE"
      ],
      "type": "string"
    },
    {
      "description": "LLM API error",
      "enum": [
        "LLM_ERROR"
      ],
      "type": "string"
    },
    {
      "description": "Internal tool error",
      "enum": [
        "INTERNAL_ERROR"
      ],
      "type": "string"
    },
    {
      "description": "Resource not found",
      "enum": [
        "NOT_FOUND"
      ],
      "type": "string"
    },
    {
      "description": "Permission denied",
      "enum": [
        "PERMISSION_DENIED"
      ],
      "type": "string"
    }
  ],
  "title": "ToolErrorCode",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ToolExecutionMetadata.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Tool execution metadata",
  "properties": {
    "duration_ms": {
      "description": "Execution duration in milliseconds",
      "format": "uint64",
      "minimum": 0.0,
      "type": "integer"
    },
    "model": {
      "default": null,
      "description": "Model used (if LLM-based)",
      "type": [
        "string",
        "null"
      ]
    },
    "started_at": {
      "description": "Timestamp when execution started",
      "type": "string"
    },
    "token_usage": {
      "anyOf": [
        {
          "$ref": "../../codegen/primitives/TokenUsage.schema.json"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Token usage (if LLM-based)"
    },
    "tool_name": {
      "description": "Tool name that was executed",
      "type": "string"
    },
    "trace_id": {
      "default": null,
      "description": "Request/trace ID for debugging",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "duration_ms",
    "started_at",
    "tool_name"
  ],
  "title": "ToolExecutionMetadata",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ToolParameter.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ParameterConstraints": {
      "description": "Validation constraints for parameters",
      "properties": {
        "allowed_values": {
          "default": null,
          "description": "Allowed values (enum constraint)",
          "items": {
            "type": "string"
          },
          "type": [
            "array",
            "null"
          ]
        },
        "max": {
          "default": null,
          "description": "Maximum value (for numbers) or length (for strings/arrays)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "min": {
          "default": null,
          "description": "Minimum value (for numbers) or length (for strings/arrays)",
          "format": "double",
          "type": [
            "number",
            "null"
          ]
        },
        "pattern": {
          "default": null,
          "description": "Regex pattern for string validation",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "ParameterType": {
      "description": "Supported parameter types",
      "oneOf": [
        {
          "enum": [
            "string",
            "integer",
            "float",
            "boolean",
            "array",
            "object"
          ],
          "type": "string"
        },
        {
          "description": "Reference to another entity",
          "enum": [
            "entity_ref"
          ],
          "type": "string"
        },
        {
          "description": "Base64 encoded binary data",
          "enum": [
            "binary"
          ],
          "type": "string"
        }
      ]
    }
  },
  "description": "Parameter definition with type and validation",
  "properties": {
    "constraints": {
      "anyOf": [
        {
          "$ref": "#/definitions/ParameterConstraints"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Validation constraints"
    },
    "default_value": {
      "default": null,
      "description": "Default value if not provided"
    },
    "description": {
      "description": "Description of what this parameter does",
      "type": "string"
    },
    "name": {
      "description": "Parameter name",
      "type": "string"
    },
    "param_type": {
      "allOf": [
        {
          "$ref": "#/definitions/ParameterType"
        }
      ],
      "description": "Data type"
    },
    "required": {
      "description": "Whether this parameter is required",
      "type": "boolean"
    }
  },
  "required": [
    "description",
    "name",
    "param_type",
    "required"
  ],
  "title": "ToolParameter",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/ToolPurpose.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Primary purpose of user's message",
  "oneOf": [
    {
      "description": "Recording memories, events, observations - wants to store",
      "enum": [
        "LOG"
      ],
      "type": "string"
    },
    {
      "description": "Asking a question - wants information returned",
      "enum": [
        "QUERY"
      ],
      "type": "string"
    },
    {
      "description": "Making connections, deriving insights - wants system to infer",
      "enum": [
        "INFER"
      ],
      "type": "string"
    },
    {
      "description": "Looking up specific entities - wants existing data",
      "enum": [
        "REFERENCE"
      ],
      "type": "string"
    },
    {
      "description": "Requesting analysis or reflection - wants patterns identified",
      "enum": [
        "REFLECT"
      ],
      "type": "string"
    },
    {
      "description": "System command/instruction - wants action taken",
      "enum": [
        "COMMAND"
      ],
      "type": "string"
    },
    {
      "description": "Social/conversational - greeting, acknowledgment",
      "enum": [
        "SOCIAL"
      ],
      "type": "string"
    },
    {
      "description": "Clarifying or continuing previous message",
      "enum": [
        "CONTINUATION"
      ],
      "type": "string"
    },
    {
      "description": "Editing or correcting previous input",
      "enum": [
        "CORRECTION"
      ],
      "type": "string"
    }
  ],
  "title": "ToolPurpose",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/TriggerType.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Types of triggers",
  "oneOf": [
    {
      "description": "Match on purpose type",
      "enum": [
        "purpose"
      ],
      "type": "string"
    },
    {
      "description": "Match on modality",
      "enum": [
        "modality"
      ],
      "type": "string"
    },
    {
      "description": "Match on entity type",
      "enum": [
        "entity_type"
      ],
      "type": "string"
    },
    {
      "description": "Match on keyword",
      "enum": [
        "keyword"
      ],
      "type": "string"
    },
    {
      "description": "Custom condition",
      "enum": [
        "custom"
      ],
      "type": "string"
    }
  ],
  "title": "TriggerType",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/UserPurposePatterns.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "User's historical purpose patterns",
  "properties": {
    "primary_purpose": {
      "allOf": [
        {
          "$ref": "../../codegen/primitives/ToolPurpose.schema.json"
        }
      ],
      "description": "Most common purpose"
    },
    "purpose_distribution": {
      "additionalProperties": {
        "format": "double",
        "type": "number"
      },
      "default": {},
      "description": "Distribution of purposes (purpose -> frequency)",
      "type": "object"
    }
  },
  "required": [
    "primary_purpose"
  ],
  "title": "UserPurposePatterns",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/VAEPosition.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "VAE space position (quantized for physics)",
  "properties": {
    "x": {
      "description": "X: Valence (emotional polarity)",
      "format": "int64",
      "type": "integer"
    },
    "y": {
      "description": "Y: Arousal (energy/activation)",
      "format": "int64",
      "type": "integer"
    },
    "z": {
      "description": "Z: Epistemic (certainty)",
      "format": "int64",
      "type": "integer"
    }
  },
  "required": [
    "x",
    "y",
    "z"
  ],
  "title": "VAEPosition",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/VerbCategory.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Categories of verbs for classification",
  "oneOf": [
    {
      "description": "Action verbs (went, did, called)  MOMENT",
      "enum": [
        "action"
      ],
      "type": "string"
    },
    {
      "description": "State verbs (was, felt, is)  often PULSE",
      "enum": [
        "state"
      ],
      "type": "string"
    },
    {
      "description": "Stative + evaluative (was nice, felt good)  PULSE",
      "enum": [
        "evaluative"
      ],
      "type": "string"
    },
    {
      "description": "Relational verbs (met, talked with)  may indicate BOND",
      "enum": [
        "relational"
      ],
      "type": "string"
    },
    {
      "description": "Habitual (always, usually does)  may indicate MOTIF/FILAMENT",
      "enum": [
        "habitual"
      ],
      "type": "string"
    },
    {
      "description": "Intentional (want to, plan to)  INTENT",
      "enum": [
        "intentional"
      ],
      "type": "string"
    }
  ],
  "title": "VerbCategory",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/VerbTense.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Verb tenses",
  "enum": [
    "past",
    "present",
    "future",
    "habitual"
  ],
  "title": "VerbTense",
  "type": "string",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

### versions/v1.1.0-alpha/json-schema/infrastructure/tools/VisionSegmentFeatures.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "BoundingBox": {
      "description": "Bounding box for object detection",
      "properties": {
        "height": {
          "format": "double",
          "type": "number"
        },
        "width": {
          "format": "double",
          "type": "number"
        },
        "x": {
          "format": "double",
          "type": "number"
        },
        "y": {
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "height",
        "width",
        "x",
        "y"
      ],
      "type": "object"
    },
    "DetectedAction": {
      "description": "A detected action in vision",
      "properties": {
        "action": {
          "type": "string"
        },
        "actor": {
          "default": null,
          "type": [
            "string",
            "null"
          ]
        },
        "confidence": {
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "action",
        "confidence"
      ],
      "type": "object"
    },
    "DetectedObject": {
      "description": "A detected object in vision",
      "properties": {
        "bounding_box": {
          "anyOf": [
            {
              "$ref": "#/definitions/BoundingBox"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "confidence": {
          "format": "double",
          "type": "number"
        },
        "label": {
          "type": "string"
        }
      },
      "required": [
        "confidence",
        "label"
      ],
      "type": "object"
    },
    "DetectedPerson": {
      "description": "A detected person in vision",
      "properties": {
        "bounding_box": {
          "anyOf": [
            {
              "$ref": "#/definitions/BoundingBox"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "emotion": {
          "default": null,
          "type": [
            "string",
            "null"
          ]
        },
        "face_id": {
          "default": null,
          "type": [
            "string",
            "null"
          ]
        }
      },
      "type": "object"
    }
  },
  "description": "Vision-specific segment features",
  "properties": {
    "actions": {
      "default": [],
      "description": "Actions/activities",
      "items": {
        "$ref": "#/definitions/DetectedAction"
      },
      "type": "array"
    },
    "objects": {
      "description": "Objects detected",
      "items": {
        "$ref": "#/definitions/DetectedObject"
      },
      "type": "array"
    },
    "people": {
      "default": [],
      "description": "People detected",
      "items": {
        "$ref": "#/definitions/DetectedPerson"
      },
      "type": "array"
    },
    "scene_description": {
      "description": "Scene description",
      "type": "string"
    },
    "text_content": {
      "default": null,
      "description": "Text in image (OCR)",
      "type": [
        "string",
        "null"
      ]
    }
  },
  "required": [
    "objects",
    "scene_description"
  ],
  "title": "VisionSegmentFeatures",
  "type": "object",
  "x-familiar-kind": "tool",
  "x-familiar-queue": "worker-queue",
  "x-familiar-service": {
    "$ref": "../nodes/familiar-worker.node.json"
  }
}
```

## Nickel Configuration Files

### versions/v1.1.0-alpha/nickel/architecture/_directory.ncl

```nickel
# Architecture Directory - Orthological reference and inheritance validation
let Composer = import "../composers/directory_composer.ncl" in
let Libraries = import "../libraries/all_libraries.ncl" in

# Architecture-specific reference validation
Libraries & {
  # Reference validation for architecture layer (directory level)
  reference_validation = {
    # Validate architecture directory schemas (should use inheritance, not $refs)
    validate_architecture_directory = fun schema =>
      Libraries.ReferenceContract.validate schema "directory"
    ,

    # Validate architecture meta schemas (may use $refs for schema composition)
    validate_architecture_meta = fun schema =>
      Libraries.ReferenceContract.validate schema "meta"
  },

  # Export validation functions
  ReferenceValidation = reference_validation
} & Composer.architecture.Contract.compose {
  extract_from_raw = Composer.architecture.extraction,
  validate_pure = Composer.architecture.validation,
  get_layer = "topology"
}
```

### versions/v1.1.0-alpha/nickel/architecture/compositions/_directory.ncl

```nickel
# Architecture subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.architecture.Contract.compose {
  extract_from_raw = Composer.architecture.extraction,
  validate_pure = Composer.architecture.validation,
  get_layer = "topology"
}

```

### versions/v1.1.0-alpha/nickel/architecture/edge-semantics.ncl

```nickel
# Architecture Edge Semantics
#
# Inherits global edge types and specializes them for architectural/topology concerns.
# Defines how edges behave in the context of system architecture and data flow.
#
# @category architecture
# @graph-value high - specializes edges for topology relationships
# @validation context-aware - topology-specific edge constraints

let global_edges = import "../extensions/edge-type.ncl" in

{
  # ============================================================================
  # INHERITED & SPECIALIZED EDGE TYPES
  # ============================================================================

  # Define architecture-specific edge types for topology concerns
  edge_types = {
    # Add architecture-specific edge types
    entity_node_binding = {
      directionality = "directed",
      cardinality = "many_to_one",
      transitivity = false,
      cyclicity = "acyclic",
      data_flow = "deployment",
      strength = "strong",
      context = "topology_deployment",
      compilation_implications = {
        generate_deployment_mapping = true,
        generate_service_discovery = true,
        generate_load_balancing = false
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = false,
        topological_sort_required = true
      }
    },

    service_mesh_binding = {
      directionality = "bidirectional",
      cardinality = "many_to_many",
      transitivity = false,
      cyclicity = "cyclic_allowed",
      data_flow = "service_discovery",
      strength = "medium",
      context = "service_orchestration",
      compilation_implications = {
        generate_service_mesh_config = true,
        generate_health_checks = true,
        generate_circuit_breakers = true
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = true,
        topological_sort_required = false
      }
    },

    # Define architecture-specific edge types
    depends_on = {
      directionality = "directed",
      cardinality = "many_to_one",
      transitivity = true,
      cyclicity = "acyclic",
      data_flow = "none",
      strength = "strong",
      context = "architecture_dependencies",
      compilation_implications = {
        generate_topology_aware_injection = true,
        generate_deployment_ordering = true,
        generate_resource_dependencies = true
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = false,
        topological_sort_required = true,
        cycle_detection_critical = true
      }
    },

    orchestrates = {
      directionality = "directed",
      cardinality = "one_to_many",
      transitivity = false,
      cyclicity = "acyclic",
      data_flow = "control_flow",
      strength = "strong",
      context = "workflow_orchestration",
      compilation_implications = {
        generate_workflow_engine = true,
        generate_state_management = true,
        generate_error_propagation = true
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = false,
        topological_sort_required = true,
        workflow_cycles_allowed = false
      }
    },

    communicates_with = {
      directionality = "bidirectional",
      cardinality = "many_to_many",
      transitivity = false,
      cyclicity = "cyclic_allowed",
      data_flow = "bidirectional",
      strength = "medium",
      context = "inter_service_communication",
      compilation_implications = {
        generate_api_clients = true,
        generate_message_queues = true,
        generate_protocol_buffers = true
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = true,
        topological_sort_required = false,
        communication_cycles_allowed = true
      }
    },

    deploys_to = {
      context = "infrastructure_deployment",
      compilation_implications = {
        generate_deployment_manifests = true,
        generate_infrastructure_as_code = true,
        generate_scaling_policies = true
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = false,
        topological_sort_required = true
      }
    }
  },

  # ============================================================================
  # ARCHITECTURE-SPECIFIC VALIDATION RULES
  # ============================================================================

  validation_rules = {
    # Edge combinations allowed in architecture schemas
    allowed_edge_combinations = [
      # Entity to Node bindings (core topology)
      {
        source_kind = "entity",
        target_kind = "node",
        allowed_edges = ["entity_node_binding", "deploys_to"]
      },

      # Node to Node orchestration
      {
        source_kind = "node",
        target_kind = "node",
        allowed_edges = ["orchestrates", "communicates_with", "depends_on"]
      },

      # System to System communication
      {
        source_kind = "system",
        target_kind = "system",
        allowed_edges = ["orchestrates", "communicates_with", "depends_on"]
      },

      # Component to Resource dependencies
      {
        source_kind = "component",
        target_kind = "resource",
        allowed_edges = ["depends_on", "uses"]
      }
    ],

    # Prohibited patterns in architecture
    prohibited_patterns = [
      # Entities shouldn't communicate directly (must go through nodes)
      {
        source_kind = "entity",
        target_kind = "entity",
        prohibited_edges = ["communicates_with"]
      },

      # Systems shouldn't bind directly to entities (use nodes)
      {
        source_kind = "system",
        target_kind = "entity",
        prohibited_edges = ["entity_node_binding"]
      }
    ],

    # Topology-specific constraints
    topology_constraints = {
      # Maximum depth for dependency chains
      max_dependency_depth = 10,

      # Require explicit relationship types
      allow_implicit_relationships = false,

      # Enforce acyclic graphs where specified
      enforce_acyclic_topology = true
    }
  },

  # ============================================================================
  # ARCHITECTURE-SPECIFIC FUNCTIONS
  # ============================================================================

  functions = {
    # Validate edge compatibility in architecture context
    validate_architecture_edge = fun source_kind target_kind edge_type =>
      let allowed_combinations = validation_rules.allowed_edge_combinations in
      let matching_rules = std.array.filter (fun rule =>
        rule.source_kind == source_kind && rule.target_kind == target_kind
      ) allowed_combinations in

      if std.array.is_empty matching_rules then
        false  # No rules allow this source->target combination
      else
        # Check if edge_type is allowed for this source->target
        std.array.any (fun rule =>
          std.array.elem edge_type rule.allowed_edges
        ) matching_rules,

    # Get edge metadata with architecture specialization
    get_architecture_edge_metadata = fun edge_type =>
      if std.record.has_field edge_type edge_types then
        std.record.get edge_type edge_types
      else
        global_edges.functions.get_edge_characteristics edge_type,

    # Analyze topology connectivity using edge semantics
    analyze_topology_connectivity = fun edges =>
      let edge_types_used = std.array.map (fun edge => edge.edge_type) edges in
      let unique_edge_types = std.array.fold_left (fun acc type =>
        if std.array.elem type acc then acc else acc @ [type]
      ) [] edge_types_used in

      {
        dependency_depth = calculate_dependency_depth edges,
        communication_patterns = analyze_communication_patterns unique_edge_types,
        orchestration_complexity = calculate_orchestration_complexity edges,
        potential_cycles = detect_potential_cycles edges edge_types,
        optimization_opportunities = identify_optimization_opportunities edges
      },

    # Calculate dependency depth (longest chain)
    calculate_dependency_depth = fun edges =>
      # Simplified depth calculation - in practice would need graph analysis
      let depends_edges = std.array.filter (fun edge => edge.edge_type == "depends_on") edges in
      std.array.length depends_edges,

    # Analyze communication patterns
    analyze_communication_patterns = fun edge_types =>
      let has_service_mesh = std.array.elem "service_mesh_binding" edge_types in
      let has_direct_comm = std.array.elem "communicates_with" edge_types in

      if has_service_mesh && has_direct_comm then
        "hybrid_service_mesh"
      else if has_service_mesh then
        "service_mesh_only"
      else if has_direct_comm then
        "direct_communication"
      else
        "no_communication",

    # Calculate orchestration complexity
    calculate_orchestration_complexity = fun edges =>
      let orchestration_edges = std.array.filter (fun edge =>
        std.array.elem edge.edge_type ["orchestrates", "entity_node_binding"]
      ) edges in
      std.array.length orchestration_edges,

    # Detect potential cycles using edge semantics
    detect_potential_cycles = fun edges edge_types =>
      let cyclic_allowed_edges = std.array.filter (fun edge_type =>
        let edge_metadata = std.record.get edge_type edge_types in
        edge_metadata.cyclicity == "cyclic_allowed"
      ) (std.record.fields edge_types) in

      let potentially_cyclic_edges = std.array.filter (fun edge =>
        std.array.elem edge.edge_type cyclic_allowed_edges
      ) edges in

      if std.array.is_empty potentially_cyclic_edges then
        []
      else
        std.array.map (fun edge => {
          edge = edge,
          risk_level = "medium",
          mitigation = "add_explicit_cycle_breakers"
        }) potentially_cyclic_edges,

    # Identify optimization opportunities
    identify_optimization_opportunities = fun edges =>
      let opportunities = [] in

      # Check for redundant paths
      let redundant_paths = detect_redundant_paths edges in
      let opportunities = if std.array.is_empty redundant_paths then
        opportunities
      else
        opportunities @ [{
          type = "redundant_paths",
          description = "Multiple paths between same nodes detected",
          edges = redundant_paths,
          optimization = "consolidate_paths"
        }] in

      # Check for potential batching opportunities
      let batching_ops = detect_batching_opportunities edges in
      let opportunities = if std.array.is_empty batching_ops then
        opportunities
      else
        opportunities @ [{
          type = "batching_opportunities",
          description = "Multiple similar edges could be batched",
          edges = batching_ops,
          optimization = "implement_edge_batching"
        }] in

      opportunities,

    # Helper: Detect redundant paths (simplified)
    detect_redundant_paths = fun edges =>
      # In practice, would need graph analysis to detect multiple paths
      [],

    # Helper: Detect batching opportunities
    detect_batching_opportunities = fun edges =>
      let depends_edges = std.array.filter (fun edge => edge.edge_type == "depends_on") edges in
      if std.array.length depends_edges > 3 then
        depends_edges  # If many dependencies, suggest batching
      else
        []
  },

  # ============================================================================
  # COMPILATION INTEGRATION
  # ============================================================================

  compilation = {
    # Generate code from architectural edges
    generate_from_architecture_edges = fun edges graph_context =>
      # Group edges by type for batch processing (simplified - no group_by available)
      let edge_types = std.array.map (fun edge => edge.edge_type) edges in
      let unique_types = std.array.uniq edge_types in

      # Generate architecture-specific code for each edge type
      std.array.map (fun edge_type =>
        let edge_list = std.array.filter (fun edge => edge.edge_type == edge_type) edges in
        let metadata = functions.get_architecture_edge_metadata edge_type in
        {
          edge_type = edge_type,
          edges = edge_list,
          metadata = metadata,
          generated_code = "placeholder_code"
        }
      ) unique_types,

    # Generate deployment topology
    generate_deployment_topology = fun edges =>
      let entity_bindings = std.array.filter (fun edge =>
        edge.edge_type == "entity_node_binding"
      ) edges in

      # Manual grouping by target_ref (simplified)
      let target_refs = std.array.map (fun edge => edge.target_ref) entity_bindings in
      let unique_targets = std.array.uniq target_refs in

      std.array.map (fun node_ref => {
        node = node_ref,
        entities = std.array.map (fun edge => edge.source_schema)
          (std.array.filter (fun edge => edge.target_ref == node_ref) entity_bindings),
        deployment_strategy = "rolling",
        health_checks = true
      }) unique_targets,

    # Generate service mesh configuration
    generate_service_mesh_config = fun edges =>
      let communication_edges = std.array.filter (fun edge =>
        edge.edge_type == "communicates_with"
      ) edges in

      {
        services = std.array.uniq (
          std.array.fold_left (fun acc edge => acc @ [edge.source_schema, edge.target_ref]) [] communication_edges
        ),
        communication_patterns = std.array.map (fun edge => {
          source = edge.source_schema,
          target = edge.target_ref,
          protocol = "http",
          timeout = "30s"
        }) communication_edges
      }
  }
}
```

### versions/v1.1.0-alpha/nickel/architecture/patterns/_directory.ncl

```nickel
# Architecture subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.architecture.Contract.compose {
  extract_from_raw = Composer.architecture.extraction,
  validate_pure = Composer.architecture.validation,
  get_layer = "topology"
}

```

### versions/v1.1.0-alpha/nickel/architecture/techniques/_directory.ncl

```nickel
# Architecture Techniques Directory - ISA compliance and CEL validation
# Inherits from global libraries with technique-specific specializations

let Libraries = import "../../libraries/all_libraries.ncl" in

# Technique validation contracts for architecture layer
{
  # Inherit all global libraries
  Libraries,

  # Architecture-specific technique validation
  technique_validation = {
    # Validate architectural techniques (high-level workflows)
    validate_architecture_technique = fun technique_json =>
      # Basic technique validation
      Libraries.TechniqueContract.validate technique_json &&

      # Architecture-specific constraints
      std.record.has_field "x-familiar-architectural-pattern" technique_json &&

      # Validate step kinds are appropriate for architecture layer
      let allowed_kinds = [Libraries.StepKinds.call, Libraries.StepKinds.switch, Libraries.StepKinds.parallel] in
      std.array.all (fun step =>
        std.array.elem step.kind allowed_kinds
      ) technique_json.steps
    ,

    # Validate CEL expressions follow architectural data flow
    validate_architectural_data_flow = fun technique_json =>
      Libraries.CELValidation.validate_return_expressions
        technique_json.return
        (std.array.map (fun step => step.id) technique_json.steps)
  },

  # Export validation functions for subdirectory inheritance
  TechniqueValidation = technique_validation,

  # Directory-level validation contract
  validate_directory = fun directory_path =>
    # Architecture techniques directory validation
    # This would validate all technique files in the directory
    { valid = true, errors = [], warnings = [] }
}
```

### versions/v1.1.0-alpha/nickel/architecture/topologies/_directory.ncl

```nickel
# Architecture subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.architecture.Contract.compose {
  extract_from_raw = Composer.architecture.extraction,
  validate_pure = Composer.architecture.validation,
  get_layer = "topology"
}

```

### versions/v1.1.0-alpha/nickel/codegen/_directory.ncl

```nickel
# Import typed collection with extreme & composition
let Composer = import "../composers/directory_composer.ncl" in

# Use extreme & composition - minimal merged blocks from libraries
Composer.codegen.Contract.compose {
  extract_from_raw = Composer.codegen.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "entity"
}
```

### versions/v1.1.0-alpha/nickel/codegen/components/_directory.ncl

```nickel
# Import typed collection (abstracted from primitives)
let Composer = import "../../composers/directory_composer.ncl" in

# Use typed codegen interface - minimal merged blocks from libraries/primitives
Composer.codegen.Contract.compose {
  extract_from_raw = Composer.codegen.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "entity"
}
```

### versions/v1.1.0-alpha/nickel/codegen/edge-semantics.ncl

```nickel
/**
 * Codegen Edge Semantics
 *
 * Inherits global edge types and specializes them for code generation/data concerns.
 * Defines how edges behave in the context of entities, types, and code generation.
 *
 * @category codegen
 * @graph-value high - specializes edges for data relationships
 * @validation context-aware - codegen-specific edge constraints
 */

let global_edges = import "../extensions/edge-type.ncl" in

{
  # ============================================================================
  # INHERITED & SPECIALIZED EDGE TYPES
  # ============================================================================

  # Inherit all global edge types with codegen-specific specializations
  edge_types = global_edges.edge_types & {
    # Add codegen-specific edge types
    inherits_from = {
      directionality = "directed",
      cardinality = "many_to_one",
      transitivity = true,
      cyclicity = "acyclic",
      data_flow = "type_inheritance",
      strength = "strong",
      context = "type_hierarchy",
      compilation_implications = {
        generate_inheritance_code = true,
        generate_polymorphic_dispatch = true,
        generate_type_checks = true
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = false,
        topological_sort_required = true,
        inheritance_cycles_forbidden = true
      }
    },

    composes = {
      directionality = "directed",
      cardinality = "one_to_many",
      transitivity = false,
      cyclicity = "acyclic",
      data_flow = "composition",
      strength = "medium",
      context = "object_composition",
      compilation_implications = {
        generate_composition_code = true,
        generate_lifecycle_management = true,
        generate_null_checks = true
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = false,
        topological_sort_required = false  # Composition is structural, not dependency-based
      }
    },

    # Specialize existing edges for codegen context
    depends_on = global_edges.edge_types.depends_on & {
      context = "codegen_dependencies",
      compilation_implications = global_edges.edge_types.depends_on.compilation_implications & {
        generate_import_statements = true,
        generate_initialization_order = true,
        generate_dependency_injection_setup = true
      },
      traversal_rules = global_edges.edge_types.depends_on.traversal_rules & {
        codegen_cycles_forbidden = true,
        import_order_critical = true
      }
    },

    references = global_edges.edge_types.references & {
      context = "type_references",
      compilation_implications = {
        generate_type_imports = true,
        generate_forward_declarations = true,
        generate_namespace_imports = false
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = true,  # Type references can be circular (mutual references)
        topological_sort_required = false
      }
    },

    implements = global_edges.edge_types.implements & {
      context = "interface_implementation",
      compilation_implications = {
        generate_interface_implementations = true,
        generate_method_stubs = true,
        generate_type_assertions = true
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = false,
        topological_sort_required = true
      }
    }
  },

  # ============================================================================
  # CODEGEN-SPECIFIC VALIDATION RULES
  # ============================================================================

  validation_rules = {
    # Edge combinations allowed in codegen schemas
    allowed_edge_combinations = [
      # Entity to Entity relationships
      {
        source_kind = "entity",
        target_kind = "entity",
        allowed_edges = ["depends_on", "references", "inherits_from", "composes"]
      },

      # Entity to Component composition
      {
        source_kind = "entity",
        target_kind = "component",
        allowed_edges = ["depends_on", "references"]
      },

      # Component to Component relationships
      {
        source_kind = "component",
        target_kind = "component",
        allowed_edges = ["depends_on", "references", "implements"]
      },

      # Primitive type references
      {
        source_kind = "entity",
        target_kind = "primitive",
        allowed_edges = ["references"]
      }
    ],

    # Prohibited patterns in codegen
    prohibited_patterns = [
      # Entities shouldn't inherit from components (use composition)
      {
        source_kind = "entity",
        target_kind = "component",
        prohibited_edges = ["inherits_from"]
      },

      # Components shouldn't inherit from entities (wrong direction)
      {
        source_kind = "component",
        target_kind = "entity",
        prohibited_edges = ["inherits_from"]
      }
    ],

    # Codegen-specific constraints
    codegen_constraints = {
      # Maximum inheritance depth
      max_inheritance_depth = 3,

      # Allow circular references between types
      allow_circular_type_references = true,

      # Maximum composition depth
      max_composition_depth = 5
    }
  },

  # ============================================================================
  # CODEGEN-SPECIFIC FUNCTIONS
  # ============================================================================

  functions = {
    # Validate edge compatibility in codegen context
    validate_codegen_edge = fun source_kind target_kind edge_type =>
      let allowed_combinations = validation_rules.allowed_edge_combinations in
      let matching_rules = std.array.filter (fun rule =>
        rule.source_kind == source_kind && rule.target_kind == target_kind
      ) allowed_combinations in

      if std.array.is_empty matching_rules then
        false  # No rules allow this source->target combination
      else
        # Check if edge_type is allowed for this source->target
        std.array.any (fun rule =>
          std.array.elem edge_type rule.allowed_edges
        ) matching_rules,

    # Get edge metadata with codegen specialization
    get_codegen_edge_metadata = fun edge_type =>
      if std.record.has_field edge_type edge_types then
        edge_types."%{edge_type}"
      else
        global_edges.functions.get_edge_characteristics edge_type,

    # Analyze type dependencies and imports
    analyze_type_dependencies = fun edges =>
      let dependency_edges = std.array.filter (fun edge =>
        std.array.elem edge.edge_type ["depends_on", "references"]
      ) edges in

      let inheritance_edges = std.array.filter (fun edge =>
        edge.edge_type == "inherits_from"
      ) edges in

      let composition_edges = std.array.filter (fun edge =>
        edge.edge_type == "composes"
      ) edges in

      {
        import_graph = build_import_graph dependency_edges,
        inheritance_hierarchy = build_inheritance_hierarchy inheritance_edges,
        composition_structure = build_composition_structure composition_edges,
        circular_dependencies = detect_circular_dependencies dependency_edges,
        optimization_opportunities = find_codegen_optimizations edges
      },

    # Build import graph for code generation
    build_import_graph = fun dependency_edges =>
      let imports_by_source = std.array.group_by (fun edge => edge.source_schema) dependency_edges in

      std.record.map (fun source imports => {
        source_type = source,
        required_imports = std.array.map (fun edge => {
          target_type = edge.target_ref,
          import_type = if edge.edge_type == "depends_on" then "direct" else "indirect",
          nullable = false
        }) imports
      }) imports_by_source,

    # Build inheritance hierarchy
    build_inheritance_hierarchy = fun inheritance_edges =>
      let hierarchy = std.array.group_by (fun edge => edge.target_ref) inheritance_edges in

      std.record.map (fun base_type inheritors => {
        base_type = base_type,
        inheriting_types = std.array.map (fun edge => edge.source_schema) inheritors,
        inheritance_depth = calculate_inheritance_depth inheritance_edges base_type
      }) hierarchy,

    # Calculate inheritance depth
    calculate_inheritance_depth = fun inheritance_edges base_type =>
      # Simplified depth calculation
      let direct_inheritors = std.array.filter (fun edge =>
        edge.target_ref == base_type
      ) inheritance_edges in
      std.array.length direct_inheritors,

    # Build composition structure
    build_composition_structure = fun composition_edges =>
      let compositions_by_owner = std.array.group_by (fun edge => edge.source_schema) composition_edges in

      std.record.map (fun owner components => {
        owner_type = owner,
        composed_components = std.array.map (fun edge => {
          component_type = edge.target_ref,
          composition_type = "aggregation",
          lifecycle_managed = true
        }) components
      }) compositions_by_owner,

    # Detect circular dependencies
    detect_circular_dependencies = fun dependency_edges =>
      # Simplified cycle detection - in practice would need proper graph algorithms
      let sources = std.array.map (fun edge => edge.source_schema) dependency_edges in
      let targets = std.array.map (fun edge => edge.target_ref) dependency_edges in

      # Check for obvious cycles (A->B and B->A)
      let potential_cycles = std.array.filter (fun source =>
        std.array.elem source targets
      ) sources in

      if std.array.is_empty potential_cycles then
        []
      else
        std.array.map (fun source => [source, "circular_dependency_detected"]) potential_cycles,

    # Find codegen optimizations
    find_codegen_optimizations = fun edges =>
      let opportunities = [] in

      # Check for redundant imports
      let redundant_imports = detect_redundant_imports edges in
      let opportunities = if std.array.is_empty redundant_imports then
        opportunities
      else
        opportunities @ [{
          type = "redundant_imports",
          description = "Multiple imports of same type detected",
          items = redundant_imports,
          optimization = "consolidate_imports"
        }] in

      # Check for deep inheritance chains
      let deep_inheritance = detect_deep_inheritance edges in
      let opportunities = if std.array.is_empty deep_inheritance then
        opportunities
      else
        opportunities @ [{
          type = "deep_inheritance",
          description = "Inheritance chains exceed recommended depth",
          items = deep_inheritance,
          optimization = "flatten_inheritance"
        }] in

      opportunities,

    # Detect redundant imports
    detect_redundant_imports = fun edges =>
      let reference_edges = std.array.filter (fun edge =>
        edge.edge_type == "references"
      ) edges in

      let references_by_target = std.array.group_by (fun edge => edge.target_ref) reference_edges in

      let redundant = std.record.filter (fun target sources =>
        std.array.length sources > 1  # Referenced by multiple sources
      ) references_by_target in

      std.record.fields redundant,

    # Detect deep inheritance chains
    detect_deep_inheritance = fun edges =>
      let inheritance_edges = std.array.filter (fun edge =>
        edge.edge_type == "inherits_from"
      ) edges in

      let inheritance_chains = build_inheritance_chains inheritance_edges in

      std.array.filter (fun chain =>
        std.array.length chain > validation_rules.codegen_constraints.max_inheritance_depth
      ) inheritance_chains,

    # Build inheritance chains (simplified)
    build_inheritance_chains = fun inheritance_edges =>
      # Simplified - in practice would need proper graph traversal
      std.array.map (fun edge => [edge.source_schema, edge.target_ref]) inheritance_edges,

    # Generate code generation ordering
    generate_codegen_ordering = fun edges =>
      let dependency_edges = std.array.filter (fun edge =>
        edge.edge_type == "depends_on"
      ) edges in

      let inheritance_edges = std.array.filter (fun edge =>
        edge.edge_type == "inherits_from"
      ) edges in

      {
        compilation_order = calculate_compilation_order dependency_edges,
        inheritance_order = calculate_inheritance_order inheritance_edges,
        import_order = calculate_import_order dependency_edges
      },

    # Calculate compilation order (topological sort of dependencies)
    calculate_compilation_order = fun dependency_edges =>
      # Simplified topological ordering
      let sources = std.array.uniq (
        std.array.map (fun edge => edge.source_schema) dependency_edges
      ) in

      # Reverse dependencies to get compilation order
      std.array.reverse sources,

    # Calculate inheritance order (base classes first)
    calculate_inheritance_order = fun inheritance_edges =>
      # Simplified - base classes should be compiled first
      let targets = std.array.uniq (
        std.array.map (fun edge => edge.target_ref) inheritance_edges
      ) in

      targets,

    # Calculate import order (dependencies first)
    calculate_import_order = fun dependency_edges =>
      # Simplified - dependencies should be imported first
      let targets = std.array.uniq (
        std.array.map (fun edge => edge.target_ref) dependency_edges
      ) in

      targets
  },

  # ============================================================================
  # COMPILATION INTEGRATION
  # ============================================================================

  compilation = {
    # Generate code from codegen edges
    generate_from_codegen_edges = fun edges graph_context =>
      # Group edges by type for batch processing
      let edges_by_type = std.array.group_by (fun edge => edge.edge_type) edges in

      # Generate codegen-specific code for each edge type
      std.record.map (fun edge_type edge_list =>
        let metadata = get_codegen_edge_metadata edge_type in
        generate_codegen_edge_code edge_type edge_list metadata graph_context
      ) edges_by_type,

    # Generate import statements
    generate_import_statements = fun edges =>
      let type_analysis = functions.analyze_type_dependencies edges in

      std.record.map (fun source info =>
        let imports = std.array.map (fun imp =>
          if imp.import_type == "direct" then
            "import ${imp.target_type};"
          else
            "import type { ${imp.target_type} };"
        ) info.required_imports in

        {
          source_file = source,
          imports = imports,
          consolidated = std.array.length imports > 1
        }
      ) type_analysis.import_graph,

    # Generate inheritance code
    generate_inheritance_code = fun edges =>
      let inheritance_hierarchy = functions.analyze_type_dependencies edges in

      std.record.flat_map (fun base_type info =>
        std.array.map (fun inheritor =>
          {
            base_type = base_type,
            inheritor_type = inheritor,
            inheritance_code = "class ${inheritor} extends ${base_type}",
            interface_required = info.inheritance_depth > 1
          }
        ) info.inheriting_types
      ) inheritance_hierarchy.inheritance_hierarchy,

    # Generate composition code
    generate_composition_code = fun edges =>
      let composition_structure = functions.analyze_type_dependencies edges in

      std.record.flat_map (fun owner info =>
        std.array.map (fun component =>
          {
            owner_type = owner,
            component_type = component.component_type,
            composition_code = "private ${component.component_type} component;",
            lifecycle_code = "this.component = new ${component.component_type}();"
          }
        ) info.composed_components
      ) composition_structure.composition_structure,

    # Generate type assertions
    generate_type_assertions = fun edges =>
      let implementation_edges = std.array.filter (fun edge =>
        edge.edge_type == "implements"
      ) edges in

      std.array.map (fun edge =>
        {
          implementor = edge.source_schema,
          interface = edge.target_ref,
          assertion_code = "assert ${edge.source_schema} instanceof ${edge.target_ref};",
          compile_time_check = true
        }
      ) implementation_edges
  }
}
```

### versions/v1.1.0-alpha/nickel/codegen/entities/_directory.ncl

```nickel
# Codegen subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.codegen.Contract.compose {
  extract_from_raw = Composer.codegen.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "entity"
}

```

### versions/v1.1.0-alpha/nickel/codegen/primitives/_directory.ncl

```nickel
# Codegen subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.codegen.Contract.compose {
  extract_from_raw = Composer.codegen.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "entity"
}

```

### versions/v1.1.0-alpha/nickel/codegen/types/_directory.ncl

```nickel
# Codegen subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.codegen.Contract.compose {
  extract_from_raw = Composer.codegen.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "entity"
}

```

### versions/v1.1.0-alpha/nickel/composers/directory_composer.ncl

```nickel
# Directory Composer - Extreme Composition with & and import
# Following Nickel "composable data" principle - records merged at will

# Import individual libraries for composition
let ContractLibrary = import "../libraries/contract_library.ncl" in
let HydrationLibrary = import "../libraries/hydration_library.ncl" in
let EdgeLibrary = import "../libraries/edge_library.ncl" in
let LayerLibrary = import "../libraries/layer_library.ncl" in
let ExtractionLibrary = import "../libraries/extraction_library.ncl" in
let ValidationLibrary = import "../libraries/validation_library.ncl" in

# Create composable building blocks using & (Nickel best practice)
let BaseContract = ContractLibrary & {
  hydration = HydrationLibrary,
  run_tests = ContractLibrary.enhanced_test_runner
} in

let EnhancedContract = BaseContract & {
  extraction = ExtractionLibrary.extraction_functions,
  validation = ValidationLibrary.validation_functions
} in

# Create layer-specific compositions using extreme & merging
let ArchitectureComposition = BaseContract & {
  layer_config = { get_layer = "entity" },
  extraction = ExtractionLibrary.extraction_functions.entity_extract,
  validation = ValidationLibrary.validation_functions.entity_validate
} in

let InfrastructureComposition = BaseContract & {
  layer_config = { get_layer = "node" },
  extraction = ExtractionLibrary.extraction_functions.node_extract,
  validation = ValidationLibrary.validation_functions.node_validate
} in

let CodegenComposition = BaseContract & {
  layer_config = { get_layer = "entity" },
  extraction = ExtractionLibrary.extraction_functions.entity_extract,
  validation = ValidationLibrary.validation_functions.entity_validate
} in

let DomainComposition = BaseContract & {
  layer_config = { get_layer = "domain" },
  extraction = ExtractionLibrary.extraction_functions.domain_extract,
  validation = ValidationLibrary.validation_functions.entity_validate  # Domain uses entity validation
} in

{
  # Typed collections using extreme & composition
  architecture = ArchitectureComposition & {
    Contract = {
      compose = fun config => ArchitectureComposition & { files = { contract = config } }
    }
  },

  infrastructure = InfrastructureComposition & {
    Contract = {
      compose = fun config => InfrastructureComposition & { files = { contract = config } }
    }
  },

  codegen = CodegenComposition & {
    Contract = {
      compose = fun config => CodegenComposition & { files = { contract = config } }
    }
  },

  domain = DomainComposition & {
    Contract = {
      compose = fun config => DomainComposition & { files = { contract = config } }
    }
  },

  # Metadata about the extreme composition approach
  metadata = {
    composition_strategy = "extreme_merging",
    nickel_principles = ["composable_data", "modular_configurations"],
    merge_operations = ["import", "&"],
    abstraction_level = "merged_libraries"
  }
}
```

### versions/v1.1.0-alpha/nickel/composers/schema_composer.ncl

```nickel
# Schema Composition Engine
# Uses extension schemas to understand and compose full schema behavior

let extension_schemas = {
  "x-familiar-kind" = import "../extensions/kind.ncl",
  "x-familiar-persistence" = import "../extensions/persistence.ncl",
  "x-familiar-service" = import "../extensions/service.ncl"
}

# Main composition function using Nickel's & operator
let compose_schema_with_extensions = fun base_schema =>
  # Extract extensions from schema
  let extensions = extract_extensions base_schema in

  # Load extension schemas
  let loaded_extensions = std.record.map (fun ext_name _ =>
    extension_schemas."${ext_name}" or {}
  ) extensions

  # Create composition context
  let composition_context = {
    schema = base_schema,
    extensions = extensions,
    extension_schemas = loaded_extensions,
    directory_path = get_directory_path base_schema,
    inheritance_chain = []  # Will be filled by directory processing
  }

  # Apply extension behaviors
  let schema_with_behaviors = apply_extension_behaviors composition_context in

  # Apply directory rules
  let schema_with_directory = apply_directory_rules schema_with_behaviors in

  # Generate derived schemas
  let derived_schemas = generate_derived_schemas schema_with_directory in

  # Return composed result
  schema_with_directory & {
    _composition = {
      applied_extensions = std.record.keys extensions,
      derived_schemas = derived_schemas,
      composition_timestamp = std.to_string (std.contract.current_time)
    }
  }

# Extract all x-familiar-* extensions from a schema
let extract_extensions = fun schema =>
  std.record.filter (fun key _ => std.string.starts_with key "x-familiar-") schema

# Apply behaviors defined in extension schemas
let apply_extension_behaviors = fun context =>
  let schema = context.schema in
  let extensions = context.extensions in

  # Apply each extension's behavior
  std.record.fold (fun acc ext_name ext_value =>
    let ext_schema = context.extension_schemas."${ext_name}" or {} in
    let behavior_result = apply_extension_behavior ext_schema ext_value schema in
    acc & behavior_result
  ) schema extensions

# Apply a single extension's behavior
let apply_extension_behavior = fun ext_schema ext_value base_schema =>
  if std.record.has_field "codegen" ext_schema then
    let codegen_rules = ext_schema.codegen in
    apply_codegen_behavior codegen_rules ext_value base_schema
  else if std.record.has_field "runtime" ext_schema then
    let runtime_rules = ext_schema.runtime in
    apply_runtime_behavior runtime_rules ext_value base_schema
  else
    {}  # No behavior to apply

# Apply codegen behavior from extension
let apply_codegen_behavior = fun codegen_rules ext_value base_schema =>
  # This would be expanded to actually generate code
  # For now, just mark what would be generated
  {
    _codegen = {
      rust_struct = would_generate_rust_struct codegen_rules ext_value base_schema,
      typescript_interface = would_generate_typescript_interface codegen_rules ext_value base_schema,
      python_model = would_generate_python_model codegen_rules ext_value base_schema
    }
  }

# Apply runtime behavior from extension
let apply_runtime_behavior = fun runtime_rules ext_value base_schema =>
  if std.record.has_field "observability" runtime_rules then
    let obs_rules = runtime_rules.observability in
    if std.is_function obs_rules then
      let obs_config = obs_rules ext_value in
      { _observability = obs_config }
    else
      {}
  else
    {}

# Apply directory-specific rules
let apply_directory_rules = fun schema =>
  # This would use the directory _directory.ncl files
  # For now, just mark that directory rules would be applied
  schema & {
    _directory_rules_applied = true
  }

# Generate derived schemas based on extensions
let generate_derived_schemas = fun schema =>
  let extensions = extract_extensions schema in

  # Generate database migration if persistence is defined
  let db_migration = if std.record.has_field "x-familiar-persistence" extensions then
    generate_db_migration schema
  else
    null

  # Generate API routes if service is defined
  let api_routes = if std.record.has_field "x-familiar-service" extensions then
    generate_api_routes schema
  else
    null

  # Generate GraphQL schema if appropriate
  let graphql_schema = if should_generate_graphql schema then
    generate_graphql_schema schema
  else
    null

  {
    database_migration = db_migration,
    api_routes = api_routes,
    graphql_schema = graphql_schema
  }

# Helper functions
let get_directory_path = fun schema =>
  # This would determine the schema's directory path
  # For now, return a placeholder
  "infrastructure/resources"

let would_generate_rust_struct = fun codegen_rules ext_value base_schema =>
  "Would generate Rust struct based on ${base_schema.title or 'Unknown'} with extension ${std.to_string ext_value}"

let would_generate_typescript_interface = fun codegen_rules ext_value base_schema =>
  "Would generate TypeScript interface for ${base_schema.title or 'Unknown'}"

let would_generate_python_model = fun codegen_rules ext_value base_schema =>
  "Would generate Python model for ${base_schema.title or 'Unknown'}"

let generate_db_migration = fun schema =>
  "CREATE TABLE ${schema.'x-familiar-persistence'.table} (...);"

let generate_api_routes = fun schema =>
  let service = schema."x-familiar-service" in
  "Generated API routes for service ${service.name}"

let should_generate_graphql = fun schema =>
  # Logic to determine if GraphQL schema should be generated
  std.record.has_field "x-familiar-kind" schema &&
  schema."x-familiar-kind" == "entity"

let generate_graphql_schema = fun schema =>
  "type ${schema.title or 'Unknown'} { id: ID! }"

# Advanced composition: Merge multiple schemas with conflict resolution
let compose_multiple_schemas = fun schemas =>
  std.array.fold (fun acc schema =>
    acc & resolve_conflicts acc schema
  ) {} schemas

# Conflict resolution strategy
let resolve_conflicts = fun base_schema overlay_schema =>
  # Extension-specific conflict resolution
  let base_extensions = extract_extensions base_schema in
  let overlay_extensions = extract_extensions overlay_schema in

  # For each conflicting extension, apply resolution rules
  let resolved_extensions = std.record.map (fun ext_name overlay_value =>
    let base_value = base_extensions."${ext_name}" or null in
    if base_value != null then
      resolve_extension_conflict ext_name base_value overlay_value
    else
      overlay_value
  ) overlay_extensions

  # Merge non-extension parts with overlay taking precedence
  let base_without_extensions = remove_extensions base_schema in
  let overlay_without_extensions = remove_extensions overlay_schema in

  base_without_extensions & overlay_without_extensions & resolved_extensions

# Resolve conflicts between extension values
let resolve_extension_conflict = fun ext_name base_value overlay_value =>
  if ext_name == "x-familiar-persistence" then
    # For persistence, merge table definitions
    base_value & overlay_value
  else if ext_name == "x-familiar-service" then
    # For services, overlay takes precedence
    overlay_value
  else
    # Default: overlay wins
    overlay_value

# Remove extensions from schema
let remove_extensions = fun schema =>
  std.record.filter (fun key _ => not (std.string.starts_with key "x-familiar-")) schema

# Export the main composition function
{
  compose_schema_with_extensions = compose_schema_with_extensions,
  compose_multiple_schemas = compose_multiple_schemas,
  extract_extensions = extract_extensions,
  apply_extension_behaviors = apply_extension_behaviors
}

```

### versions/v1.1.0-alpha/nickel/composers/simple_test.ncl

```nickel
# Simple test file
{
  test = "hello",
  func = fun x => x + 1
}

```

### versions/v1.1.0-alpha/nickel/composers/working_example.ncl

```nickel
# Working example of layered Nickel architecture
# This demonstrates the concept without complex syntax
let make_interface = fun layer_name =>
  {
    name = layer_name,
    contract = {
      compose = fun config =>
        {
          layer = layer_name,
          config = config
        }
    },
    hydration = {},
    edge = {},
    layer = { type = layer_name }
  }
in

{
  architecture = make_interface "architecture",
  infrastructure = make_interface "infrastructure",
  codegen = make_interface "codegen",

  metadata = {
    description = "Typed collections from merged primitives",
    abstraction_level = "typed_collections",
    primitive_layers_hidden = true
  }
}

```

### versions/v1.1.0-alpha/nickel/domain/_directory.ncl

```nickel
# Import typed collection with extreme & composition
let Composer = import "../composers/directory_composer.ncl" in

# Use extreme & composition - minimal merged blocks from libraries
Composer.domain.Contract.compose {
  extract_from_raw = Composer.domain.extraction,
  validate_pure = Composer.domain.validation,
  get_layer = "domain"
}
```

### versions/v1.1.0-alpha/nickel/domain/agentic/_directory.ncl

```nickel
# Domain subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.domain.Contract.compose {
  extract_from_raw = Composer.domain.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "domain"
}

```

### versions/v1.1.0-alpha/nickel/domain/api/_directory.ncl

```nickel
# Domain subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.domain.Contract.compose {
  extract_from_raw = Composer.domain.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "domain"
}

```

### versions/v1.1.0-alpha/nickel/domain/auth/_directory.ncl

```nickel
# Domain subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.domain.Contract.compose {
  extract_from_raw = Composer.domain.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "domain"
}

```

### versions/v1.1.0-alpha/nickel/domain/config/_directory.ncl

```nickel
# Domain subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.domain.Contract.compose {
  extract_from_raw = Composer.domain.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "domain"
}

```

### versions/v1.1.0-alpha/nickel/domain/contracts/_directory.ncl

```nickel
# Domain subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.domain.Contract.compose {
  extract_from_raw = Composer.domain.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "domain"
}

```

### versions/v1.1.0-alpha/nickel/domain/conversation/_directory.ncl

```nickel
# Domain subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.domain.Contract.compose {
  extract_from_raw = Composer.domain.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "domain"
}

```

### versions/v1.1.0-alpha/nickel/domain/database/_directory.ncl

```nickel
# Domain subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.domain.Contract.compose {
  extract_from_raw = Composer.domain.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "domain"
}

```

### versions/v1.1.0-alpha/nickel/domain/entities_api/_directory.ncl

```nickel
# Domain subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.domain.Contract.compose {
  extract_from_raw = Composer.domain.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "domain"
}

```

### versions/v1.1.0-alpha/nickel/domain/tenant/_directory.ncl

```nickel
# Domain subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.domain.Contract.compose {
  extract_from_raw = Composer.domain.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "domain"
}

```

### versions/v1.1.0-alpha/nickel/domain/ui/_directory.ncl

```nickel
# Domain subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.domain.Contract.compose {
  extract_from_raw = Composer.domain.extraction,
  validate_pure = Composer.codegen.validation,
  get_layer = "domain"
}

```

### versions/v1.1.0-alpha/nickel/extensions/agent-capabilities.ncl

```nickel
/**
 * x-familiar-agent-capabilities Extension
 *
 * Defines AI agent capabilities for orchestration.
 * Enables capability-aware agent orchestration in slotmap+petgraph.
 *
 * @category domain
 * @graph-value medium - enables agent orchestration
 * @validation optional - for agent nodes
 */

{
  extension = {
    name = "x-familiar-agent-capabilities",
    description = "AI agent capability definitions",
    category = "domain",
    required = false,
    version = "1.0.0"
  },

  nickel_type = Array<String>,

  contract = std.contract.custom (fun label value =>
    if std.is_array value && std.array.all (fun item => std.is_string item) value then value
    else std.contract.blame_with label "Agent capabilities must be array of strings: ${std.to_string value}"
  ),

  functions = {
    has_capability = fun capabilities target_capability =>
      std.array.elem target_capability capabilities,

    match_agent_to_task = fun agent_capabilities required_capabilities =>
      std.array.all (fun req => functions.has_capability agent_capabilities req) required_capabilities,

    rank_agents_by_capability = fun agents required_capabilities =>
      std.array.sort_by (fun agent =>
        let agent_caps = agent."x-familiar-agent-capabilities" | [] in
        std.array.length (std.array.filter (fun req => std.array.elem req agent_caps) required_capabilities)
      ) agents
  },

  graph_integration = {
    node_metadata = fun capabilities => {
      agent_capabilities = capabilities,
      capability_count = std.array.length capabilities,
      primary_capabilities = std.array.take 3 capabilities
    },

    graph_constraints = fun node graph_context => {
      let capabilities = node."x-familiar-agent-capabilities" | [] in
      let required_caps = graph_context.required_agent_capabilities | [] in
      
      if std.array.all (fun req => functions.has_capability capabilities req) required_caps then
        { valid = true, errors = [], warnings = [] }
      else
        { valid = false, errors = ["Agent lacks required capabilities"], warnings = [] }
    }
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/allocation-strategy.ncl

```nickel
/**
 * x-familiar-allocation-strategy Extension
 *
 * Defines resource allocation strategies for infrastructure nodes.
 * Enables intelligent resource distribution in slotmap+petgraph.
 *
 * @category infrastructure
 * @graph-value medium - optimizes resource allocation
 * @validation optional - for resource-managed nodes
 */

{
  extension = {
    name = "x-familiar-allocation-strategy",
    description = "Resource allocation strategy",
    category = "infrastructure",
    required = false,
    version = "1.0.0"
  },

  nickel_type = [| `first_fit, `best_fit, `worst_fit, `round_robin |],

  contract = std.contract.custom (fun label value =>
    let valid_strategies = ["first_fit", "best_fit", "worst_fit", "round_robin"] in
    if std.array.elem value valid_strategies then value
    else std.contract.blame_with label "Invalid allocation strategy: ${std.to_string value}"
  ),

  functions = {
    get_strategy_characteristics = fun strategy =>
      if strategy == "first_fit" then { efficiency = "fast", fragmentation = "high" }
      else if strategy == "best_fit" then { efficiency = "optimal", fragmentation = "low" }
      else if strategy == "worst_fit" then { efficiency = "balanced", fragmentation = "medium" }
      else { efficiency = "fair", fragmentation = "medium" }
  },

  graph_integration = {
    node_metadata = fun strategy => {
      allocation_strategy = strategy,
      strategy_characteristics = functions.get_strategy_characteristics strategy
    }
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/architectural-boundary.ncl

```nickel
/**
 * x-familiar-architectural-boundary Extension
 *
 * Defines architectural boundaries for graph structure organization.
 * Enables boundary-aware graph partitioning in slotmap+petgraph.
 *
 * @category architecture
 * @graph-value medium - organizes graph structure
 * @validation optional - for boundary definitions
 */

{
  extension = {
    name = "x-familiar-architectural-boundary",
    description = "Architectural boundary definitions",
    category = "architecture",
    required = false,
    version = "1.0.0"
  },

  nickel_type = {
    type: String,
    name: String,
    responsibilities: Array<String>
  },

  contract = std.contract.custom (fun label value =>
    if std.is_record value &&
       std.record.has_field "type" value &&
       std.record.has_field "name" value then value
    else std.contract.blame_with label "Boundary must have type and name: ${std.to_string value}"
  ),

  functions = {
    get_boundary_type = fun boundary =>
      boundary.type,

    validate_boundary_consistency = fun boundary graph_context =>
      # Check if boundary aligns with architectural context
      let boundary_type = functions.get_boundary_type boundary in
      let allowed_types = ["service", "module", "layer", "context", "aggregate"] in
      std.array.elem boundary_type allowed_types
  },

  graph_integration = {
    node_metadata = fun boundary => {
      boundary_definition = boundary,
      boundary_type = functions.get_boundary_type boundary,
      boundary_name = boundary.name,
      boundary_responsibilities = boundary.responsibilities
    }
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/architectural-pattern.ncl

```nickel
/**
 * x-familiar-architectural-pattern Extension
 *
 * Defines architectural patterns for graph structure validation.
 * Enables pattern-aware graph analysis in slotmap+petgraph.
 *
 * @category architecture
 * @graph-value high - validates graph structure patterns
 * @validation context-dependent - for architecture nodes
 */

{
  extension = {
    name = "x-familiar-architectural-pattern",
    description = "Architectural pattern classification",
    category = "architecture",
    required = false,
    version = "1.0.0",
    context_required = ["topology"]
  },

  nickel_type = [|
    `layered, `microservices, `event_driven, `hexagonal,
    `cqrs, `serverless, `monolithic, `modular, `pipeline
  |],

  contract = std.contract.custom (fun label value =>
    let valid_patterns = [
      "layered", "microservices", "event_driven", "hexagonal",
      "cqrs", "serverless", "monolithic", "modular", "pipeline"
    ] in
    if std.array.elem value valid_patterns then value
    else std.contract.blame_with label "Invalid architectural pattern: ${std.to_string value}"
  ),

  functions = {
    get_pattern_characteristics = fun pattern =>
      if pattern == "layered" then {
        coupling = "loose", communication = "strict_layers", scalability = "vertical"
      } else if pattern == "microservices" then {
        coupling = "loose", communication = "api_contracts", scalability = "horizontal"
      } else if pattern == "event_driven" then {
        coupling = "loose", communication = "events", scalability = "horizontal"
      } else {
        coupling = "tight", communication = "direct", scalability = "vertical"
      },

    validate_pattern_constraints = fun pattern graph_structure =>
      # Pattern-specific graph validation
      if pattern == "layered" then
        validate_layered_constraints graph_structure
      else if pattern == "microservices" then
        validate_microservices_constraints graph_structure
      else
        true
  },

  graph_integration = {
    node_metadata = fun pattern => {
      architectural_pattern = pattern,
      pattern_characteristics = functions.get_pattern_characteristics pattern,
      structural_constraints = get_pattern_constraints pattern
    },

    graph_constraints = fun node graph_context => {
      let pattern = node."x-familiar-architectural-pattern" in
      if functions.validate_pattern_constraints pattern graph_context then
        { valid = true, errors = [], warnings = [] }
      else
        { valid = false, errors = ["Graph structure violates ${pattern} pattern constraints"], warnings = [] }
    }
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/business-rules.ncl

```nickel
/**
 * x-familiar-business-rules Extension
 *
 * Defines business rules for domain logic validation.
 * Enables rule-aware graph constraints in slotmap+petgraph.
 *
 * @category domain
 * @graph-value high - enforces business constraints
 * @validation context-dependent - for domain nodes
 */

{
  extension = {
    name = "x-familiar-business-rules",
    description = "Business rule definitions",
    category = "domain",
    required = false,
    version = "1.0.0",
    context_required = ["domain"]
  },

  nickel_type = Array<String>,

  contract = std.contract.custom (fun label value =>
    if std.is_array value && std.array.all (fun item => std.is_string item) value then value
    else std.contract.blame_with label "Business rules must be array of strings: ${std.to_string value}"
  ),

  functions = {
    validate_business_consistency = fun rules graph_context =>
      # Check if business rules are consistent across the domain
      let domain_rules = graph_context.business_rules | [] in
      std.array.all (fun rule => std.array.elem rule domain_rules) rules,

    categorize_rules = fun rules =>
      std.array.map (fun rule =>
        if std.string.contains "must" rule then "invariant"
        else if std.string.contains "should" rule then "guideline"
        else "constraint"
      ) rules
  },

  graph_integration = {
    node_metadata = fun rules => {
      business_rules = rules,
      rule_count = std.array.length rules,
      rule_categories = functions.categorize_rules rules,
      business_constraints = extract_constraints rules
    },

    graph_constraints = fun node graph_context => {
      let rules = node."x-familiar-business-rules" | [] in
      if functions.validate_business_consistency rules graph_context then
        { valid = true, errors = [], warnings = [] }
      else
        { valid = false, errors = ["Business rules violate domain consistency"], warnings = [] }
    }
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/capabilities.ncl

```nickel
/**
 * x-familiar-capabilities Extension
 *
 * Defines what a node can do in the graph.
 * Enables capability-aware graph queries and orchestration.
 *
 * @category infrastructure
 * @graph-value high - enables capability-based orchestration
 * @validation optional - for functional nodes
 */

{
  extension = {
    name = "x-familiar-capabilities",
    description = "Node capability definitions",
    category = "infrastructure",
    required = false,
    version = "1.0.0"
  },

  nickel_type = Array<String>,

  contract = std.contract.custom (fun label value =>
    if std.is_array value && std.array.all (fun item => std.is_string item) value then value
    else std.contract.blame_with label "Capabilities must be array of strings: ${std.to_string value}"
  ),

  functions = {
    has_capability = fun capabilities target_capability =>
      std.array.elem target_capability capabilities,

    find_compatible_nodes = fun required_capabilities available_nodes =>
      std.array.filter (fun node =>
        let node_caps = node."x-familiar-capabilities" | [] in
        std.array.all (fun req_cap =>
          std.array.elem req_cap node_caps
        ) required_capabilities
      ) available_nodes
  },

  graph_integration = {
    node_metadata = fun capabilities => {
      node_capabilities = capabilities,
      capability_count = std.array.length capabilities,
      primary_capability = std.array.first capabilities
    },

    graph_constraints = fun node graph_context => {
      let capabilities = node."x-familiar-capabilities" | [] in
      let required_capabilities = graph_context.required_capabilities | [] in
      
      if std.array.all (fun req => std.array.elem req capabilities) required_capabilities then
        { valid = true, errors = [], warnings = [] }
      else
        { valid = false, errors = ["Missing required capabilities"], warnings = [] }
    }
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/codegen-targets.ncl

```nickel
/**
 * x-familiar-codegen-targets Extension
 *
 * Defines code generation targets for graph nodes.
 * Enables multi-language code generation from slotmap+petgraph structure.
 *
 * @category generation
 * @graph-value high - drives code generation pipeline
 * @validation optional - defaults provided
 */

{
  extension = {
    name = "x-familiar-codegen-targets",
    description = "Target languages for code generation",
    category = "generation",
    required = false,
    version = "1.0.0"
  },

  nickel_type = Array<String>,

  contract = std.contract.custom (fun label value =>
    if std.is_array value &&
       std.array.all (fun target =>
         std.array.elem target ["rust", "typescript", "python", "go", "java"]
       ) value then value
    else std.contract.blame_with label "Invalid codegen targets: ${std.to_string value}"
  ),

  defaults = {
    targets = ["rust", "typescript"]
  },

  functions = {
    get_target_capabilities = fun targets =>
      std.array.map (fun target =>
        if target == "rust" then { systems_programming = true, performance = true }
        else if target == "typescript" then { web_development = true, type_safety = true }
        else if target == "python" then { scripting = true, libraries = true }
        else if target == "go" then { concurrency = true, simplicity = true }
        else { general_purpose = true }
      ) targets
  },

  graph_integration = {
    node_metadata = fun targets => {
      codegen_targets = targets,
      target_capabilities = functions.get_target_capabilities targets,
      generation_pipeline = "multi_language"
    }
  },

  codegen = {
    self_referential = true,  # This extension drives its own code generation
    pipeline_integration = true
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/component-type.ncl

```nickel
/**
 * x-familiar-component-type Extension
 *
 * Defines the ECS component classification for graph nodes.
 * Provides semantic meaning for component composition in slotmap+petgraph.
 *
 * @category entity
 * @graph-value high - classifies ECS components for composition
 * @validation context-dependent - only required for component schemas
 */

{
  # ============================================================================
  # EXTENSION METADATA
  # ============================================================================

  extension = {
    name = "x-familiar-component-type",
    description = "ECS component classification for entity composition",
    category = "entity",
    required = false,
    version = "1.0.0",
    context_required = ["entity"]  # Only for entity schemas
  },

  # ============================================================================
  # NICKEL TYPE SYSTEM INTEGRATION
  # ============================================================================

  nickel_type = [| `ecs_component, `data_structure, `value_object, `entity |],

  # ============================================================================
  # CONTRACT DEFINITION
  # ============================================================================

  contract = std.contract.custom (fun label value =>
    let valid_types = ["ecs_component", "data_structure", "value_object", "entity"] in
    if std.array.elem value valid_types then
      value
    else
      std.contract.blame_with label "x-familiar-component-type must be one of: ecs_component, data_structure, value_object, entity. Got: ${std.to_string value}"
  ),

  # ============================================================================
  # MERGE STRATEGIES
  # ============================================================================

  merge_strategies = {
    override = fun base override => override,
    compose = fun base override => override,
    validate = fun base override =>
      if contract.validate override then override
      else std.contract.blame_with "merge" "Invalid x-familiar-component-type in merge: ${std.to_string override}"
  },

  # ============================================================================
  # DEFAULTS & METADATA
  # ============================================================================

  defaults = {
    validation = true
  },

  metadata = {
    required = false,
    examples = ["ecs_component", "data_structure", "value_object"],
    since = "v1.0.0",
    graph_impact = "component_composition"
  },

  # ============================================================================
  # FUNCTION LIBRARY
  # ============================================================================

  functions = {
    validate_component_type = fun value =>
      std.array.elem value ["ecs_component", "data_structure", "value_object", "entity"],

    # Get ECS characteristics
    get_ecs_properties = fun component_type =>
      if component_type == "ecs_component" then {
        has_data = true,
        has_behavior = false,
        storable = true,
        serializable = true
      } else if component_type == "data_structure" then {
        has_data = true,
        has_behavior = false,
        storable = true,
        serializable = true
      } else if component_type == "value_object" then {
        has_data = true,
        has_behavior = false,
        storable = false,
        serializable = true
      } else {  # entity
        has_data = true,
        has_behavior = true,
        storable = true,
        serializable = true
      },

    # Check composition compatibility
    can_compose_with = fun component_a component_b =>
      let props_a = functions.get_ecs_properties component_a in
      let props_b = functions.get_ecs_properties component_b in
      # Entities can contain components, but not vice versa
      if component_a == "entity" then
        component_b != "entity"
      else if component_b == "entity" then
        false
      else
        true,

    # Get storage requirements
    get_storage_requirements = fun component_type =>
      if component_type == "ecs_component" then "persistent"
      else if component_type == "data_structure" then "persistent"
      else if component_type == "value_object" then "transient"
      else "persistent"
  },

  # ============================================================================
  # GRAPH INTEGRATION
  # ============================================================================

  graph_integration = {
    # Add ECS metadata to component nodes
    node_metadata = fun component_type_value => {
      component_type = component_type_value,
      ecs_properties = functions.get_ecs_properties component_type_value,
      storage_requirements = functions.get_storage_requirements component_type_value,
      composition_capabilities = get_composition_capabilities component_type_value
    },

    # Validate component composition in graph
    graph_constraints = fun node graph_context => {
      let component_type = node."x-familiar-component-type" in
      let connected_nodes = graph_context.neighbors | [] in

      # Check composition compatibility with connected components
      let compatibility_issues = std.array.filter_map
        (fun neighbor =>
          if std.record.has_field "x-familiar-component-type" neighbor then
            let neighbor_type = neighbor."x-familiar-component-type" in
            if functions.can_compose_with component_type neighbor_type then
              null
            else
              "Component ${component_type} cannot compose with ${neighbor_type}"
          else
            null
        )
        connected_nodes in

      if std.array.is_empty compatibility_issues then
        { valid = true, errors = [], warnings = [] }
      else
        { valid = false, errors = compatibility_issues, warnings = [] }
    },

    # Generate ECS code from graph relationships
    generate_from_graph = fun node graph_context => {
      let component_type = node."x-familiar-component-type" in
      let ecs_props = functions.get_ecs_properties component_type in

      # Generate component-specific code
      generate_component_struct component_type node graph_context &
      generate_storage_logic component_type node graph_context &
      generate_composition_logic component_type node graph_context
    }
  },

  # ============================================================================
  # CODE GENERATION IMPLICATIONS
  # ============================================================================

  codegen = {
    rust = {
      derives = fun component_type =>
        let base = ["Debug", "Clone"] in
        if component_type == "ecs_component" then
          base @ ["Serialize", "Deserialize", "Default"]
        else if component_type == "value_object" then
          base @ ["Serialize", "Deserialize", "PartialEq", "Eq", "Hash"]
        else
          base @ ["Serialize", "Deserialize"],

      traits = fun component_type =>
        if component_type == "ecs_component" then ["Component"]
        else if component_type == "entity" then ["Entity"]
        else []
    },

    typescript = {
      interfaces = fun component_type =>
        if component_type == "ecs_component" then ["Component", "Serializable"]
        else if component_type == "value_object" then ["ValueObject", "Equatable"]
        else ["Serializable"]
    }
  },

  # ============================================================================
  # COMPOSITION RULES
  # ============================================================================

  composition_rules = {
    compatible_with = ["x-familiar-type-category", "x-familiar-codegen-targets"],
    validation_order = 2,
    inheritable = true
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/composition-type.ncl

```nickel
/**
 * x-familiar-composition-type Extension
 *
 * Defines composition patterns for graph assembly.
 * Enables composition-aware graph construction in slotmap+petgraph.
 *
 * @category architecture
 * @graph-value medium - guides graph composition
 * @validation optional - for composition definitions
 */

{
  extension = {
    name = "x-familiar-composition-type",
    description = "System composition patterns",
    category = "architecture",
    required = false,
    version = "1.0.0"
  },

  nickel_type = [| `system_assembly, `service_composition, `module_aggregation |],

  contract = std.contract.custom (fun label value =>
    let valid_types = ["system_assembly", "service_composition", "module_aggregation"] in
    if std.array.elem value valid_types then value
    else std.contract.blame_with label "Invalid composition type: ${std.to_string value}"
  ),

  functions = {
    get_composition_strategy = fun composition_type =>
      if composition_type == "system_assembly" then {
        assembly_strategy = "hierarchical", dependency_resolution = "topological"
      } else if composition_type == "service_composition" then {
        assembly_strategy = "contract_based", dependency_resolution = "interface_matching"
      } else {
        assembly_strategy = "modular", dependency_resolution = "capability_matching"
      }
  },

  graph_integration = {
    node_metadata = fun composition_type => {
      composition_type = composition_type,
      composition_strategy = functions.get_composition_strategy composition_type,
      assembly_pattern = get_assembly_pattern composition_type
    }
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/contract.ncl

```nickel
/**
 * x-familiar-contract Extension
 *
 * Defines interface contracts for graph nodes.
 * Provides type-safe interface definitions for slotmap+petgraph nodes.
 *
 * @category interfaces
 * @graph-value high - enables type-safe graph operations
 * @validation optional - for service interfaces
 */

{
  extension = {
    name = "x-familiar-contract",
    description = "Interface contract definitions",
    category = "interfaces",
    required = false,
    version = "1.0.0"
  },

  nickel_type = {
    inputs: Record,
    outputs: Record,
    side_effects: Array<String>
  },

  contract = std.contract.custom (fun label value =>
    if std.is_record value &&
       std.record.has_field "inputs" value &&
       std.record.has_field "outputs" value then value
    else std.contract.blame_with label "Contract must have inputs and outputs: ${std.to_string value}"
  ),

  functions = {
    validate_contract_compatibility = fun contract_a contract_b =>
      # Check if contracts are compatible for composition
      let inputs_match = deep_equal contract_a.inputs contract_b.outputs in
      let outputs_match = deep_equal contract_a.outputs contract_b.inputs in
      inputs_match || outputs_match
  },

  graph_integration = {
    node_metadata = fun contract => {
      interface_contract = contract,
      input_types = std.record.keys contract.inputs,
      output_types = std.record.keys contract.outputs,
      contract_hash = hash_contract contract
    },

    graph_constraints = fun node graph_context => {
      # Validate contract compatibility with connected nodes
      let connected_contracts = get_connected_contracts node graph_context in
      let compatibility_errors = validate_contract_chain node."x-familiar-contract" connected_contracts in
      {
        valid = std.array.is_empty compatibility_errors,
        errors = compatibility_errors,
        warnings = []
      }
    }
  },

  codegen = {
    rust = {
      traits = ["Contract", "Callable"]
    },
    typescript = {
      interfaces = ["Contract", "TypeSafe"]
    }
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/description.ncl

```nickel
/**
 * x-familiar-description Extension
 *
 * Provides human-readable documentation for graph nodes.
 * Enables self-documenting graph structures in slotmap+petgraph.
 *
 * @category metadata
 * @graph-value medium - improves graph usability
 * @validation optional - documentation
 */

{
  extension = {
    name = "x-familiar-description",
    description = "Human-readable documentation",
    category = "metadata",
    required = false,
    version = "1.0.0"
  },

  nickel_type = String,

  contract = std.contract.custom (fun label value =>
    if std.is_string value && std.string.length value > 0 then value
    else std.contract.blame_with label "Description must be non-empty string: ${std.to_string value}"
  ),

  functions = {
    generate_summary = fun description =>
      let words = std.string.split " " description in
      if std.array.length words > 10 then
        std.string.join " " (std.array.take 10 words) ++ "..."
      else
        description,

    extract_keywords = fun description =>
      std.string.split " " description
  },

  graph_integration = {
    node_metadata = fun description => {
      description = description,
      summary = functions.generate_summary description,
      keywords = functions.extract_keywords description,
      documentation_type = "human_readable"
    }
  },

  merge_strategies = {
    compose = fun base override => base ++ ". " ++ override
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/domain-context.ncl

```nickel
/**
 * x-familiar-domain-context Extension
 *
 * Defines bounded context for domain logic validation.
 * Enables domain-aware graph constraints in slotmap+petgraph.
 *
 * @category domain
 * @graph-value high - validates domain boundaries
 * @validation context-dependent - for domain nodes
 */

{
  extension = {
    name = "x-familiar-domain-context",
    description = "Bounded context classification",
    category = "domain",
    required = false,
    version = "1.0.0",
    context_required = ["domain"]
  },

  nickel_type = String,

  contract = std.contract.custom (fun label value =>
    if std.is_string value && std.string.length value > 0 then value
    else std.contract.blame_with label "Domain context must be non-empty string: ${std.to_string value}"
  ),

  functions = {
    validate_context_boundaries = fun context graph_context =>
      # Check if domain context aligns with architectural boundaries
      let domain_contexts = graph_context.domain_contexts | [] in
      std.array.elem context domain_contexts,

    get_context_relationships = fun context =>
      # Define valid relationships between domain contexts
      if context == "user_management" then ["authentication", "authorization"]
      else if context == "data_processing" then ["storage", "computation"]
      else ["generic"]
  },

  graph_integration = {
    node_metadata = fun context => {
      domain_context = context,
      context_relationships = functions.get_context_relationships context,
      boundary_requirements = get_boundary_requirements context
    },

    graph_constraints = fun node graph_context => {
      let context = node."x-familiar-domain-context" in
      if functions.validate_context_boundaries context graph_context then
        { valid = true, errors = [], warnings = [] }
      else
        { valid = false, errors = ["Domain context ${context} violates boundary constraints"], warnings = [] }
    }
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/edge-declaration-contract.ncl

```nickel
/**
 * x-familiar-edge-declaration-contract Extension
 *
 * CONTRACT ENFORCER for explicit edge type declarations in JSON schemas.
 * Prohibits bare $ref arrays and requires typed edge structures for Frame Graph compatibility.
 *
 * This contract ensures schemas declare relationships using:
 *   "x-familiar-edges": [
 *     { "edge_type": "depends_on", "target": {"$ref": "Component.json"} }
 *   ]
 *
 * Instead of the old implicit:
 *   "x-familiar-depends": [{"$ref": "Component.json"}]
 *
 * @category architecture
 * @graph-value critical - enforces Frame Graph structure
 * @validation schema-level - validates entire schema structure
 * @contract strict - no exceptions for Frame Graph compatibility
 */

{
  extension = {
    name = "x-familiar-edge-declaration-contract",
    description = "Contract enforcer for explicit edge type declarations",
    category = "architecture",
    required = true,  # This MAKES it a contract - schemas MUST comply
    version = "1.0.0",
    context_required = ["topology", "entity", "component", "system", "node"]
  },

  # ============================================================================
  # STRUCTURAL CONTRACT - The Core Enforcement
  # ============================================================================

  contract = std.contract.custom (fun label schema =>
    let relationship_fields = [
      "x-familiar-depends", "x-familiar-reads", "x-familiar-writes",
      "x-familiar-components", "x-familiar-systems", "x-familiar-resources",
      "x-familiar-service", "x-familiar-queue"
    ] in

    # Check if this schema needs edge validation
    let needs_validation = std.record.has_field "x-familiar-kind" schema &&
                          std.array.elem schema."x-familiar-kind" [
                            "entity", "component", "system", "node", "topology"
                          ] in

    if needs_validation then
      # Validate all relationship fields
      let violations = std.array.flat_map (fun field_name =>
        if std.record.has_field field_name schema then
          let field_value = schema."%{field_name}" in
          validate_relationship_field field_name field_value
        else
          []
      ) relationship_fields in

      if std.array.is_empty violations then
        schema  # Valid - return the schema unchanged
      else
        std.contract.blame_with label
          "Edge Declaration Contract Violations: Use x-familiar-edges array with explicit edge types instead of bare $ref arrays"
    else
      schema  # Skip validation for schemas that don't declare relationships
  ),

  # ============================================================================
  # VALIDATION FUNCTIONS
  # ============================================================================

  functions = {
    # Validate a single relationship field
    validate_relationship_field = fun field_name field_value =>
      if is_array_of_refs field_value then
        ["Bare $ref arrays prohibited. Use {edge_type, target} objects instead."]
      else if is_array_of_edge_declarations field_value then
        []  # Valid new format
      else if std.is_array field_value then
        ["Array elements must be {edge_type, target} objects."]
      else
        ["Must be array of {edge_type, target} objects."],

    # Check if value is old-style bare $ref array
    is_array_of_refs = fun value =>
      std.is_array value &&
      std.array.length value > 0 &&
      std.array.any (fun item =>
        std.is_record item && std.record.has_field "$ref" item &&
        !std.record.has_field "edge_type" item
      ) value,

    # Check if value is new-style edge declarations
    is_array_of_edge_declarations = fun value =>
      std.is_array value &&
      std.array.all (fun item =>
        std.is_record item &&
        std.record.has_field "edge_type" item &&
        std.record.has_field "target" item &&
        std.is_record item.target &&
        std.record.has_field "$ref" item.target
      ) value,

    # ============================================================================
    # EXTRACTION FUNCTIONS - For Frame Graph Building
    # ============================================================================

    # Extract all edges from a schema for Frame Graph construction
    extract_edges = fun schema =>
      let relationship_fields = [
        "x-familiar-depends", "x-familiar-reads", "x-familiar-writes",
        "x-familiar-components", "x-familiar-systems", "x-familiar-resources",
        "x-familiar-service", "x-familiar-queue"
      ] in

      std.array.flat_map (fun field_name =>
        if std.record.has_field field_name schema then
          let declarations = schema."%{field_name}" in
          if is_array_of_edge_declarations declarations then
            std.array.map (fun decl => {
              source_schema = schema."$id" | schema,
              edge_type = decl.edge_type,
              target_ref = decl.target."$ref",
              field_type = field_name,
              metadata = decl.metadata | {}
            }) declarations
          else
            []  # Skip invalid declarations (will be caught by contract)
        else
          []
      ) relationship_fields,

    # ============================================================================
    # MIGRATION FUNCTIONS - Transform old schemas
    # ============================================================================

    # Inject default edge types for common patterns (migration helper)
    inject_default_edge_types = fun schema =>
      let inject_field = fun field_name default_edge_type schema =>
        if std.record.has_field field_name schema then
          let old_value = schema."%{field_name}" in
          if is_array_of_refs old_value then
            # Transform old format to new format
            let new_value = std.array.map (fun ref_obj => {
              edge_type = default_edge_type,
              target = ref_obj,
              metadata = { migrated_from = field_name }
            }) old_value in
            schema & { "%{field_name}" = new_value }
          else
            schema
        else
          schema
      in

      # Apply migrations with defaults based on field semantics
      schema
      |> inject_field "x-familiar-depends" "depends_on"
      |> inject_field "x-familiar-reads" "references"
      |> inject_field "x-familiar-writes" "transforms"
      |> inject_field "x-familiar-components" "contains"
      |> inject_field "x-familiar-systems" "orchestrates"
      |> inject_field "x-familiar-resources" "depends_on"
      |> inject_field "x-familiar-service" "deploys_to"
      |> inject_field "x-familiar-queue" "communicates_with",

    # ============================================================================
    # VALIDATION HELPERS
    # ============================================================================

    # Get allowed edge types for a given context
    get_allowed_edge_types = fun schema_kind =>
      let global_edges = import "../edge-type.ncl" in
      let edge_names = std.record.fields global_edges.edge_types in

      # Context-specific restrictions
      if schema_kind == "entity" then
        # Entities can only reference and depend
        std.array.filter (fun edge => std.array.elem edge ["depends_on", "references"]) edge_names
      else if schema_kind == "component" then
        # Components have broader relationship options
        edge_names
      else if schema_kind == "system" then
        # Systems orchestrate and communicate
        std.array.filter (fun edge => std.array.elem edge ["orchestrates", "communicates_with", "depends_on"]) edge_names
      else if schema_kind == "node" then
        # Nodes contain systems and provide resources
        std.array.filter (fun edge => std.array.elem edge ["contains", "provides", "depends_on"]) edge_names
      else
        edge_names,  # Default to all

    # Validate edge type is allowed for schema kind
    validate_edge_type_allowed = fun edge_type schema_kind =>
      let allowed = functions.get_allowed_edge_types schema_kind in
      std.array.elem edge_type allowed
  },

  # ============================================================================
  # MERGE STRATEGIES - Strict enforcement
  # ============================================================================

  merge_strategies = {
    override = fun base override =>
      # Only allow override if both are valid edge declarations
      if contract.validate base && contract.validate override then
        override
      else
        std.contract.blame "Cannot merge invalid edge declarations",

    compose = fun base override =>
      std.contract.blame "Edge declarations cannot be composed - use explicit override",

    validate = fun base override =>
      if contract.validate override then override
      else std.contract.blame_with "merge" "Invalid edge declaration in merge"
  },

  # ============================================================================
  # METADATA & EXAMPLES
  # ============================================================================

  defaults = {
    validation = true,
    migration = false  # Don't auto-migrate by default
  },

  metadata = {
    required = true,
    examples = [
      # Valid new format
      {
        "x-familiar-edges": [
          {
            "edge_type": "depends_on",
            "target": {"$ref": "../components/DatabasePool.component.json"},
            "metadata": {"strength": "strong"}
          }
        ]
      }
    ],
    since = "v1.1.0",
    breaking_change = true,  # This enforces a breaking change to Frame Graph format
    graph_impact = "enforced_topology"
  },

  # ============================================================================
  # TESTING FRAMEWORK
  # ============================================================================

  test_cases = [
    # Valid edge declarations
    {
      name = "valid_edge_declarations",
      input = {
        "x-familiar-kind" = "component",
        "x-familiar-depends" = [
          {
            "edge_type" = "depends_on",
            "target" = {"$ref" = "../components/DatabasePool.component.json"}
          }
        ]
      },
      expected_valid = true,
      description = "Valid edge declarations should pass contract validation"
    },

    # Invalid: bare $ref array
    {
      name = "bare_ref_array_violation",
      input = {
        "x-familiar-kind" = "component",
        "x-familiar-depends" = [
          {"$ref" = "../components/DatabasePool.component.json"}
        ]
      },
      expected_valid = false,
      description = "Bare $ref arrays should violate the contract"
    },

    # Invalid: missing target field
    {
      name = "missing_target_field",
      input = {
        "x-familiar-kind" = "component",
        "x-familiar-depends" = [
          {
            "edge_type" = "depends_on"
            # Missing target field
          }
        ]
      },
      expected_valid = false,
      description = "Missing target field should violate contract"
    }
  ]
}
```

### versions/v1.1.0-alpha/nickel/extensions/edge-type.ncl

```nickel
# x-familiar-edge-type Extension
#
# Defines edge relationship semantics in the graph structure.
# Enables typed edge classification in slotmap+petgraph for the compiler.
#
# @category architecture
# @graph-value high - provides edge semantics for petgraph relationships
# @validation context-dependent - for topology relationships

{
  # ============================================================================
  # EXTENSION METADATA
  # ============================================================================

  extension = {
    name = "x-familiar-edge-type",
    description = "Edge relationship type classification for graph topology",
    category = "architecture",
    required = false,
    version = "1.0.0",
    context_required = ["topology"]  # Only for topology schemas
  },

  # ============================================================================
  # CONTRACT DEFINITION
  # ============================================================================

  contract = std.contract.custom (fun label value =>
    let valid_edge_types = [
      "depends_on", "communicates_with", "contains", "implements",
      "extends", "aggregates", "orchestrates", "transforms",
      "references", "configures", "deploys_to", "routes_to"
    ] in
    if std.array.elem value valid_edge_types then value
    else std.contract.blame_with label "x-familiar-edge-type must be one of: depends_on, communicates_with, contains, implements, extends, aggregates, orchestrates, transforms, references, configures, deploys_to, routes_to. Got: ${std.to_string value}"
  ),

  # ============================================================================
  # MERGE STRATEGIES
  # ============================================================================

  merge_strategies = {
    override = fun base override => override,
    compose = fun base override => override,  # Edge types typically don't compose
    validate = fun base override =>
      if contract.validate override then override
      else std.contract.blame_with "merge" "Invalid x-familiar-edge-type in merge: ${std.to_string override}"
  },

  # ============================================================================
  # DEFAULTS & METADATA
  # ============================================================================

  defaults = {
    validation = true
  },

  metadata = {
    required = false,
    examples = ["depends_on", "communicates_with", "contains"],
    since = "v1.0.0",
    graph_impact = "edge_semantics"
  },

  # ============================================================================
  # FUNCTION LIBRARY
  # ============================================================================

  functions = {
    # Validate edge type
    validate_edge_type = fun value =>
      std.array.elem value [
        "depends_on", "communicates_with", "contains", "implements",
        "extends", "aggregates", "orchestrates", "transforms",
        "references", "configures", "deploys_to", "routes_to"
      ],

    # Get edge characteristics for graph traversal and optimization
    get_edge_characteristics = fun edge_type =>
      if edge_type == "depends_on" then {
        directionality = "directed",
        cardinality = "many_to_one",
        transitivity = true,           # A depends on B, B depends on C  A depends on C
        cyclicity = "acyclic",         # No circular dependencies
        data_flow = "none",            # No data flows through this edge
        strength = "strong"            # Breaking this edge breaks the system
      } else if edge_type == "communicates_with" then {
        directionality = "bidirectional",
        cardinality = "many_to_many",
        transitivity = false,
        cyclicity = "cyclic_allowed",   # Services can communicate in cycles
        data_flow = "bidirectional",
        strength = "medium"
      } else if edge_type == "contains" then {
        directionality = "directed",
        cardinality = "one_to_many",
        transitivity = false,
        cyclicity = "acyclic",
        data_flow = "containment",
        strength = "strong"
      } else if edge_type == "implements" then {
        directionality = "directed",
        cardinality = "many_to_one",
        transitivity = false,
        cyclicity = "acyclic",
        data_flow = "inheritance",
        strength = "strong"
      } else if edge_type == "extends" then {
        directionality = "directed",
        cardinality = "one_to_one",
        transitivity = true,
        cyclicity = "acyclic",
        data_flow = "extension",
        strength = "medium"
      } else if edge_type == "aggregates" then {
        directionality = "directed",
        cardinality = "one_to_many",
        transitivity = false,
        cyclicity = "acyclic",
        data_flow = "aggregation",
        strength = "medium"
      } else if edge_type == "orchestrates" then {
        directionality = "directed",
        cardinality = "one_to_many",
        transitivity = false,
        cyclicity = "acyclic",
        data_flow = "control_flow",
        strength = "strong"
      } else if edge_type == "transforms" then {
        directionality = "directed",
        cardinality = "one_to_one",
        transitivity = false,
        cyclicity = "acyclic",
        data_flow = "transformation",
        strength = "medium"
      } else if edge_type == "references" then {
        directionality = "directed",
        cardinality = "many_to_one",
        transitivity = false,
        cyclicity = "cyclic_allowed",
        data_flow = "reference",
        strength = "weak"
      } else if edge_type == "configures" then {
        directionality = "directed",
        cardinality = "one_to_one",
        transitivity = false,
        cyclicity = "acyclic",
        data_flow = "configuration",
        strength = "medium"
      } else if edge_type == "deploys_to" then {
        directionality = "directed",
        cardinality = "many_to_one",
        transitivity = false,
        cyclicity = "acyclic",
        data_flow = "deployment",
        strength = "medium"
      } else if edge_type == "routes_to" then {
        directionality = "directed",
        cardinality = "one_to_one",
        transitivity = false,
        cyclicity = "cyclic_allowed",
        data_flow = "routing",
        strength = "weak"
      } else {
        directionality = "directed",
        cardinality = "one_to_one",
        transitivity = false,
        cyclicity = "acyclic",
        data_flow = "unknown",
        strength = "weak"
      },

    # Validate edge compatibility between node types
    validate_edge_compatibility = fun source_node target_node edge_type =>
      let source_kind = std.record.get_or "x-familiar-kind" source_node "unknown" in
      let target_kind = std.record.get_or "x-familiar-kind" target_node "unknown" in
      let source_type = std.record.get_or "x-familiar-node-type" source_node source_kind in
      let target_type = std.record.get_or "x-familiar-node-type" target_node target_kind in

      if edge_type == "depends_on" then
        # Infrastructure depends on infrastructure, entities depend on entities
        source_kind == target_kind ||
        (source_kind == "node" && target_kind == "node")
      else if edge_type == "contains" then
        # Only entities can contain other entities
        source_kind == "entity" && target_kind == "entity"
      else if edge_type == "communicates_with" then
        # Services can communicate with services
        source_type == "api_service" || target_type == "api_service"
      else if edge_type == "implements" then
        # Entities can implement domain concepts
        source_kind == "entity" && target_kind == "domain"
      else if edge_type == "orchestrates" then
        # Infrastructure can orchestrate other infrastructure
        source_kind == "node" && target_kind == "node"
      else if edge_type == "deploys_to" then
        # Anything can be deployed to infrastructure
        target_kind == "node"
      else
        true,  # Allow other combinations

    # Get traversal rules for this edge type
    get_traversal_rules = fun edge_type =>
      let chars = functions.get_edge_characteristics edge_type in
      {
        can_traverse = chars.directionality != "none",
        is_bidirectional = chars.directionality == "bidirectional",
        allows_cycles = chars.cyclicity == "cyclic_allowed",
        transitive = chars.transitivity
      },

    # Get compilation implications for code generation
    get_compilation_implications = fun edge_type =>
      if edge_type == "depends_on" then {
        generate_dependency_injection = true,
        generate_initialization_order = true,
        generate_lifecycle_management = true
      } else if edge_type == "communicates_with" then {
        generate_network_client = true,
        generate_api_calls = true,
        generate_error_handling = true
      } else if edge_type == "contains" then {
        generate_composition_logic = true,
        generate_ecs_relationships = true
      } else if edge_type == "orchestrates" then {
        generate_workflow_coordination = true,
        generate_state_management = true
      } else {
        generate_basic_relationship = true
      },

    # Get optimization hints for edge type
    get_optimization_hints = fun edge_type =>
      if edge_type == "depends_on" then {
        prefer_eager_loading = true,
        cache_relationship = true,
        parallel_initialization = false
      } else if edge_type == "communicates_with" then {
        prefer_async_calls = true,
        implement_circuit_breaker = true,
        add_retry_logic = true
      } else if edge_type == "orchestrates" then {
        use_workflow_engine = true,
        implement_transaction_boundaries = true,
        add_compensation_logic = true
      } else {
        basic_optimization = true
      }
  },

  # ============================================================================
  # GRAPH INTEGRATION
  # ============================================================================

  # Helper function to get node by ID (placeholder)
  get_node_by_id = fun node_id => {
    id = node_id,
    kind = "unknown",
    schema = {}
  },

  # Helper function to generate edge code (placeholder)
  generate_edge_code = fun edge_type edge_list implications graph_context => {
    edge_type = edge_type,
    edge_count = std.array.length edge_list,
    implications = implications,
    generated_code = "placeholder_code"
  },

  graph_integration = {
    # Add semantic metadata to graph edges
    edge_metadata = fun edge_type => {
      edge_type = edge_type,
      characteristics = functions.get_edge_characteristics edge_type,
      traversal_rules = functions.get_traversal_rules edge_type,
      compilation_implications = functions.get_compilation_implications edge_type,
      optimization_hints = functions.get_optimization_hints edge_type
    },

    # Validate edge semantics in the graph
    validate_graph_edges = fun edges =>
      std.array.all (fun edge =>
        let source_node = get_node_by_id edge.source_id in
        let target_node = get_node_by_id edge.target_id in
        let edge_type = std.record.get_or "x-familiar-edge-type" edge "depends_on" in
        functions.validate_edge_compatibility source_node target_node edge_type
      ) edges,

    # Generate code from edge relationships
    generate_from_graph_edges = fun edges graph_context =>
      # Group edges by type for batch processing (manual implementation)
      let edges_by_type = std.array.fold_left (fun acc edge =>
        let edge_type = std.record.get_or "x-familiar-edge-type" edge "depends_on" in
        let existing = std.record.get_or edge_type acc [] in
        std.record.update edge_type (existing @ [edge]) acc
      ) {} edges in

      # Generate code for each edge type
      std.record.map (fun edge_type edge_list =>
        let implications = functions.get_compilation_implications edge_type in
        generate_edge_code edge_type edge_list implications graph_context
      ) edges_by_type,

    # Analyze graph connectivity using edge semantics
    analyze_graph_connectivity = fun graph =>
      let edges = graph.edges in
      let edge_types = std.array.map (fun edge => std.record.get_or "x-familiar-edge-type" edge "depends_on") edges in

      {
        dependency_depth = std.array.length edges,
        communication_patterns = "basic",
        orchestration_complexity = std.array.length edge_types,
        potential_cycles = [],
        optimization_opportunities = []
      }
  },

  # ============================================================================
  # CODE GENERATION IMPLICATIONS
  # ============================================================================

  codegen = {
    rust = {
      traits = fun edge_type =>
        let implications = functions.get_compilation_implications edge_type in
        if implications.generate_dependency_injection then ["Injectable", "DependsOn"]
        else if implications.generate_network_client then ["NetworkClient", "CommunicatesWith"]
        else ["GraphEdge"],

      edge_structs = fun edge_type =>
        if edge_type == "depends_on" then ["DependencyEdge", "DependencyGraph"]
        else if edge_type == "communicates_with" then ["CommunicationEdge", "ServiceMesh"]
        else ["GenericEdge"]
    },

    typescript = {
      interfaces = fun edge_type =>
        if edge_type == "depends_on" then ["Dependency", "Injectable"]
        else if edge_type == "communicates_with" then ["Communicator", "ServiceClient"]
        else ["GraphEdge"]
    }
  },

  # ============================================================================
  # COMPOSITION RULES
  # ============================================================================

  # ============================================================================
  # TOPOLOGY CLASSIFICATION (MERGED FROM topology-type.ncl)
  # ============================================================================

  topology_classification = {
    contract = std.contract.custom (fun label value =>
      let valid_types = [
        "entity_node_binding", "synthesized", "runtime_topology",
        "static_topology", "dynamic_topology", "hierarchical_topology"
      ] in
      if std.array.elem value valid_types then value
      else std.contract.blame_with label "x-familiar-topology-classification must be one of: entity_node_binding, synthesized, runtime_topology, static_topology, dynamic_topology, hierarchical_topology"
    ),

    functions = {
      get_topology_characteristics = fun topology_type =>
        if topology_type == "entity_node_binding" then {
          purpose = "bind_data_to_compute",
          dynamism = "static",
          lifecycle = "compile_time",
          generation_strategy = "synthesized_from_service_refs"
        } else if topology_type == "synthesized" then {
          purpose = "generated_topology",
          dynamism = "static",
          lifecycle = "build_time",
          generation_strategy = "inferred_from_schema_relationships"
        } else if topology_type == "runtime_topology" then {
          purpose = "runtime_orchestration",
          dynamism = "dynamic",
          lifecycle = "runtime",
          generation_strategy = "discovered_at_runtime"
        } else if topology_type == "static_topology" then {
          purpose = "fixed_architecture",
          dynamism = "static",
          lifecycle = "design_time",
          generation_strategy = "manually_defined"
        } else if topology_type == "dynamic_topology" then {
          purpose = "adaptive_architecture",
          dynamism = "dynamic",
          lifecycle = "runtime",
          generation_strategy = "adaptive_discovery"
        } else if topology_type == "hierarchical_topology" then {
          purpose = "layered_architecture",
          dynamism = "static",
          lifecycle = "design_time",
          generation_strategy = "layer_composition"
        } else {
          purpose = "unknown",
          dynamism = "unknown",
          lifecycle = "unknown",
          generation_strategy = "unknown"
        }
    }
  },

  composition_rules = {
    compatible_with = ["x-familiar-architectural-pattern"],
    validation_order = 3,  # Validate after node types
    inheritable = true
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/kind.ncl

```nickel
/**
 * x-familiar-kind Extension
 *
 * Defines the architectural role of a schema in the graph structure.
 * Provides semantic classification for graph nodes (slotmap indices).
 *
 * @category identity
 * @graph-value high - provides node semantics for slotmap+petgraph
 * @validation strict - required for all schemas
 */

{
  # ============================================================================
  # EXTENSION METADATA
  # ============================================================================

  extension = {
    name = "x-familiar-kind",
    description = "Architectural role classification for graph nodes",
    category = "identity",
    required = true,
    version = "1.0.0"
  },

  # ============================================================================
  # NICKEL TYPE SYSTEM INTEGRATION
  # ============================================================================

  nickel_type = [| `entity, `node, `topology, `domain |],

  # ============================================================================
  # CONTRACT DEFINITION
  # ============================================================================

  contract = std.contract.custom (fun label value =>
    if std.array.elem value ["entity", "node", "topology", "domain"] then
      value
    else
      std.contract.blame_with label "x-familiar-kind must be one of: entity, node, topology, domain. Got: ${std.to_string value}"
  ),

  # ============================================================================
  # MERGE STRATEGIES
  # ============================================================================

  merge_strategies = {
    override = fun base override => override,
    compose = fun base override => override,  # Kind cannot be composed, only overridden
    validate = fun base override =>
      if contract.validate override then override
      else std.contract.blame_with "merge" "Invalid x-familiar-kind in merge: ${std.to_string override}"
  },

  # ============================================================================
  # DEFAULTS & METADATA
  # ============================================================================

  defaults = {
    validation = true
  },

  metadata = {
    required = true,
    examples = ["entity", "node", "topology", "domain"],
    since = "v1.0.0",
    graph_impact = "node_classification"
  },

  # ============================================================================
  # FUNCTION LIBRARY
  # ============================================================================

  functions = {
    # Validate kind value
    validate_kind = fun value =>
      std.array.elem value ["entity", "node", "topology", "domain"],

    # Get orthological layer from kind
    get_layer = fun kind =>
      if kind == "entity" then `codegen
      else if kind == "node" then `infrastructure
      else if kind == "topology" then `architecture
      else `domain,

    # Get directory placement for kind
    get_directory = fun kind =>
      if kind == "entity" then "codegen"
      else if kind == "node" then "infrastructure"
      else if kind == "topology" then "architecture"
      else "domain",

    # Check if kind represents data (for codegen)
    is_data_kind = fun kind =>
      kind == "entity",

    # Check if kind represents compute (for infrastructure)
    is_compute_kind = fun kind =>
      kind == "node",

    # Check if kind represents wiring (for architecture)
    is_wiring_kind = fun kind =>
      kind == "topology",

    # Check if kind represents business logic (for domain)
    is_business_kind = fun kind =>
      kind == "domain"
  },

  # ============================================================================
  # GRAPH INTEGRATION
  # ============================================================================

  graph_integration = {
    # Add semantic metadata to graph nodes
    node_metadata = fun kind_value => {
      node_type = kind_value,
      orthological_layer = functions.get_layer kind_value,
      is_data_node = functions.is_data_kind kind_value,
      is_compute_node = functions.is_compute_kind kind_value,
      is_wiring_node = functions.is_wiring_kind kind_value,
      is_business_node = functions.is_business_kind kind_value
    },

    # Validate node fits in graph structure
    graph_constraints = fun node graph_context => {
      # Ensure node kind is compatible with graph structure
      let layer = functions.get_layer node."x-familiar-kind" in
      let allowed_layers = graph_context.allowed_layers | ["codegen", "infrastructure", "architecture", "domain"] in

      if std.array.elem layer allowed_layers then
        { valid = true, errors = [], warnings = [] }
      else
        { valid = false, errors = ["Node kind ${node."x-familiar-kind"} not allowed in current graph context"], warnings = [] }
    },

    # Generate code from graph context
    generate_from_graph = fun node graph_context => {
      let kind = node."x-familiar-kind" in
      let layer = functions.get_layer kind in

      if layer == `codegen then
        # Generate data structures
        generate_entity_code node graph_context
      else if layer == `infrastructure then
        # Generate infrastructure code
        generate_infrastructure_code node graph_context
      else if layer == `architecture then
        # Generate wiring code
        generate_architecture_code node graph_context
      else
        # Generate domain code
        generate_domain_code node graph_context
    }
  },

  # ============================================================================
  # CODE GENERATION IMPLICATIONS
  # ============================================================================

  codegen = {
    rust = {
      derives = fun kind =>
        if kind == "entity" then
          ["Debug", "Clone", "Serialize", "Deserialize"]
        else
          ["Debug", "Clone"],

      traits = fun kind =>
        if kind == "entity" then
          ["Entity"]
        else if kind == "node" then
          ["Node"]
        else
          []
    },

    typescript = {
      interfaces = fun kind =>
        if kind == "entity" then
          ["Entity", "Serializable"]
        else if kind == "node" then
          ["Node", "Executable"]
        else
          ["Serializable"]
    }
  },

  # ============================================================================
  # COMPOSITION RULES
  # ============================================================================

  composition_rules = {
    # How this extension composes with others
    compatible_with = ["x-familiar-description", "x-familiar-contract"],

    # Validation order (this should be validated first)
    validation_order = 1,

    # Inheritance rules
    inheritable = false  # Kind cannot be inherited, must be explicit
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/node-type.ncl

```nickel
/**
 * x-familiar-node-type Extension
 *
 * Defines the specific type of infrastructure node in the graph.
 * Provides classification for compute resources in slotmap+petgraph.
 *
 * @category infrastructure
 * @graph-value high - classifies infrastructure nodes for scheduling
 * @validation context-dependent - only required for node kinds
 */

{
  # ============================================================================
  # EXTENSION METADATA
  # ============================================================================

  extension = {
    name = "x-familiar-node-type",
    description = "Infrastructure node classification for compute resources",
    category = "infrastructure",
    required = false,
    version = "1.0.0",
    context_required = ["node"]  # Only required when x-familiar-kind = "node"
  },

  # ============================================================================
  # NICKEL TYPE SYSTEM INTEGRATION
  # ============================================================================

  nickel_type = [|
    `api_service, `worker, `database, `cache, `queue,
    `tool_execution, `resource_allocation, `action_execution
  |],

  # ============================================================================
  # CONTRACT DEFINITION
  # ============================================================================

  contract = std.contract.custom (fun label value =>
    let valid_types = [
      "api_service", "worker", "database", "cache", "queue",
      "tool_execution", "resource_allocation", "action_execution"
    ] in
    if std.array.elem value valid_types then
      value
    else
      std.contract.blame_with label "x-familiar-node-type must be one of: api_service, worker, database, cache, queue, tool_execution, resource_allocation, action_execution. Got: ${std.to_string value}"
  ),

  # ============================================================================
  # MERGE STRATEGIES
  # ============================================================================

  merge_strategies = {
    override = fun base override => override,
    compose = fun base override => override,  # Node type cannot be composed
    validate = fun base override =>
      if contract.validate override then override
      else std.contract.blame_with "merge" "Invalid x-familiar-node-type in merge: ${std.to_string override}"
  },

  # ============================================================================
  # DEFAULTS & METADATA
  # ============================================================================

  defaults = {
    validation = true
  },

  metadata = {
    required = false,
    examples = ["api_service", "worker", "database"],
    since = "v1.0.0",
    graph_impact = "node_scheduling"
  },

  # ============================================================================
  # FUNCTION LIBRARY
  # ============================================================================

  functions = {
    # Validate node type
    validate_node_type = fun value =>
      std.array.elem value [
        "api_service", "worker", "database", "cache", "queue",
        "tool_execution", "resource_allocation", "action_execution"
      ],

    # Get execution characteristics
    get_execution_model = fun node_type =>
      if node_type == "api_service" then "request_response"
      else if node_type == "worker" then "background_processing"
      else if node_type == "database" then "data_access"
      else if node_type == "cache" then "fast_access"
      else if node_type == "queue" then "message_processing"
      else if node_type == "tool_execution" then "tool_invocation"
      else if node_type == "resource_allocation" then "resource_management"
      else "task_execution",

    # Get scaling characteristics
    get_scaling_profile = fun node_type =>
      if node_type == "api_service" then "horizontal_scaling"
      else if node_type == "worker" then "horizontal_scaling"
      else if node_type == "database" then "vertical_scaling"
      else if node_type == "cache" then "horizontal_scaling"
      else if node_type == "queue" then "horizontal_scaling"
      else "fixed_scaling",

    # Check if node type supports persistence
    supports_persistence = fun node_type =>
      std.array.elem node_type ["database", "cache", "queue"],

    # Check if node type is externally accessible
    is_externally_accessible = fun node_type =>
      std.array.elem node_type ["api_service", "database", "cache"]
  },

  # ============================================================================
  # GRAPH INTEGRATION
  # ============================================================================

  graph_integration = {
    # Add scheduling metadata to infrastructure nodes
    node_metadata = fun node_type_value => {
      node_type = node_type_value,
      execution_model = functions.get_execution_model node_type_value,
      scaling_profile = functions.get_scaling_profile node_type_value,
      supports_persistence = functions.supports_persistence node_type_value,
      externally_accessible = functions.is_externally_accessible node_type_value,
      scheduling_priority = get_scheduling_priority node_type_value
    },

    # Validate infrastructure node constraints
    graph_constraints = fun node graph_context => {
      let node_type = node."x-familiar-node-type" in
      let infra_context = graph_context.infrastructure | {} in

      # Check resource compatibility
      let compatible_resources = check_resource_compatibility node_type infra_context in
      let scaling_allowed = check_scaling_allowed node_type infra_context in

      if compatible_resources && scaling_allowed then
        { valid = true, errors = [], warnings = [] }
      else
        {
          valid = false,
          errors = std.array.filter (fun x => x != null) [
            if compatible_resources then null else "Node type ${node_type} incompatible with available resources",
            if scaling_allowed then null else "Node type ${node_type} scaling not supported in current context"
          ],
          warnings = []
        }
    },

    # Generate infrastructure code from graph
    generate_from_graph = fun node graph_context => {
      let node_type = node."x-familiar-node-type" in

      # Generate node-specific infrastructure code
      generate_node_infrastructure node_type node graph_context &
      generate_networking_config node_type node graph_context &
      generate_monitoring_config node_type node graph_context
    }
  },

  # ============================================================================
  # CODE GENERATION IMPLICATIONS
  # ============================================================================

  codegen = {
    rust = {
      derives = ["Debug", "Clone", "Serialize", "Deserialize"],
      traits = fun node_type =>
        if node_type == "api_service" then ["Handler", "Routable"]
        else if node_type == "worker" then ["Worker", "Processable"]
        else if node_type == "database" then ["Database", "Queryable"]
        else ["Node"]
    },

    typescript = {
      interfaces = fun node_type =>
        if node_type == "api_service" then ["ApiService", "RequestHandler"]
        else if node_type == "worker" then ["Worker", "TaskProcessor"]
        else ["InfrastructureNode"]
    }
  },

  # ============================================================================
  # COMPOSITION RULES
  # ============================================================================

  composition_rules = {
    compatible_with = ["x-familiar-resources", "x-familiar-scaling", "x-familiar-capabilities"],
    validation_order = 2,
    inheritable = true
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/resources.ncl

```nickel
/**
 * x-familiar-resources Extension
 *
 * Defines resource requirements for infrastructure nodes.
 * Enables resource-aware scheduling in slotmap+petgraph.
 *
 * @category infrastructure
 * @graph-value high - drives resource allocation
 * @validation required - for infrastructure nodes
 */

{
  extension = {
    name = "x-familiar-resources",
    description = "Resource requirements for compute nodes",
    category = "infrastructure",
    required = false,
    version = "1.0.0",
    context_required = ["node"]
  },

  nickel_type = {
    cpu: String,
    memory: String,
    storage: String,
    replicas: Number
  },

  contract = std.contract.custom (fun label value =>
    if std.is_record value &&
       std.record.has_field "cpu" value &&
       std.record.has_field "memory" value then value
    else std.contract.blame_with label "Resources must specify cpu and memory: ${std.to_string value}"
  ),

  functions = {
    calculate_resource_cost = fun resources =>
      let cpu_cores = std.string.to_number (std.string.split "." resources.cpu | [0] | std.array.first) in
      let memory_gb = std.string.to_number (std.string.split "Gi" resources.memory | [0] | std.array.first) in
      cpu_cores * 2 + memory_gb,

    check_resource_compatibility = fun required available =>
      let req_cpu = parse_cpu required.cpu in
      let avail_cpu = parse_cpu available.cpu in
      let req_mem = parse_memory required.memory in
      let avail_mem = parse_memory available.memory in
      req_cpu <= avail_cpu && req_mem <= avail_mem
  },

  graph_integration = {
    node_metadata = fun resources => {
      resource_requirements = resources,
      resource_cost = functions.calculate_resource_cost resources,
      scheduling_class = get_scheduling_class resources
    },

    graph_constraints = fun node graph_context => {
      let resources = node."x-familiar-resources" in
      let available_resources = graph_context.available_resources | {} in
      
      if functions.check_resource_compatibility resources available_resources then
        { valid = true, errors = [], warnings = [] }
      else
        { valid = false, errors = ["Insufficient resources available"], warnings = [] }
    }
  },

  codegen = {
    rust = {
      structs = ["ResourceRequirements", "ResourceAllocation"]
    }
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/scaling.ncl

```nickel
/**
 * x-familiar-scaling Extension
 *
 * Defines auto-scaling rules for infrastructure nodes.
 * Enables dynamic scaling in slotmap+petgraph resource management.
 *
 * @category infrastructure
 * @graph-value high - enables dynamic resource management
 * @validation optional - for scalable nodes
 */

{
  extension = {
    name = "x-familiar-scaling",
    description = "Auto-scaling configuration",
    category = "infrastructure",
    required = false,
    version = "1.0.0"
  },

  nickel_type = {
    min_replicas: Number,
    max_replicas: Number,
    target_cpu_utilization: Number,
    enabled: Bool
  },

  contract = std.contract.custom (fun label value =>
    if std.is_record value &&
       (std.record.get_or "min_replicas" value 1) <= (std.record.get_or "max_replicas" value 10) then value
    else std.contract.blame_with label "Invalid scaling configuration: ${std.to_string value}"
  ),

  functions = {
    calculate_scaling_headroom = fun scaling =>
      scaling.max_replicas - scaling.min_replicas,

    get_scaling_policy = fun scaling =>
      if scaling.enabled then "horizontal" else "fixed"
  },

  graph_integration = {
    node_metadata = fun scaling => {
      scaling_config = scaling,
      scaling_headroom = functions.calculate_scaling_headroom scaling,
      scaling_policy = functions.get_scaling_policy scaling
    }
  }
}

```

### versions/v1.1.0-alpha/nickel/extensions/type-category-merged.ncl

```nickel
# x-familiar-type-category Extension - Composed from extension primitives
# Demonstrates how extensions can be built from merged primitives
let ExtensionLibrary = import "../libraries/extension_libraries/extension_library.ncl" in

# Build extension using merged primitives
ExtensionLibrary.extension_builders.build_category_extension "entity" "x-familiar-type-category" "Type system classification for schemas"
& {

  # Override contract with specific validation using merged primitives
  contract = ExtensionLibrary.ContractPrimitives.ValidationPatterns.type_category,

  # Add specific functions using merged primitives
  functions =
    ExtensionLibrary.FunctionPrimitives.ProcessingFunctions
    & {
      get_type_characteristics = fun category =>
        if category == "primitive" then
          { has_subtypes = false, serializable = true, nullable = true }
        else if category == "composite" then
          { has_subtypes = true, serializable = true, nullable = false }
        else if category == "enum" then
          { has_subtypes = true, serializable = true, nullable = false }
        else if category == "union" then
          { has_subtypes = true, serializable = false, nullable = false }
        else
          { has_subtypes = false, serializable = true, nullable = false },

      validate_type_category = fun schema =>
        let category = ExtensionLibrary.FunctionPrimitives.ProcessingFunctions.extract_field schema "x-familiar-type-category" null in
        if category != null then
          ExtensionLibrary.ContractPrimitives.ValidationPatterns.type_category.validate category
        else
          null
    },

  # Enhance graph integration using merged primitives
  graph_integration =
    ExtensionLibrary.IntegrationPrimitives.GraphIntegrationPrimitives
    & {
      node_metadata = fun schema =>
        let base_metadata = ExtensionLibrary.IntegrationPrimitives.GraphIntegrationPrimitives.node_metadata_generators.entity_node schema extension in
        let category = ExtensionLibrary.FunctionPrimitives.ProcessingFunctions.extract_field schema "x-familiar-type-category" null in
        base_metadata
        & {
          type_characteristics = if category != null then functions.get_type_characteristics category else {},
          type_category = category
        }
    },

  # Enhance codegen integration using merged primitives
  codegen =
    ExtensionLibrary.IntegrationPrimitives.CodegenIntegrationPrimitives
    & {
      rust =
        ExtensionLibrary.IntegrationPrimitives.CodegenIntegrationPrimitives.language_generators.rust
        & {
          derives = fun category =>
            if category == "enum" then
              ["Debug", "Clone", "Serialize", "Deserialize", "PartialEq", "Eq"]
            else if category == "primitive" then
              ["Debug", "Clone", "Serialize", "Deserialize", "PartialEq", "Eq", "Hash"]
            else
              ["Debug", "Clone", "Serialize", "Deserialize"]
        }
    },

  # Specify merge strategy using merged primitives
  merge_strategies = ExtensionLibrary.MergePrimitives.CategoryMergeStrategies.singleton_extension
}

```

### versions/v1.1.0-alpha/nickel/extensions/type-category.ncl

```nickel
/**
 * x-familiar-type-category Extension
 *
 * Defines the type system classification for graph nodes.
 * Provides type system semantics for code generation in slotmap+petgraph.
 *
 * @category entity
 * @graph-value high - enables type-aware code generation
 * @validation context-dependent - for typed schemas
 */

{
  extension = {
    name = "x-familiar-type-category",
    description = "Type system classification for schemas",
    category = "entity",
    required = false,
    version = "1.0.0"
  },

  nickel_type = [| `primitive, `composite, `enum, `union, `reference |],

  contract = std.contract.custom (fun label value =>
    let valid_categories = ["primitive", "composite", "enum", "union", "reference"] in
    if std.array.elem value valid_categories then value
    else std.contract.blame_with label "Invalid type category: ${std.to_string value}"
  ),

  functions = {
    get_type_characteristics = fun category =>
      if category == "primitive" then { has_subtypes = false, serializable = true }
      else if category == "composite" then { has_subtypes = true, serializable = true }
      else if category == "enum" then { has_subtypes = true, serializable = true }
      else if category == "union" then { has_subtypes = true, serializable = false }
      else { has_subtypes = false, serializable = true }
  },

  graph_integration = {
    node_metadata = fun type_category => {
      type_category = type_category,
      characteristics = functions.get_type_characteristics type_category,
      type_system_role = "definition"
    }
  },

  codegen = {
    rust = {
      derives = fun category =>
        if category == "enum" then ["Debug", "Clone", "Serialize", "Deserialize"]
        else ["Debug", "Clone", "Serialize", "Deserialize"]
    }
  }
}

```

### versions/v1.1.0-alpha/nickel/global.ncl

```nickel
# Global Orthological Governance Module
# Foundation for all Familiar schema validation and transformation.
# Establishes orthological principles: Entity/Node/Topology separation.

# Import merged library bundle for extreme & composition
let Libraries = import "libraries/all_libraries.ncl" in

# Global governance through extreme & merging of libraries
Libraries & {
  # Orthological metadata merged with library bundle
  orthology = {
    level = "global",
    description = "Entity/Node/Topology orthological governance for all Familiar schemas",
    entity_node_topology = {
      entity = "data_purity",      # What gets processed
      node = "compute_purity",     # Where processing happens
      topology = "wiring_purity"   # How they connect
    }
  }
}
```

### versions/v1.1.0-alpha/nickel/infrastructure/_directory.ncl

```nickel
# Import typed collection (abstracted from primitives)
let Composer = import "../composers/directory_composer.ncl" in

# Use typed infrastructure interface - minimal merged blocks from libraries/primitives
Composer.infrastructure.Contract.compose {
  extract_from_raw = Composer.infrastructure.extraction,
  validate_pure = Composer.infrastructure.validation,
  get_layer = "node"
}
```

### versions/v1.1.0-alpha/nickel/infrastructure/actions/_directory.ncl

```nickel
# Infrastructure Actions Directory - Basic action validation and capability querying
let Composer = import "../../composers/directory_composer.ncl" in
let Libraries = import "../../libraries/all_libraries.ncl" in

# Specialized action validation for infrastructure layer
Libraries & {
  # Action-specific validation
  action_validation = {
    # Validate infrastructure actions (atomic operations)
    validate_infrastructure_action = fun action_json =>
      # Basic action validation
      Libraries.ActionValidation.validate_action action_json &&

      # Infrastructure-specific constraints
      std.record.has_field "x-familiar-compute-category" action_json &&

      # Validate execution model is appropriate for infrastructure
      let valid_models = ["sync", "async", "stream"] in
      if std.record.has_field "x-familiar-execution-model" action_json then
        std.array.elem action_json."x-familiar-execution-model" valid_models
      else
        true  # execution-model is optional
    ,

    # Validate action capabilities for infrastructure compatibility
    validate_action_capabilities = fun action_json =>
      if std.record.has_field "capabilities" action_json.signature then
        Libraries.ActionValidation.validate_capabilities action_json.signature.capabilities
      else
        true  # capabilities are optional
  },

  # Export validation functions for subdirectory inheritance
  ActionValidation = action_validation
} & Composer.infrastructure.Contract.compose {
  extract_from_raw = Composer.infrastructure.extraction,
  validate_pure = Composer.infrastructure.validation,
  get_layer = "node"
}
```

### versions/v1.1.0-alpha/nickel/infrastructure/actions/algebra/_directory.ncl

```nickel
# Infrastructure nested subdirectory - minimal merged blocks
let Composer = import "../../../composers/directory_composer.ncl" in
Composer.infrastructure.Contract.compose {
  extract_from_raw = Composer.infrastructure.extraction,
  validate_pure = Composer.infrastructure.validation,
  get_layer = "node"
}

```

### versions/v1.1.0-alpha/nickel/infrastructure/actions/llm/_directory.ncl

```nickel
# Infrastructure nested subdirectory - minimal merged blocks
let Composer = import "../../../composers/directory_composer.ncl" in
Composer.infrastructure.Contract.compose {
  extract_from_raw = Composer.infrastructure.extraction,
  validate_pure = Composer.infrastructure.validation,
  get_layer = "node"
}

```

### versions/v1.1.0-alpha/nickel/infrastructure/actions/nlp/_directory.ncl

```nickel
# Infrastructure nested subdirectory - minimal merged blocks
let Composer = import "../../../composers/directory_composer.ncl" in
Composer.infrastructure.Contract.compose {
  extract_from_raw = Composer.infrastructure.extraction,
  validate_pure = Composer.infrastructure.validation,
  get_layer = "node"
}

```

### versions/v1.1.0-alpha/nickel/infrastructure/edge-semantics.ncl

```nickel
/**
 * Infrastructure Edge Semantics
 *
 * Inherits global edge types and specializes them for infrastructure/compute concerns.
 * Defines how edges behave in the context of nodes, resources, and deployment.
 *
 * @category infrastructure
 * @graph-value high - specializes edges for compute infrastructure
 * @validation context-aware - infrastructure-specific edge constraints
 */

let global_edges = import "../extensions/edge-type.ncl" in

{
  # ============================================================================
  # INHERITED & SPECIALIZED EDGE TYPES
  # ============================================================================

  # Inherit all global edge types with infrastructure-specific specializations
  edge_types = global_edges.edge_types & {
    # Add infrastructure-specific edge types
    provides = {
      directionality = "directed",
      cardinality = "one_to_many",
      transitivity = false,
      cyclicity = "acyclic",
      data_flow = "resource_provisioning",
      strength = "strong",
      context = "resource_management",
      compilation_implications = {
        generate_resource_allocation = true,
        generate_capacity_planning = true,
        generate_monitoring_setup = true
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = false,
        topological_sort_required = true
      }
    },

    consumes = {
      directionality = "directed",
      cardinality = "many_to_one",
      transitivity = false,
      cyclicity = "acyclic",
      data_flow = "resource_consumption",
      strength = "medium",
      context = "resource_utilization",
      compilation_implications = {
        generate_resource_requests = true,
        generate_quota_management = true,
        generate_usage_monitoring = true
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = false,
        topological_sort_required = true
      }
    },

    # Specialize existing edges for infrastructure context
    depends_on = global_edges.edge_types.depends_on & {
      context = "infrastructure_dependencies",
      compilation_implications = global_edges.edge_types.depends_on.compilation_implications & {
        generate_infrastructure_dependencies = true,
        generate_startup_ordering = true,
        generate_health_dependencies = true
      },
      traversal_rules = global_edges.edge_types.depends_on.traversal_rules & {
        infrastructure_cycles_forbidden = true,
        startup_order_critical = true
      }
    },

    deploys_to = global_edges.edge_types.deploys_to & {
      context = "physical_deployment",
      compilation_implications = {
        generate_deployment_scripts = true,
        generate_infrastructure_templates = true,
        generate_rollback_procedures = true,
        generate_scaling_automation = true
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = false,
        topological_sort_required = true,
        deployment_order_critical = true
      }
    },

    contains = global_edges.edge_types.contains & {
      context = "infrastructure_containment",
      compilation_implications = {
        generate_namespace_isolation = true,
        generate_resource_sharing = true,
        generate_cleanup_procedures = true
      },
      traversal_rules = {
        can_traverse = true,
        allows_cycles = false,
        topological_sort_required = false  # Containment is hierarchical, not dependency-based
      }
    }
  },

  # ============================================================================
  # INFRASTRUCTURE-SPECIFIC VALIDATION RULES
  # ============================================================================

  validation_rules = {
    # Edge combinations allowed in infrastructure schemas
    allowed_edge_combinations = [
      # Node to Resource provisioning
      {
        source_kind = "node",
        target_kind = "resource",
        allowed_edges = ["provides", "consumes", "depends_on"]
      },

      # Node to Node relationships
      {
        source_kind = "node",
        target_kind = "node",
        allowed_edges = ["depends_on", "communicates_with", "contains"]
      },

      # System to Node deployment
      {
        source_kind = "system",
        target_kind = "node",
        allowed_edges = ["deploys_to"]
      },

      # Resource to Resource dependencies
      {
        source_kind = "resource",
        target_kind = "resource",
        allowed_edges = ["depends_on"]
      }
    ],

    # Prohibited patterns in infrastructure
    prohibited_patterns = [
      # Resources shouldn't contain other resources (use dependencies)
      {
        source_kind = "resource",
        target_kind = "resource",
        prohibited_edges = ["contains"]
      },

      # Systems shouldn't provide resources (that's node's job)
      {
        source_kind = "system",
        target_kind = "resource",
        prohibited_edges = ["provides"]
      }
    ],

    # Infrastructure-specific constraints
    infrastructure_constraints = {
      # Maximum nodes per resource
      max_consumers_per_resource = 10,

      # Require explicit resource specifications
      allow_implicit_resources = false,

      # Enforce resource dependency chains
      max_resource_dependency_depth = 5
    }
  },

  # ============================================================================
  # INFRASTRUCTURE-SPECIFIC FUNCTIONS
  # ============================================================================

  functions = {
    # Validate edge compatibility in infrastructure context
    validate_infrastructure_edge = fun source_kind target_kind edge_type =>
      let allowed_combinations = validation_rules.allowed_edge_combinations in
      let matching_rules = std.array.filter (fun rule =>
        rule.source_kind == source_kind && rule.target_kind == target_kind
      ) allowed_combinations in

      if std.array.is_empty matching_rules then
        false  # No rules allow this source->target combination
      else
        # Check if edge_type is allowed for this source->target
        std.array.any (fun rule =>
          std.array.elem edge_type rule.allowed_edges
        ) matching_rules,

    # Get edge metadata with infrastructure specialization
    get_infrastructure_edge_metadata = fun edge_type =>
      if std.record.has_field edge_type edge_types then
        edge_types."%{edge_type}"
      else
        global_edges.functions.get_edge_characteristics edge_type,

    # Analyze infrastructure resource utilization
    analyze_resource_utilization = fun edges =>
      let resource_edges = std.array.filter (fun edge =>
        std.array.elem edge.edge_type ["provides", "consumes"]
      ) edges in

      let providers = std.array.filter (fun edge => edge.edge_type == "provides") resource_edges in
      let consumers = std.array.filter (fun edge => edge.edge_type == "consumes") resource_edges in

      {
        total_providers = std.array.length providers,
        total_consumers = std.array.length consumers,
        resource_contention = calculate_resource_contention resource_edges,
        utilization_efficiency = calculate_utilization_efficiency providers consumers,
        scaling_recommendations = generate_scaling_recommendations resource_edges
      },

    # Calculate resource contention (over-subscription)
    calculate_resource_contention = fun resource_edges =>
      let provides_by_resource = std.array.group_by (fun edge => edge.target_ref) (
        std.array.filter (fun edge => edge.edge_type == "provides") resource_edges
      ) in

      let consumes_by_resource = std.array.group_by (fun edge => edge.source_schema) (
        std.array.filter (fun edge => edge.edge_type == "consumes") resource_edges
      ) in

      # Simplified contention calculation
      let over_subscribed = std.record.filter (fun resource consumers =>
        std.array.length consumers > validation_rules.infrastructure_constraints.max_consumers_per_resource
      ) consumes_by_resource in

      std.record.map (fun resource consumers => {
        resource = resource,
        consumer_count = std.array.length consumers,
        max_allowed = validation_rules.infrastructure_constraints.max_consumers_per_resource,
        over_subscribed = std.array.length consumers > validation_rules.infrastructure_constraints.max_consumers_per_resource
      }) over_subscribed,

    # Calculate utilization efficiency
    calculate_utilization_efficiency = fun providers consumers =>
      let total_providers = std.array.length providers in
      let total_consumers = std.array.length consumers in

      if total_providers == 0 then
        0.0
      else
        (total_consumers / total_providers) * 100.0,

    # Generate scaling recommendations
    generate_scaling_recommendations = fun resource_edges =>
      let contention = calculate_resource_contention resource_edges in

      if std.record.is_empty contention then
        []
      else
        std.record.map (fun resource info =>
          if info.over_subscribed then
            {
              resource = resource,
              action = "scale_up",
              reason = "over_subscribed",
              recommended_capacity = info.consumer_count * 2
            }
          else
            {
              resource = resource,
              action = "optimize",
              reason = "under_utilized",
              recommended_capacity = info.consumer_count
            }
        ) contention,

    # Validate resource dependency chains
    validate_resource_dependencies = fun edges =>
      let dependency_edges = std.array.filter (fun edge =>
        edge.edge_type == "depends_on" &&
        (std.string.contains "resource" edge.source_schema ||
         std.string.contains "resource" edge.target_ref)
      ) edges in

      # Check for cycles in resource dependencies
      let cycles = detect_resource_dependency_cycles dependency_edges in

      if std.array.is_empty cycles then
        { valid = true, errors = [], warnings = [] }
      else
        {
          valid = false,
          errors = std.array.map (fun cycle =>
            "Resource dependency cycle detected: ${std.string.join " -> " cycle}"
          ) cycles,
          warnings = []
        },

    # Detect cycles in resource dependencies (simplified)
    detect_resource_dependency_cycles = fun dependency_edges =>
      # In practice, would need proper cycle detection algorithm
      # For now, return empty (no cycles detected)
      [],

    # Generate infrastructure deployment ordering
    generate_deployment_ordering = fun edges =>
      let deployment_edges = std.array.filter (fun edge =>
        edge.edge_type == "deploys_to"
      ) edges in

      let containment_edges = std.array.filter (fun edge =>
        edge.edge_type == "contains"
      ) edges in

      # Combine deployment and containment for ordering
      let all_structural_edges = deployment_edges @ containment_edges in

      {
        deployment_phases = group_by_deployment_phase all_structural_edges,
        startup_order = calculate_startup_order all_structural_edges,
        shutdown_order = calculate_shutdown_order all_structural_edges
      },

    # Group edges by deployment phase
    group_by_deployment_phase = fun edges =>
      let infrastructure_edges = std.array.filter (fun edge =>
        std.string.contains "infrastructure" edge.target_ref
      ) edges in

      let application_edges = std.array.filter (fun edge =>
        !std.string.contains "infrastructure" edge.target_ref
      ) edges in

      {
        infrastructure = infrastructure_edges,
        applications = application_edges
      },

    # Calculate startup order (reverse of dependencies)
    calculate_startup_order = fun edges =>
      # Simplified topological sort for startup
      let dependency_edges = std.array.filter (fun edge =>
        edge.edge_type == "depends_on"
      ) edges in

      # In practice, would implement topological sort
      std.array.map (fun edge => edge.source_schema) dependency_edges,

    # Calculate shutdown order (follow dependencies)
    calculate_shutdown_order = fun edges =>
      # Simplified reverse topological sort for shutdown
      let dependency_edges = std.array.filter (fun edge =>
        edge.edge_type == "depends_on"
      ) edges in

      # In practice, would implement reverse topological sort
      std.array.map (fun edge => edge.target_ref) dependency_edges
  },

  # ============================================================================
  # COMPILATION INTEGRATION
  # ============================================================================

  compilation = {
    # Generate infrastructure code from edges
    generate_from_infrastructure_edges = fun edges graph_context =>
      # Group edges by type for batch processing
      let edges_by_type = std.array.group_by (fun edge => edge.edge_type) edges in

      # Generate infrastructure-specific code for each edge type
      std.record.map (fun edge_type edge_list =>
        let metadata = get_infrastructure_edge_metadata edge_type in
        generate_infrastructure_edge_code edge_type edge_list metadata graph_context
      ) edges_by_type,

    # Generate resource allocation manifests
    generate_resource_manifests = fun edges =>
      let resource_edges = std.array.filter (fun edge =>
        std.array.elem edge.edge_type ["provides", "consumes"]
      ) edges in

      let manifests_by_resource = std.array.group_by (fun edge => edge.target_ref) resource_edges in

      std.record.map (fun resource_ref edges => {
        resource = resource_ref,
        providers = std.array.filter (fun edge => edge.edge_type == "provides") edges,
        consumers = std.array.filter (fun edge => edge.edge_type == "consumes") edges,
        allocation_strategy = "fair_sharing",
        monitoring_enabled = true
      }) manifests_by_resource,

    # Generate deployment automation
    generate_deployment_automation = fun edges =>
      let deployment_ordering = functions.generate_deployment_ordering edges in

      {
        startup_script = generate_startup_script deployment_ordering.startup_order,
        shutdown_script = generate_shutdown_script deployment_ordering.shutdown_order,
        health_checks = generate_health_checks edges,
        rollback_procedures = generate_rollback_procedures edges
      },

    # Generate startup script
    generate_startup_script = fun startup_order =>
      std.array.map (fun component =>
        "start_component ${component}"
      ) startup_order,

    # Generate shutdown script
    generate_shutdown_script = fun shutdown_order =>
      std.array.map (fun component =>
        "stop_component ${component}"
      ) shutdown_order,

    # Generate health checks
    generate_health_checks = fun edges =>
      let nodes = std.array.uniq (
        std.array.flat_map (fun edge => [edge.source_schema, edge.target_ref]) edges
      ) in

      std.array.map (fun node => {
        component = node,
        health_endpoint = "/health",
        timeout = "30s",
        interval = "10s"
      }) nodes,

    # Generate rollback procedures
    generate_rollback_procedures = fun edges =>
      let deployment_edges = std.array.filter (fun edge =>
        edge.edge_type == "deploys_to"
      ) edges in

      std.array.map (fun edge => {
        component = edge.source_schema,
        target_infrastructure = edge.target_ref,
        rollback_command = "rollback_component ${edge.source_schema}",
        cleanup_commands = ["cleanup_resources ${edge.source_schema}"]
      }) deployment_edges
  }
}
```

### versions/v1.1.0-alpha/nickel/infrastructure/environments/_directory.ncl

```nickel
# Infrastructure subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.infrastructure.Contract.compose {
  extract_from_raw = Composer.infrastructure.extraction,
  validate_pure = Composer.infrastructure.validation,
  get_layer = "node"
}

```

### versions/v1.1.0-alpha/nickel/infrastructure/nodes/_directory.ncl

```nickel
# Infrastructure subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.infrastructure.Contract.compose {
  extract_from_raw = Composer.infrastructure.extraction,
  validate_pure = Composer.infrastructure.validation,
  get_layer = "node"
}

```

### versions/v1.1.0-alpha/nickel/infrastructure/queues/_directory.ncl

```nickel
# Infrastructure subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.infrastructure.Contract.compose {
  extract_from_raw = Composer.infrastructure.extraction,
  validate_pure = Composer.infrastructure.validation,
  get_layer = "node"
}

```

### versions/v1.1.0-alpha/nickel/infrastructure/resources/_directory.ncl

```nickel
# Infrastructure subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.infrastructure.Contract.compose {
  extract_from_raw = Composer.infrastructure.extraction,
  validate_pure = Composer.infrastructure.validation,
  get_layer = "node"
}

```

### versions/v1.1.0-alpha/nickel/infrastructure/systems/_directory.ncl

```nickel
# Infrastructure subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.infrastructure.Contract.compose {
  extract_from_raw = Composer.infrastructure.extraction,
  validate_pure = Composer.infrastructure.validation,
  get_layer = "node"
}

```

### versions/v1.1.0-alpha/nickel/infrastructure/techniques/_directory.ncl

```nickel
# Infrastructure Techniques Directory - ISA and CEL validation with inheritance
let Composer = import "../../composers/directory_composer.ncl" in
let ArchitectureTechniques = import "../../architecture/techniques/_directory.ncl" in

# Inherit from architecture techniques and specialize for infrastructure
ArchitectureTechniques & {
  # Infrastructure-specific technique validation
  technique_validation = ArchitectureTechniques.technique_validation & {
    # Validate infrastructure techniques (deployment/compute workflows)
    validate_infrastructure_technique = fun technique_json =>
      # Basic technique validation
      ArchitectureTechniques.technique_validation.validate_architecture_technique technique_json &&

      # Infrastructure-specific constraints
      std.record.has_field "x-familiar-compute-requirements" technique_json &&

      # Allow all step kinds for infrastructure flexibility
      true
    ,

    # Validate infrastructure-specific CEL expressions
    validate_infrastructure_data_flow = fun technique_json =>
      ArchitectureTechniques.technique_validation.validate_architectural_data_flow technique_json &&

      # Additional infrastructure constraints
      # e.g., ensure compute resources are properly referenced
      true
  },

  # Directory-level validation contract with technique focus
  validate_directory = ArchitectureTechniques.validate_directory & {
    # Infrastructure techniques directory validation
    # Validates technique files for infrastructure compliance
    technique_compliance_check = fun directory_path =>
      # Check all .technique.json files for ISA compliance
      { valid = true, errors = [], warnings = [] }
  }
} & Composer.infrastructure.Contract.compose {
  extract_from_raw = Composer.infrastructure.extraction,
  validate_pure = Composer.infrastructure.validation,
  get_layer = "node"
}

```

### versions/v1.1.0-alpha/nickel/infrastructure/techniques/nlp/_directory.ncl

```nickel
# NLP Techniques Subdirectory - Specialized technique validation
let ParentTechniques = import "../_directory.ncl" in
let Composer = import "../../../composers/directory_composer.ncl" in

# Inherit from parent techniques directory and specialize for NLP
ParentTechniques & {
  # NLP-specific technique validation
  technique_validation = ParentTechniques.technique_validation & {
    # Validate NLP techniques (language processing workflows)
    validate_nlp_technique = fun technique_json =>
      # Basic infrastructure technique validation
      ParentTechniques.technique_validation.validate_infrastructure_technique technique_json &&

      # NLP-specific constraints
      std.record.has_field "x-familiar-nlp-model" technique_json &&

      # Validate NLP-appropriate step kinds
      let nlp_allowed_kinds = [ParentTechniques.StepKinds.call, ParentTechniques.StepKinds.map, ParentTechniques.StepKinds.transform] in
      std.array.all (fun step =>
        std.array.elem step.kind nlp_allowed_kinds
      ) technique_json.steps
    ,

    # Validate NLP-specific data flow (text processing pipeline)
    validate_nlp_data_flow = fun technique_json =>
      ParentTechniques.technique_validation.validate_infrastructure_data_flow technique_json &&

      # NLP-specific data flow constraints
      # e.g., ensure text flows through tokenization -> processing -> generation
      true
  }
} & Composer.infrastructure.Contract.compose {
  extract_from_raw = Composer.infrastructure.extraction,
  validate_pure = Composer.infrastructure.validation,
  get_layer = "node"
}

```

### versions/v1.1.0-alpha/nickel/infrastructure/tools/_directory.ncl

```nickel
# Infrastructure subdirectory - minimal merged blocks
let Composer = import "../../composers/directory_composer.ncl" in
Composer.infrastructure.Contract.compose {
  extract_from_raw = Composer.infrastructure.extraction,
  validate_pure = Composer.infrastructure.validation,
  get_layer = "node"
}

```

### versions/v1.1.0-alpha/nickel/libraries/action_library.ncl

```nickel
# Action Library - Basic validation for atomic action signatures
# Following Nickel "composable data" principles with validation contracts

{
  # ============================================================================
  # ACTION VALIDATION
  # ============================================================================

  ActionValidation = {
    # Validate action signature structure
    validate_signature = fun signature =>
      std.is_record signature &&
      std.record.has_field "inputs" signature &&
      std.record.has_field "output" signature &&
      # Inputs should be a record of parameter definitions
      std.is_record signature.inputs &&
      # Output should be a single schema reference or object
      std.is_record signature.output
    ,

    # Validate action capabilities (if present)
    validate_capabilities = fun capabilities =>
      if std.is_record capabilities then
        std.record.has_field "category" capabilities &&
        std.record.has_field "provides" capabilities &&
        std.is_string capabilities.category &&
        std.is_array capabilities.provides
      else
        true  # Capabilities are optional
    ,

    # Validate complete action schema
    validate_action = fun action_json =>
      std.is_record action_json &&
      std.record.has_field "signature" action_json &&
      ActionValidation.validate_signature action_json.signature &&
      (if std.record.has_field "capabilities" action_json.signature then
        ActionValidation.validate_capabilities action_json.signature.capabilities
       else
        true) &&
      # Basic structure validation
      std.record.has_field "id" action_json &&
      std.record.has_field "x-familiar-kind" action_json &&
      action_json.x-familiar-kind == "action"
  },

  # ============================================================================
  # CAPABILITY QUERYING
  # ============================================================================

  CapabilityQueries = {
    # Check if action provides specific capability
    has_capability = fun action capabilities_needed =>
      if std.record.has_field "capabilities" action.signature &&
         std.record.has_field "provides" action.signature.capabilities then
        let provided_caps = action.signature.capabilities.provides in
        std.array.all (fun needed => std.array.elem needed provided_caps) capabilities_needed
      else
        false
    ,

    # Get actions by category
    by_category = fun actions category =>
      std.array.filter (fun action =>
        std.record.has_field "capabilities" action.signature &&
        action.signature.capabilities.category == category
      ) actions
    ,

    # Find actions that provide required capabilities
    find_compatible_actions = fun actions required_capabilities =>
      std.array.filter (fun action =>
        CapabilityQueries.has_capability action required_capabilities
      ) actions
  },

  # ============================================================================
  # LIBRARY METADATA
  # ============================================================================

  library_metadata = {
    name = "action_library",
    version = "1.0.0",
    description = "Basic validation and capability querying for atomic actions",
    provides = ["ActionValidation", "CapabilityQueries"],
    dependencies = [],
    nickel_principle = "composable_data"
  }
}
```

### versions/v1.1.0-alpha/nickel/libraries/all_libraries.ncl

```nickel
# All Libraries - Single merged bundle for extreme composition
# Following Nickel "composable data" - records merged at will with &

# Import individual libraries
let ContractLibrary = import "contract_library.ncl" in
let HydrationLibrary = import "hydration_library.ncl" in
let EdgeLibrary = import "edge_library.ncl" in
let LayerLibrary = import "layer_library.ncl" in
let ExtractionLibrary = import "extraction_library.ncl" in
let ValidationLibrary = import "validation_library.ncl" in
let TechniqueLibrary = import "technique_library.ncl" in
let ActionLibrary = import "action_library.ncl" in
let ReferenceLibrary = import "reference_library.ncl" in

# Merge all libraries into single composable bundle using &
ContractLibrary & HydrationLibrary & EdgeLibrary & LayerLibrary & ExtractionLibrary & ValidationLibrary & TechniqueLibrary & ActionLibrary & ReferenceLibrary & {
  # Library bundle metadata
    merged_libraries = ["contract", "hydration", "edge", "layer", "extraction", "validation", "technique", "action", "reference"],
    composition_strategy = "extreme_merging",
    nickel_principle = "composable_data"
  }
}
```

### versions/v1.1.0-alpha/nickel/libraries/contract_library.ncl

```nickel
# Contract Library - Merged composition of contract primitives

let ContractPrimitives = import "../primitives/contract_primitives.ncl" in

# Merge contract primitives into complete contract library
ContractPrimitives.InterfacePrimitives & ContractPrimitives.FileStructurePrimitives & {
  # Add library-specific enhancements

  # Enhanced test execution using merged primitives
  enhanced_test_runner = fun contract test_cases =>
    ContractPrimitives.TestPrimitives.run_tests contract {} test_cases & {
      enhanced = true,
      library_version = "1.0"
    }
}
```

### versions/v1.1.0-alpha/nickel/libraries/edge_library.ncl

```nickel
# Edge Library - Merged composition of edge primitives

let EdgePrimitives = import "../primitives/edge_primitives.ncl" in

# Merge edge primitives into complete edge library
EdgePrimitives.EdgeValidationPrimitives & {
  # Merge edge types
  edge_types = EdgePrimitives.EdgeTypePrimitives,

  # Merge compatibility rules
  compatibility_rules = EdgePrimitives.EdgeCompatibilityPrimitives,

  # Library metadata

  # Enhanced edge validation with compatibility checking
  validate_edge_with_compatibility = fun schema source_kind target_kind edge_type =>
    let base_validation = EdgePrimitives.EdgeValidationPrimitives.validate_with_edge_contract schema in
    let compatibility_key = "%{source_kind}_to_%{target_kind}" in
    let allowed_edges = if std.record.has_field compatibility_key compatibility_rules then
      compatibility_rules."%{compatibility_key}"
    else [] in
    let is_compatible = std.array.elem edge_type allowed_edges in

    if base_validation.valid && is_compatible then
      {valid = true, errors = [], warnings = []}
    else if !is_compatible then
      {valid = false, errors = ["Edge type '%{edge_type}' not compatible between %{source_kind} and %{target_kind}"], warnings = []}
    else
      base_validation,

  # Edge type lookup with validation
  get_edge_type = fun edge_name =>
    let edge_type = edge_types."%{edge_name}" in
    if edge_type != {} then edge_type
    else std.contract.blame "Unknown edge type: %{edge_name}"
}
```

### versions/v1.1.0-alpha/nickel/libraries/extension_library.ncl

```nickel
# Extension Library - Merged composition of extension primitives
let MetadataPrimitives = import "../../primitives/extension_primitives/metadata_primitives.ncl" in
let ContractPrimitives = import "../../primitives/extension_primitives/contract_primitives.ncl" in
let FunctionPrimitives = import "../../primitives/extension_primitives/function_primitives.ncl" in
let IntegrationPrimitives = import "../../primitives/extension_primitives/integration_primitives.ncl" in
let MergePrimitives = import "../../primitives/extension_primitives/merge_primitives.ncl" in

# Merge extension primitives into complete extension library
MetadataPrimitives
& ContractPrimitives
& FunctionPrimitives
& IntegrationPrimitives
& MergePrimitives
& {
  # Add library-specific enhancements

  # Enhanced extension builders
  extension_builders = {
    # Build complete extension from components
    build_extension = fun metadata contract functions integration merge_strategy =>
      {
        extension = metadata,
        contract = contract,
        functions = functions,
        graph_integration = integration.GraphIntegrationPrimitives,
        codegen = integration.CodegenIntegrationPrimitives,
        validation_integration = integration.ValidationIntegrationPrimitives,
        merge_strategies = merge_strategy
      },

    # Build category-specific extension template
    build_category_extension = fun category name description =>
      {
        extension =
          MetadataPrimitives.BaseExtensionMetadata
          & MetadataPrimitives.CategoryTemplates."%{category}"
          & {
            name = name,
            description = description
          },
        contract = ContractPrimitives.BaseContractPatterns.type_check "String",
        functions = FunctionPrimitives.ValidationFunctions,
        graph_integration = IntegrationPrimitives.GraphIntegrationPrimitives,
        codegen = IntegrationPrimitives.CodegenIntegrationPrimitives,
        validation_integration = IntegrationPrimitives.ValidationIntegrationPrimitives,
        merge_strategies = MergePrimitives.StrategySelectors.by_category category
      }
  },

  # Validation helpers using merged primitives
  validation_helpers = {
    validate_extension_structure = fun extension =>
      std.record.has_field "extension" extension
      && std.record.has_field "contract" extension
      && std.record.has_field "functions" extension,

    validate_extension_metadata = fun extension_metadata =>
      ContractPrimitives.BaseContractPatterns.record_with_fields ["name", "description", "category"].validate extension_metadata,

    validate_extension_contract = fun contract =>
      std.type.of contract == "Function" # Contract should be a function
  },

  # Composition helpers using merged primitives
  composition_helpers = {
    compose_extension_with_schema = fun extension schema =>
      let validated_schema = extension.contract.validate schema in
      let processed_schema = extension.functions.validate_schema_structure validated_schema extension.functions in
      processed_schema
      & {
        "_extension_metadata" = extension.extension,
        "_graph_metadata" = extension.graph_integration.make_node_metadata processed_schema extension.extension,
        "_codegen_metadata" = extension.codegen.make_codegen_metadata processed_schema extension.extension
      },

    merge_extensions = fun base_extension override_extension =>
      let merge_strategy = base_extension.merge_strategies.compose in
      merge_strategy base_extension override_extension
  }
}

```

### versions/v1.1.0-alpha/nickel/libraries/extraction_library.ncl

```nickel
# Extraction Library - Merged composition of extraction primitives

let ExtractionPrimitives = import "../primitives/extraction_primitives.ncl" in

# Merge extraction primitives into complete extraction library
ExtractionPrimitives & {
  # Library metadata

  # Enhanced extraction with validation
  extract_with_validation = fun raw_schema extract_fn validate_fn =>
    let extracted = extract_fn raw_schema in
    let validation = validate_fn extracted in
    {
      data = extracted,
      validation = validation,
      success = validation.valid
    },

  # Layer-specific extraction functions
  extraction_functions = {
    entity_extract = ExtractionPrimitives.EntityExtraction.extract_entity_data,
    node_extract = ExtractionPrimitives.NodeExtraction.extract_compute_resources,
    topology_extract = ExtractionPrimitives.NodeExtraction.extract_topology_wiring,
    domain_extract = ExtractionPrimitives.DomainExtraction.extract_domain_logic
  }
}
```

### versions/v1.1.0-alpha/nickel/libraries/hydration_library.ncl

```nickel
# Hydration Library - Merged composition of hydration primitives

let HydrationPrimitives = import "../primitives/hydration_primitives.ncl" in

# Merge hydration primitives into complete hydration library
HydrationPrimitives.BaseHydration & {
  # Merge metadata primitives
  _metadata = HydrationPrimitives.MetadataPrimitives,

  # Merge observability primitives
  _observability = HydrationPrimitives.ObservabilityPrimitives,

  # Merge operations primitives
  _operations = HydrationPrimitives.OperationsPrimitives,

  # Library metadata

  # Layer-specific hydration composers
  compose_layer_hydration = fun layer_name =>
    HydrationPrimitives.BaseHydration & {
      _metadata = HydrationPrimitives.MetadataPrimitives & {
        governance_level = layer_name
      },
      _observability = HydrationPrimitives.ObservabilityPrimitives,
      _operations = HydrationPrimitives.OperationsPrimitives
    } & (if std.record.has_field layer_name HydrationPrimitives.LayerHydrationPrimitives then
      HydrationPrimitives.LayerHydrationPrimitives."%{layer_name}"
    else {}),

  # Enhanced merging with validation
  validated_merge = fun base overrides =>
    let merged = base & overrides in
    let has_required_fields = std.record.has_field "_metadata" merged &&
                              std.record.has_field "_observability" merged in
    if has_required_fields then merged
    else std.contract.blame "Hydration merge missing required fields"
}
```

### versions/v1.1.0-alpha/nickel/libraries/layer_library.ncl

```nickel
# Layer Library - Merged composition of layer primitives

let LayerPrimitives = import "../primitives/layer_primitives.ncl" in

# Merge layer primitives into complete layer library
{
  # Layer types
  layer_types = LayerPrimitives.LayerTypePrimitives,

  # Layer functions
  layer_functions = LayerPrimitives.LayerFunctionPrimitives,

  # Compatibility rules
  compatibility_rules = LayerPrimitives.LayerCompatibilityPrimitives,

  # Library metadata

  # Layer validation
  validate_layer_schema = fun schema layer_name =>
    let schema_kind = if std.record.has_field "x-familiar-kind" schema then
      schema."x-familiar-kind"
    else "unknown" in
    let allowed_kinds = if std.record.has_field "%{layer_name}_schemas" compatibility_rules then
      compatibility_rules."%{layer_name}_schemas" else [] in
    let is_compatible = std.array.elem schema_kind allowed_kinds in

    if is_compatible then
      {valid = true, errors = [], warnings = []}
    else
      {valid = false, errors = ["Schema kind '%{schema_kind}' not compatible with %{layer_name} layer"], warnings = []},

  # Get layer-specific functions
  get_layer_functions = fun layer_name =>
    if std.record.has_field layer_name layer_functions then
      layer_functions."%{layer_name}"
    else {
      extract_from_raw = fun schema => schema,
      validate_pure = fun schema => {valid = true, errors = [], warnings = []}
    }
}
```

### versions/v1.1.0-alpha/nickel/libraries/reference_library.ncl

```nickel
# Reference Library - Validation contracts for $ref and $schema usage patterns
# Following Nickel "composable data" principles with orthological reference validation
{
  # ============================================================================
  # REFERENCE PATTERN DEFINITIONS (Orthological Constants)
  # ============================================================================

  ReferencePatterns = {
    # Allowed $schema patterns by level
    allowed_schema_patterns = {
      directory = ["http://json-schema.org/draft-07/schema#", "http://json-schema.org/draft-04/schema#"],
      leaf = ["http://json-schema.org/draft-07/schema#", "http://json-schema.org/draft-04/schema#"],
      meta = ["http://json-schema.org/draft-07/schema#", "http://json-schema.org/draft-04/schema#"]
    },

    # $ref usage patterns by level
    ref_usage_patterns = {
      # Directory level: NO $refs allowed (use inheritance)
      directory = {
        forbidden_refs = true,
        allowed_ref_types = [],
        inheritance_required = true
      },
      # Leaf level: $refs allowed for composition
      leaf = {
        forbidden_refs = false,
        allowed_ref_types = ["primitive", "entity", "component", "node", "system"],
        inheritance_allowed = false
      },
      # Meta level: $refs allowed for schema composition
      meta = {
        forbidden_refs = false,
        allowed_ref_types = ["primitive", "definition"],
        inheritance_allowed = true
      }
    }
  },

  # ============================================================================
  # REFERENCE VALIDATION
  # ============================================================================

  ReferenceValidation = {
    # Validate $schema usage by level
    validate_schema_usage = fun schema level =>
      if std.record.has_field "$schema" schema then
        let schema_value = schema."$schema" in
        let allowed_patterns = std.record.get level ReferencePatterns.allowed_schema_patterns in
        std.array.elem schema_value allowed_patterns
      else
        # $schema is optional but recommended
        true,

    # Validate $ref usage by level
    validate_ref_usage = fun schema level =>
      let level_config = std.record.get level ReferencePatterns.ref_usage_patterns in
      if level_config.forbidden_refs then
        # Directory level: No $refs allowed
        let has_refs =
          std.record.fields schema
          |> std.array.any (fun field =>
            if std.record.has_field field schema then
              let field_value = std.record.get field schema in
              std.is_record field_value && std.record.has_field "$ref" field_value
            else
              false
          )
        in
        if has_refs then
          {
            valid = false,
            errors = ["Directory-level schemas must use inheritance, not $refs"],
            warnings = []
          }
        else
          { valid = true, errors = [], warnings = [] }
      else
        # Leaf/meta level: Validate $ref patterns
        let refs = ReferenceValidation.extract_all_refs schema in
        let invalid_refs =
          std.array.filter
            (fun ref =>
              !ReferenceValidation.validate_ref_pattern ref level_config.allowed_ref_types
            )
            refs
        in
        if std.array.is_empty invalid_refs then
          { valid = true, errors = [], warnings = [] }
        else
          {
            valid = false,
            errors = std.array.map (fun ref => "Invalid $ref pattern: %{ref}") invalid_refs,
            warnings = []
          },

    # Extract all $ref values from a schema
    extract_all_refs = fun schema =>
      let rec extract_refs_recursively = fun value =>
        if std.is_record value then
          let direct_ref =
            if std.record.has_field "$ref" value then
              [value."$ref"]
            else
              []
          in
          let nested_refs =
            std.record.values value
            |> std.array.map extract_refs_recursively
            |> std.array.fold_left (fun acc arr => acc @ arr) []
          in
          direct_ref @ nested_refs
        else if std.is_array value then
          std.array.map extract_refs_recursively value
          |> std.array.fold_left (fun acc arr => acc @ arr) []
        else
          []
      in
      extract_refs_recursively schema,

    # Validate a single $ref pattern
    validate_ref_pattern = fun ref_value allowed_types =>
      # Check if ref follows allowed patterns
      std.array.any
        (fun ref_type =>
          std.string.contains ref_value ref_type
        )
        allowed_types
  },

  # ============================================================================
  # INHERITANCE VALIDATION
  # ============================================================================

  InheritanceValidation = {
    # Validate inheritance usage by level
    validate_inheritance_usage = fun schema level =>
      let level_config = std.record.get level ReferencePatterns.ref_usage_patterns in
      if level_config.inheritance_required then
        # Directory level should show signs of inheritance
        let has_inheritance_indicators =
          std.record.fields schema
          |> std.array.any (fun field =>
            # Look for merged record patterns or inheritance markers
            std.string.contains field "Libraries"
            || std.string.contains field "Composer"
            || std.record.has_field "bundle_metadata" schema
          )
        in
        if has_inheritance_indicators then
          { valid = true, errors = [], warnings = [] }
        else
          {
            valid = false,
            errors = ["Directory-level schemas should use inheritance patterns"],
            warnings = []
          }
      else
        { valid = true, errors = [], warnings = [] }
  },

  # ============================================================================
  # COMPREHENSIVE REFERENCE CONTRACT
  # ============================================================================

  ReferenceContract = {
    # Validate complete reference usage for a schema
    validate = fun schema level =>
      let schema_validation = ReferenceValidation.validate_schema_usage schema level in
      let ref_validation = ReferenceValidation.validate_ref_usage schema level in
      let inheritance_validation = InheritanceValidation.validate_inheritance_usage schema level in

      if schema_validation && ref_validation.valid && inheritance_validation.valid then
        {
          valid = true,
          errors = [],
          warnings = ref_validation.warnings @ inheritance_validation.warnings
        }
      else
        {
          valid = false,
          errors =
            (if ref_validation.valid then [] else ref_validation.errors)
            @ (if inheritance_validation.valid then [] else inheritance_validation.errors)
            @ (if schema_validation then [] else ["Invalid $schema for %{level} level"]),
          warnings = ref_validation.warnings @ inheritance_validation.warnings
        }
  },

  # ============================================================================
  # LIBRARY METADATA
  # ============================================================================

  library_metadata = {
    name = "reference_library",
    version = "1.0.0",
    description = "Orthological validation for $ref and $schema usage patterns",
    provides = ["ReferencePatterns", "ReferenceValidation", "InheritanceValidation", "ReferenceContract"],
    dependencies = [],
    nickel_principle = "composable_data"
  }
}

```

### versions/v1.1.0-alpha/nickel/libraries/technique_library.ncl

```nickel
# Technique Library - Validation contracts for ISA compliance and CEL expressions
# Following Nickel "composable data" principles with extreme & merging

{
  # ============================================================================
  # STEP KIND DEFINITIONS (Architectural Constants)
  # ============================================================================

  StepKinds = {
    call = "call",           # Execute single action
    switch = "switch",       # Conditional branching
    map = "map",             # Transform arrays
    parallel = "parallel",   # Parallel execution
    transform = "transform"  # Data transformation
  },

  # ============================================================================
  # CEL EXPRESSION VALIDATION
  # ============================================================================

  CELValidation = {
    # Validate $.step.field reference patterns
    validate_cel_reference = fun expr available_step_ids =>
      if std.is_string expr then
        let parts = std.string.split "." expr in
        if std.array.length parts >= 2 && std.array.elem_at 0 parts == "$" then
          let step_id = std.array.elem_at 1 parts in
          std.array.elem step_id available_step_ids ||
          step_id == "input"  # Allow $.input.* references
        else
          true  # Non-$. expressions are allowed
      else
        true  # Non-string expressions are valid for now
    ,

    # Recursively validate all CEL expressions in an object
    validate_cel_expressions_in_object = fun obj available_step_ids =>
      if std.is_record obj then
        let field_validations = std.record.map (fun _field_name field_value =>
          if std.is_string field_value then
            CELValidation.validate_cel_reference field_value available_step_ids
          else if std.is_record field_value then
            CELValidation.validate_cel_expressions_in_object field_value available_step_ids
          else if std.is_array field_value then
            std.array.all (fun item =>
              if std.is_string item then
                CELValidation.validate_cel_reference item available_step_ids
              else if std.is_record item then
                CELValidation.validate_cel_expressions_in_object item available_step_ids
              else
                true
            ) field_value
          else
            true
        ) obj in
        std.record.values field_validations |> std.array.all std.function.id
      else
        true
    ,

    # Validate step arguments contain valid CEL expressions
    validate_step_args = fun args available_step_ids =>
      CELValidation.validate_cel_expressions_in_object args available_step_ids
    ,

    # Validate return object CEL expressions
    validate_return_expressions = fun return_obj available_step_ids =>
      CELValidation.validate_cel_expressions_in_object return_obj available_step_ids
  },

  # ============================================================================
  # ISA COMPLIANCE VALIDATION (Input-Steps-Action-Return)
  # ============================================================================

  ISAValidation = {
    # Validate input contract structure
    validate_input_contract = fun input =>
      std.is_record input && std.record.has_field "$\ref" input
    ,

    # Validate output contract structure
    validate_output_contract = fun output =>
      std.is_record output && std.record.has_field "$\ref" output
    ,

    # Validate individual step structure
    validate_step = fun step =>
      std.is_record step &&
      std.record.has_field "id" step &&
      std.record.has_field "kind" step &&
      std.record.has_field "action" step &&
      std.is_string step.id &&
      std.is_string step.kind &&
      std.array.elem step.kind [
        StepKinds.call,
        StepKinds.switch,
        StepKinds.map,
        StepKinds.parallel,
        StepKinds.transform
      ]
    ,

    # Validate steps array structure
    validate_steps_structure = fun steps =>
      std.is_array steps &&
      std.array.length steps > 0 &&
      std.array.all ISAValidation.validate_step steps &&
      # Check for unique step IDs
      (let step_ids = std.array.map (fun step => step.id) steps in
       std.array.length step_ids == std.array.length (std.array.unique step_ids))
    ,

    # Validate data flow (no circular dependencies in CEL expressions)
    validate_data_flow = fun steps return_obj =>
      let available_step_ids = std.array.map (fun step => step.id) steps in
      # For now, just check that return expressions reference valid steps
      CELValidation.validate_return_expressions return_obj available_step_ids
  },

  # ============================================================================
  # TECHNIQUE CONTRACT (Complete Validation)
  # ============================================================================

  TechniqueContract = {
    validate = fun technique_json =>
      # Basic structure validation
      std.is_record technique_json &&
      std.record.has_field "input" technique_json &&
      std.record.has_field "output" technique_json &&
      std.record.has_field "steps" technique_json &&
      std.record.has_field "return" technique_json &&
      std.record.has_field "x-familiar-kind" technique_json &&

      # ISA compliance
      ISAValidation.validate_input_contract technique_json.input &&
      ISAValidation.validate_output_contract technique_json.output &&
      ISAValidation.validate_steps_structure technique_json.steps &&
      ISAValidation.validate_data_flow technique_json.steps technique_json.return &&

      # CEL expression validation
      (let available_step_ids = std.array.map (fun step => step.id) technique_json.steps in
       CELValidation.validate_return_expressions technique_json.return available_step_ids &&

       # Validate each step's args
       std.array.all (fun step =>
         if std.record.has_field "args" step then
           CELValidation.validate_step_args step.args available_step_ids
         else
           true  # Steps don't require args
       ) technique_json.steps)
  },

  # ============================================================================
  # LIBRARY METADATA
  # ============================================================================

  library_metadata = {
    name = "technique_library",
    version = "1.0.0",
    description = "ISA compliance and CEL expression validation for techniques",
    provides = ["StepKinds", "CELValidation", "ISAValidation", "TechniqueContract"],
    dependencies = [],
    nickel_principle = "composable_data"
  }
}
```

### versions/v1.1.0-alpha/nickel/libraries/validation_library.ncl

```nickel
# Validation Library - Merged composition of validation primitives

let ValidationPrimitives = import "../primitives/validation_primitives.ncl" in

# Merge validation primitives into complete validation library
ValidationPrimitives & {
  # Library metadata

  # Combined validation (structure + purity)
  validate_comprehensive = fun schema purity_validator structure_validator =>
    let purity = purity_validator schema in
    let structure = structure_validator schema in
    {
      valid = purity.valid && structure.valid,
      errors = purity.errors @ structure.errors,
      warnings = purity.warnings @ structure.warnings,
      purity_check = purity,
      structure_check = structure
    },

  # Layer-specific validation functions
  validation_functions = {
    entity_validate = fun schema =>
      ValidationPrimitives.EntityValidation.validate_pure_entity schema,

    entity_validate_comprehensive = fun schema =>
      validate_comprehensive
        schema
        ValidationPrimitives.EntityValidation.validate_pure_entity
        ValidationPrimitives.EntityValidation.validate_entity_structure,

    node_validate = fun schema =>
      ValidationPrimitives.NodeValidation.validate_pure_compute schema,

    node_validate_comprehensive = fun schema =>
      validate_comprehensive
        schema
        ValidationPrimitives.NodeValidation.validate_pure_compute
        ValidationPrimitives.NodeValidation.validate_compute_resources,

    topology_validate = ValidationPrimitives.TopologyValidation.validate_pure_topology
  }
}
```

### versions/v1.1.0-alpha/nickel/primitives/contract_primitives.ncl

```nickel
# Contract Primitives - Basic building blocks for contract composition
{
  # Core contract interface primitives
  InterfacePrimitives = {
    extract_from_raw = fun schema => schema, # Base implementation
    validate_pure = fun schema => { valid = true, errors = [], warnings = [] },
    get_layer = "unknown"
  },

  # File structure primitives
  FileStructurePrimitives = {
    contract_file =
      {
        _ : InterfacePrimitives
      }
  },

  # Test execution primitives
  TestPrimitives = {
    run_tests = fun contract file test_cases =>
      # Base test runner - directories override with specific logic
      { executed = true, test_cases = test_cases, contract = contract, file = file }
  }
}

```

### versions/v1.1.0-alpha/nickel/primitives/edge_primitives.ncl

```nickel
# Edge Primitives - Building blocks for relationship semantics

{
  # Edge validation primitives
  EdgeValidationPrimitives = {
    validate_with_edge_contract = fun schema => schema,  # Placeholder - will be implemented by extensions
    extract_typed_relationships = fun schema => []  # Placeholder - will be implemented by extensions
  },

  # Edge type primitives
  EdgeTypePrimitives = {
    depends_on = {directionality = "directed", cyclicity = "acyclic"},
    orchestrates = {directionality = "directed", cardinality = "one_to_many"},
    communicates_with = {directionality = "bidirectional", cyclicity = "cyclic_allowed"},
    contains = {directionality = "directed", cardinality = "one_to_many"},
    deploys_to = {directionality = "directed", cardinality = "many_to_one"}
  },

  # Edge compatibility primitives
  EdgeCompatibilityPrimitives = {
    entity_to_node = ["entity_node_binding", "deploys_to"],
    system_to_component = ["orchestrates", "depends_on"],
    component_to_resource = ["consumes", "depends_on"],
    node_to_system = ["contains", "orchestrates"]
  }
}
```

### versions/v1.1.0-alpha/nickel/primitives/extension_primitives/contract_primitives.ncl

```nickel
# Extension Contract Primitives - Common contract patterns for extensions

{
  # Base contract patterns
  BaseContractPatterns = {
    # String enum validation
    string_enum = fun valid_values => std.contract.custom (fun label value =>
      if std.array.elem value valid_values then value
      else std.contract.blame_with label "Must be one of: ${std.string.join ", " valid_values}. Got: ${std.to_string value}"
    ),

    # Type validation
    type_check = fun expected_type => std.contract.custom (fun label value =>
      let actual_type = std.type.of value in
      if actual_type == expected_type then value
      else std.contract.blame_with label "Expected ${std.to_string expected_type}, got ${std.to_string actual_type}"
    ),

    # Array validation
    array_of = fun element_contract => std.contract.custom (fun label value =>
      if std.type.of value == "Array then
        std.array.map (fun elem => element_contract.validate elem) value
      else std.contract.blame_with label "Expected array, got ${std.to_string (std.type.of value)}"
    ),

    # Record field validation
    record_with_fields = fun required_fields => std.contract.custom (fun label value =>
      if std.type.of value == "Record then
        let missing_fields = std.array.filter (fun field => !std.record.has_field field value) required_fields in
        if std.array.is_empty missing_fields then value
        else std.contract.blame_with label "Missing required fields: ${std.string.join ", " missing_fields}"
      else std.contract.blame_with label "Expected record, got ${std.to_string (std.type.of value)}"
    )
  },

  # Common validation patterns
  ValidationPatterns = {
    # Edge type validation
    edge_type = BaseContractPatterns.string_enum [
      "depends_on", "communicates_with", "contains", "implements",
      "extends", "aggregates", "orchestrates", "transforms",
      "references", "configures", "deploys_to", "routes_to"
    ],

    # Type category validation
    type_category = BaseContractPatterns.string_enum [
      "primitive", "composite", "enum", "union", "reference"
    ],

    # Component type validation
    component_type = BaseContractPatterns.string_enum [
      "entity", "system", "component", "primitive", "node"
    ]
  },

  # Contract composition helpers
  CompositionHelpers = {
    # Combine multiple contracts with AND logic
    combine_contracts = fun contracts => std.contract.custom (fun label value =>
      std.array.fold_left (fun acc contract => contract.validate acc) value contracts
    ),

    # Make contract optional
    optional = fun contract => std.contract.custom (fun label value =>
      if value == null then value else contract.validate value
    )
  }
}
```

### versions/v1.1.0-alpha/nickel/primitives/extension_primitives/function_primitives.ncl

```nickel
# Extension Function Primitives - Common function patterns for extensions

{
  # Validation function patterns
  ValidationFunctions = {
    # Generic field validation
    validate_field = fun schema field_name validator =>
      let field_value = std.record.get field_name schema in
      validator field_value,

    # Array element validation
    validate_array_elements = fun array validator =>
      std.array.map validator array,

    # Conditional validation based on context
    validate_conditional = fun condition validator value =>
      if condition value then validator value else value,

    # Schema-level validation
    validate_schema_structure = fun schema validators =>
      std.record.map (fun field_name validator =>
        let field_value = std.record.get_or field_name schema null in
        if field_value != null then validator field_value else null
      ) validators
  },

  # Processing function patterns
  ProcessingFunctions = {
    # Extract field with default
    extract_field = fun schema field_name default =>
      std.record.get_or field_name schema default,

    # Transform field value
    transform_field = fun schema field_name transformer =>
      let value = std.record.get_or field_name schema null in
      if value != null then transformer value else null,

    # Merge field into record
    merge_field = fun base_record field_name field_value =>
      base_record & { "%{field_name}" = field_value },

    # Filter fields by predicate
    filter_fields = fun record predicate =>
      std.record.filter (fun field_name field_value => predicate field_name field_value) record
  },

  # Lookup function patterns
  LookupFunctions = {
    # Simple key-value lookup
    lookup = fun map key default =>
      std.record.get_or key map default,

    # Lookup with transformation
    lookup_transform = fun map key transformer default =>
      let value = std.record.get_or key map default in
      transformer value,

    # Multi-key lookup
    lookup_multi = fun map keys default =>
      let results = std.array.map (fun key => std.record.get_or key map default) keys in
      std.array.filter (fun result => result != default) results
  },

  # Integration function patterns
  IntegrationFunctions = {
    # Graph node metadata generation
    make_node_metadata = fun schema extension_data =>
      {
        schema_id = std.record.get_or "id" schema null,
        extension_name = extension_data.name,
        category = extension_data.category,
        graph_value = extension_data.graph_value or "medium"
      } & extension_data,

    # Code generation metadata
    make_codegen_metadata = fun schema extension_data =>
      {
        target_languages = extension_data.codegen_targets or ["rust"],
        schema_type = extension_data.category,
        validation_level = extension_data.validation or "basic"
      } & extension_data
  }
}
```

### versions/v1.1.0-alpha/nickel/primitives/extension_primitives/integration_primitives.ncl

```nickel
# Extension Integration Primitives - Common integration patterns

{
  # Graph integration primitives
  GraphIntegrationPrimitives = {
    # Base graph metadata
    base_graph_metadata = {
      node_type = "schema",
      edge_types = [],
      properties = {}
    },

    # Node metadata generators
    node_metadata_generators = {
      # For entity schemas
      entity_node = fun schema extension => {
        id = std.record.get_or "$id" schema "unknown",
        type = "entity",
        category = extension.category,
        extension_name = extension.name,
        properties = {
          required = std.record.get_or "required" schema [],
          properties = std.record.get_or "properties" schema {}
        }
      },

      # For infrastructure schemas
      infrastructure_node = fun schema extension => {
        id = std.record.get_or "$id" schema "unknown",
        type = "infrastructure",
        category = extension.category,
        extension_name = extension.name,
        properties = {
          scaling = std.record.get_or "scaling" schema {},
          resources = std.record.get_or "resources" schema {}
        }
      },

      # For topology schemas
      topology_node = fun schema extension => {
        id = std.record.get_or "$id" schema "unknown",
        type = "topology",
        category = extension.category,
        extension_name = extension.name,
        properties = {
          wiring = std.record.get_or "wiring" schema {},
          relationships = std.record.get_or "relationships" schema []
        }
      }
    },

    # Edge metadata generators
    edge_metadata_generators = {
      # Relationship edges
      relationship_edge = fun source target edge_type => {
        source_id = source.id,
        target_id = target.id,
        edge_type = edge_type,
        properties = {
          direction = "directed",
          cardinality = "many_to_one"
        }
      },

      # Dependency edges
      dependency_edge = fun source target => {
        source_id = source.id,
        target_id = target.id,
        edge_type = "depends_on",
        properties = {
          direction = "directed",
          strength = "strong",
          transitivity = true
        }
      }
    }
  },

  # Codegen integration primitives
  CodegenIntegrationPrimitives = {
    # Base codegen metadata
    base_codegen_metadata = {
      target_languages = ["rust"],
      features = [],
      derives = []
    },

    # Language-specific generators
    language_generators = {
      rust = {
        # Derive generators
        derives_by_category = {
          entity = ["Debug", "Clone", "Serialize", "Deserialize"],
          infrastructure = ["Debug", "Clone"],
          topology = ["Debug", "Clone", "Serialize"]
        },

        # Type mapping
        type_mapping = {
          string = "String",
          number = "f64",
          integer = "i64",
          boolean = "bool",
          array = "Vec",
          object = "HashMap"
        },

        # Feature flags
        feature_flags_by_category = {
          entity = ["serde"],
          infrastructure = ["tokio"],
          topology = ["petgraph", "serde"]
        }
      },

      typescript = {
        derives_by_category = {
          entity = [],
          infrastructure = [],
          topology = []
        },
        type_mapping = {
          string = "string",
          number = "number",
          integer = "number",
          boolean = "boolean",
          array = "Array",
          object = "Record"
        }
      }
    },

    # Codegen metadata generators
    metadata_generators = {
      entity_codegen = fun schema extension => {
        language = "rust",
        derives = language_generators.rust.derives_by_category.entity,
        features = language_generators.rust.feature_flags_by_category.entity,
        schema_type = "entity"
      },

      infrastructure_codegen = fun schema extension => {
        language = "rust",
        derives = language_generators.rust.derives_by_category.infrastructure,
        features = language_generators.rust.feature_flags_by_category.infrastructure,
        schema_type = "infrastructure"
      }
    }
  },

  # Validation integration primitives
  ValidationIntegrationPrimitives = {
    # Context-aware validation
    context_validators = {
      topology_context = fun schema =>
        std.record.has_field "relationships" schema &&
        std.record.has_field "wiring" schema,

      entity_context = fun schema =>
        std.record.has_field "properties" schema,

      infrastructure_context = fun schema =>
        std.record.has_field "resources" schema
    },

    # Schema-level validators
    schema_validators = {
      has_required_fields = fun schema required_fields =>
        std.array.all (fun field => std.record.has_field field schema) required_fields,

      field_type_check = fun schema field_checks =>
        std.record.all (fun field_name expected_type =>
          let actual_value = std.record.get_or field_name schema null in
          actual_value == null || std.type.of actual_value == expected_type
        ) field_checks
    }
  }
}
```

### versions/v1.1.0-alpha/nickel/primitives/extension_primitives/merge_primitives.ncl

```nickel
# Extension Merge Primitives - Common merge strategy patterns

{
  # Base merge strategies
  BaseMergeStrategies = {
    override = fun base override => override,

    compose = fun base override =>
      if std.type.of base == "Record && std.type.of override == "Record then
        base & override
      else override,

    validate_and_merge = fun validator => fun base override =>
      if validator override then base & override
      else std.contract.blame_with "merge" "Invalid value in merge: ${std.to_string override}",

    deep_merge = fun base override =>
      if std.type.of base == "Record && std.type.of override == "Record then
        std.record.map (fun key base_value =>
          let override_value = std.record.get_or key override null in
          if override_value != null then
            if std.type.of base_value == "Record && std.type.of override_value == "Record then
              deep_merge base_value override_value
            else override_value
          else base_value
        ) base
      else override
  },

  # Category-specific merge strategies
  CategoryMergeStrategies = {
    # For extensions that should not compose (like edge types)
    singleton_extension = {
      override = BaseMergeStrategies.override,
      compose = BaseMergeStrategies.override,  # No composition
      validate = BaseMergeStrategies.validate_and_merge (fun x => true)
    },

    # For extensions that can compose (like metadata)
    composable_extension = {
      override = BaseMergeStrategies.override,
      compose = BaseMergeStrategies.compose,
      validate = BaseMergeStrategies.validate_and_merge (fun x => std.type.of x == "Record)
    },

    # For extensions with deep merging (like complex configurations)
    deep_merge_extension = {
      override = BaseMergeStrategies.override,
      compose = BaseMergeStrategies.deep_merge,
      validate = BaseMergeStrategies.validate_and_merge (fun x => std.type.of x == "Record)
    }
  },

  # Merge strategy selectors
  StrategySelectors = {
    # Select strategy based on extension category
    by_category = fun category =>
      if category == "architecture" then CategoryMergeStrategies.singleton_extension
      else if category == "entity" then CategoryMergeStrategies.composable_extension
      else CategoryMergeStrategies.deep_merge_extension,

    # Select strategy based on merge behavior
    by_behavior = fun behavior =>
      if behavior == "singleton" then CategoryMergeStrategies.singleton_extension
      else if behavior == "composable" then CategoryMergeStrategies.composable_extension
      else CategoryMergeStrategies.deep_merge_extension
  },

  # Merge helpers
  MergeHelpers = {
    # Safe merge with error handling
    safe_merge = fun base override strategy =>
      try strategy.compose base override
      catch {
        std.contract.blame_with "merge" "Merge failed: ${std.to_string %catch}"
      },

    # Conditional merge
    conditional_merge = fun condition base override strategy =>
      if condition base override then strategy.compose base override
      else base,

    # Merge with validation
    validated_merge = fun validator base override strategy =>
      if validator override then strategy.compose base override
      else std.contract.blame_with "merge" "Validation failed for merge value: ${std.to_string override}"
  }
}
```

### versions/v1.1.0-alpha/nickel/primitives/extension_primitives/metadata_primitives.ncl

```nickel
# Extension Metadata Primitives - Common extension metadata patterns

{
  # Base extension metadata structure
  BaseExtensionMetadata = {
    name = "unknown",
    description = "No description provided",
    category = "unknown",
    required = false,
    version = "1.0.0"
  },

  # Category-specific metadata templates
  CategoryTemplates = {
    architecture = {
      category = "architecture",
      graph_value = "medium",
      validation = "context-dependent",
      context_required = []
    },

    entity = {
      category = "entity",
      graph_value = "high",
      validation = "schema-level",
      context_required = []
    },

    infrastructure = {
      category = "infrastructure",
      graph_value = "high",
      validation = "runtime",
      context_required = []
    },

    codegen = {
      category = "codegen",
      graph_value = "critical",
      validation = "build-time",
      context_required = []
    }
  },

  # Validation level primitives
  ValidationLevels = {
    none = "none",
    basic = "basic",
    context_dependent = "context-dependent",
    schema_level = "schema-level",
    strict = "strict"
  },

  # Graph value primitives
  GraphValues = {
    none = "none",
    low = "low",
    medium = "medium",
    high = "high",
    critical = "critical"
  }
}
```

### versions/v1.1.0-alpha/nickel/primitives/extraction_primitives.ncl

```nickel
# Extraction Primitives - Common schema extraction patterns

{
  # Entity extraction primitives
  EntityExtraction = {
    # Extract pure component data from mixed schemas
    extract_entity_data = fun raw_schema =>
      let forbidden_runtime = [
        "x-familiar-service", "x-familiar-api", "x-familiar-queue",
        "x-familiar-policy", "x-familiar-persistence", "x-familiar-resources",
        "x-familiar-monitoring-enabled", "x-familiar-node-type",
        "x-familiar-scaling", "x-familiar-deploy-config"
      ] in

      let forbidden_infrastructure = [
        "x-familiar-environment", "x-familiar-networking", "x-familiar-storage",
        "x-familiar-compute-limits", "x-familiar-load-balancing"
      ] in

      let forbidden_topology = [
        "x-familiar-depends_on", "x-familiar-communicates_with",
        "x-familiar-contains", "x-familiar-orchestrates",
        "x-familiar-deploys_to", "x-familiar-routes_to"
      ] in

      # Filter out all non-entity concerns
      std.record.filter
        (fun key _ =>
          !std.array.elem key (forbidden_runtime @ forbidden_infrastructure @ forbidden_topology))
        raw_schema,

    # Extract pure entity types from mixed schemas
    extract_entity_types = fun raw_schema =>
      let type_fields = [
        "$schema", "$id", "title", "description", "type",
        "properties", "required", "additionalProperties",
        "x-familiar-kind", "x-familiar-description"
      ] in

      std.record.filter
        (fun key _ => std.array.elem key type_fields)
        raw_schema
  },

  # Node extraction primitives
  NodeExtraction = {
    # Extract compute resources from mixed schemas
    extract_compute_resources = fun raw_schema =>
      let compute_fields = [
        "x-familiar-node-type", "x-familiar-resources", "x-familiar-scaling",
        "x-familiar-monitoring-enabled", "x-familiar-deploy-config",
        "x-familiar-environment", "x-familiar-networking"
      ] in

      # Filter to compute concerns only
      let compute_only = std.record.filter
        (fun key _ =>
          std.array.elem key compute_fields ||
          key == "x-familiar-kind" ||
          key == "x-familiar-description" ||
          key == "$schema" ||
          key == "$id" ||
          key == "title" ||
          key == "description")
        raw_schema in

      # Ensure required compute fields exist with defaults
      let with_defaults = compute_only & {
        "x-familiar-node-type" = if std.record.has_field "x-familiar-node-type" compute_only then
          compute_only."x-familiar-node-type" else "generic",
        "x-familiar-resources" = if std.record.has_field "x-familiar-resources" compute_only then
          compute_only."x-familiar-resources" else { cpu = "1", memory = "1Gi" },
        "x-familiar-scaling" = if std.record.has_field "x-familiar-scaling" compute_only then
          compute_only."x-familiar-scaling" else { min = 1, max = 1 }
      } in with_defaults,

    # Extract topology wiring from mixed schemas
    extract_topology_wiring = fun raw_schema =>
      let topology_fields = [
        "x-familiar-depends_on", "x-familiar-communicates_with",
        "x-familiar-contains", "x-familiar-orchestrates",
        "x-familiar-deploys_to", "x-familiar-routes_to",
        "x-familiar-edges"
      ] in

      std.record.filter
        (fun key _ => std.array.elem key topology_fields)
        raw_schema
  },

  # Domain extraction primitives
  DomainExtraction = {
    # Extract business domain logic from mixed schemas
    extract_domain_logic = fun raw_schema =>
      let domain_fields = [
        "x-familiar-business-rules", "x-familiar-domain-context",
        "x-familiar-agent-capabilities", "x-familiar-api",
        "x-familiar-auth", "x-familiar-tenant"
      ] in

      std.record.filter
        (fun key _ => std.array.elem key domain_fields)
        raw_schema
  }
}
```

### versions/v1.1.0-alpha/nickel/primitives/hydration_primitives.ncl

```nickel
# Hydration Primitives - Building blocks for runtime configuration composition

{
  # Base hydration primitives
  BaseHydration = {
    "_metadata" = {
      governance_level = "unknown",
      orthological_role = "unknown",
      category = "unknown"
    },
    "_observability" = {
      metrics_enabled = false,
      health_checks = false,
      monitoring = false
    },
    "_operations" = {
      deployment_strategy = "none",
      scaling_policy = "none"
    }
  },

  # Metadata primitives
  MetadataPrimitives = {
    governance_level = "unknown",
    orthological_role = "unknown",
    category = "unknown"
  },

  # Observability primitives
  ObservabilityPrimitives = {
    metrics_enabled = false,
    health_checks = false,
    monitoring = false,
    logging = "none"
  },

  # Operations primitives
  OperationsPrimitives = {
    deployment_strategy = "none",
    scaling_policy = "none",
    health_checks = false,
    monitoring = false
  },

  # Layer-specific hydration primitives
  LayerHydrationPrimitives = {
    architecture = {
      topology = {
        wiring_enforcement = "strict",
        relationship_validation = "continuous",
        data_flow_tracking = true
      }
    },

    infrastructure = {
      compute = {
        isolation_level = "container",
        scheduling_policy = "kubernetes_scheduler",
        resource_quotas = true
      }
    },

    codegen = {
      codegen = {
        generation_strategy = "tvm_pattern",
        type_safety = "strict",
        cross_language_support = true
      }
    }
  }
}
```

### versions/v1.1.0-alpha/nickel/primitives/layer_primitives.ncl

```nickel
# Layer Primitives - Building blocks for architectural layer definitions

{
  # Layer type primitives
  LayerTypePrimitives = {
    entity = "entity",
    node = "node",
    topology = "topology"
  },

  # Layer-specific function primitives
  LayerFunctionPrimitives = {
    architecture = {
      extract_from_raw = fun schema => schema,  # Placeholder - implemented in directory
      validate_pure = fun schema => {valid = true, errors = [], warnings = []}
    },

    infrastructure = {
      extract_from_raw = fun schema => schema,  # Placeholder - implemented in directory
      validate_pure = fun schema => {valid = true, errors = [], warnings = []}
    },

    codegen = {
      extract_from_raw = fun schema => schema,  # Placeholder - implemented in directory
      validate_pure = fun schema => {valid = true, errors = [], warnings = []}
    }
  },

  # Layer compatibility primitives
  LayerCompatibilityPrimitives = {
    architecture_schemas = ["topology"],
    infrastructure_schemas = ["node", "resource", "system"],
    codegen_schemas = ["entity", "component", "primitive"]
  }
}
```

### versions/v1.1.0-alpha/nickel/primitives/validation_primitives.ncl

```nickel
# Validation Primitives - Common schema validation patterns

{
  # Entity validation primitives
  EntityValidation = {
    # Validate pure component data (no runtime concerns)
    validate_pure_entity = fun schema =>
      let forbidden_runtime = [
        "x-familiar-service", "x-familiar-api", "x-familiar-queue",
        "x-familiar-policy", "x-familiar-persistence", "x-familiar-resources"
      ] in

      let forbidden_infrastructure = [
        "x-familiar-environment", "x-familiar-networking", "x-familiar-storage",
        "x-familiar-compute-limits", "x-familiar-node-type", "x-familiar-scaling"
      ] in

      let forbidden_topology = [
        "x-familiar-depends_on", "x-familiar-communicates_with",
        "x-familiar-contains", "x-familiar-orchestrates"
      ] in

      let all_forbidden = forbidden_runtime @ forbidden_infrastructure @ forbidden_topology in

      let violations = std.record.fields schema
        |> std.array.filter (fun field => std.array.elem field all_forbidden) in

      if std.array.is_empty violations then
        { valid = true, errors = [], warnings = [] }
      else
        {
          valid = false,
          errors = std.array.map (fun field => "Forbidden runtime/infrastructure field in component: %{field}") violations,
          warnings = []
        }
  },

  # Node validation primitives
  NodeValidation = {
    # Validate pure compute resources (no business logic)
    validate_pure_compute = fun schema =>
      let forbidden_business = [
        "x-familiar-business-rules", "x-familiar-domain-context",
        "x-familiar-agent-capabilities", "x-familiar-api-contracts"
      ] in

      let forbidden_entity = [
        "properties", "required", "additionalProperties",
        "x-familiar-component-type", "x-familiar-entity-kind"
      ] in

      let forbidden_topology = [
        "x-familiar-depends_on", "x-familiar-communicates_with",
        "x-familiar-contains", "x-familiar-orchestrates"
      ] in

      let all_forbidden = forbidden_business @ forbidden_entity @ forbidden_topology in

      let violations = std.record.fields schema
        |> std.array.filter (fun field => std.array.elem field all_forbidden) in

      if std.array.is_empty violations then
        { valid = true, errors = [], warnings = [] }
      else
        {
          valid = false,
          errors = std.array.map (fun field => "Forbidden business/entity field in node: %{field}") violations,
          warnings = []
        }
  },

  # Topology validation primitives
  TopologyValidation = {
    # Validate pure topology wiring (no implementation details)
    validate_pure_topology = fun schema =>
      let forbidden_implementation = [
        "x-familiar-service", "x-familiar-api", "x-familiar-resources",
        "x-familiar-scaling", "x-familiar-deploy-config", "properties",
        "x-familiar-component-type", "x-familiar-node-type"
      ] in

      let allowed_topology = [
        "x-familiar-depends_on", "x-familiar-communicates_with",
        "x-familiar-contains", "x-familiar-orchestrates",
        "x-familiar-edges"
      ] in

      let violations = std.record.fields schema
        |> std.array.filter (fun field =>
          std.array.elem field forbidden_implementation &&
          !std.array.elem field allowed_topology) in

      if std.array.is_empty violations then
        { valid = true, errors = [], warnings = [] }
      else
        {
          valid = false,
          errors = std.array.map (fun field => "Forbidden implementation field in topology: %{field}") violations,
          warnings = []
        }
  }
}
```

### versions/v1.1.0-alpha/nickel/validation.ncl

```nickel
# Simple Nickel validation for testing
# Validates that a JSON schema can be parsed and has basic required fields

let schema_content = std.record.get_or "SCHEMA_FILE" std.env "" in

let validation_result = if schema_content == "" then
  {
    valid = false,
    errors = ["No schema content provided"],
    warnings = []
  }
else
  let schema = std.from_json schema_content in

  # Basic validation: check if schema has required fields
  let has_dollar_schema = std.record.has_field "$schema" schema in
  let has_kind = std.record.has_field "x-familiar-kind" schema in

  if has_dollar_schema && has_kind then
    {
      valid = true,
      errors = [],
      warnings = []
    }
  else
    let missing_fields = (if has_dollar_schema then [] else ["$schema"]) @
                        (if has_kind then [] else ["x-familiar-kind"]) in
    {
      valid = false,
      errors = ["Missing required fields: " ++ std.string.join ", " missing_fields],
      warnings = []
    }
in

# Export orthologically-validated result
validation_result

```

### versions/v1.1.0-alpha/nickel/windmill/_directory.ncl

```nickel
/**
 * DEPRECATED: Windmill Directory
 *
 * This directory is deprecated and should not be used for new schemas.
 * 
 * @deprecated This directory contains legacy windmill-related schemas that
 * should be migrated to appropriate domain or infrastructure directories.
 * 
 * All new schemas should use the orthological structure with proper
 * separation of concerns (codegen, infrastructure, architecture, domain).
 */

# Deprecated directory - always fails validation
{
  files = {
    _ : {
      extract_topology_wiring = fun raw_schema => raw_schema & {
        "x-familiar-deprecation-warning" = "Windmill directory is deprecated",
        "x-familiar-migration-required" = true
      },
      validate_pure_topology = fun schema => {
        valid = false,
        errors = ["Windmill directory is deprecated. Migrate schemas to appropriate orthological directories."],
        warnings = []
      },
      get_layer = `deprecated
    }
  },

  # No hydration for deprecated directories
  hydration = {}
}

```

## Rust Source Files

### packages/familiar-schemas/src/checksum.rs

```rust
//! Checksum utilities for schema integrity verification

use sha2::{Sha256, Digest};
use serde::{Deserialize, Serialize};
use std::fmt;

/// SHA256 checksum for schema content
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Checksum(String);

impl Checksum {
    /// Compute checksum from raw bytes
    pub fn from_bytes(data: &[u8]) -> Self {
        let hash = Sha256::digest(data);
        Self(format!("{:x}", hash))
    }

    /// Compute checksum from a string
    pub fn from_str(content: &str) -> Self {
        Self::from_bytes(content.as_bytes())
    }

    /// Compute checksum from JSON value (canonicalized)
    pub fn from_json(value: &serde_json::Value) -> Self {
        // Canonicalize JSON by converting to string with sorted keys
        let canonical = serde_json::to_string(value).unwrap_or_default();
        Self::from_str(&canonical)
    }

    /// Get the hex string representation
    pub fn as_str(&self) -> &str {
        &self.0
    }

    /// Verify that content matches this checksum
    pub fn verify(&self, content: &str) -> bool {
        let computed = Self::from_str(content);
        self.0 == computed.0
    }

    /// Verify that JSON value matches this checksum
    pub fn verify_json(&self, value: &serde_json::Value) -> bool {
        let computed = Self::from_json(value);
        self.0 == computed.0
    }
}

impl fmt::Display for Checksum {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<String> for Checksum {
    fn from(s: String) -> Self {
        Self(s)
    }
}

impl From<&str> for Checksum {
    fn from(s: &str) -> Self {
        Self(s.to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_checksum_consistency() {
        let content = r#"{"name": "test", "version": "1.0.0"}"#;
        let checksum1 = Checksum::from_str(content);
        let checksum2 = Checksum::from_str(content);
        assert_eq!(checksum1, checksum2);
    }

    #[test]
    fn test_checksum_different_content() {
        let content1 = r#"{"name": "test1"}"#;
        let content2 = r#"{"name": "test2"}"#;
        let checksum1 = Checksum::from_str(content1);
        let checksum2 = Checksum::from_str(content2);
        assert_ne!(checksum1, checksum2);
    }

    #[test]
    fn test_checksum_verification() {
        let content = r#"{"name": "test"}"#;
        let checksum = Checksum::from_str(content);
        assert!(checksum.verify(content));
        assert!(!checksum.verify("different content"));
    }
}









```

### packages/familiar-schemas/src/compiler.rs

```rust
//! Schema Architecture Validator & Compiler Configuration
//!
//! Enforces the strict consolidation policy at build time to prevent
//! unauthorized x-familiar-* extensions from being committed.
//!
//! ## Compiler Configuration
//! Platform-wide settings that control code generation behavior.
//! These settings are NOT configurable per-schema - they're global platform decisions.
//!
//! ## Future: Directory Structure Alignment
//! TODO: Restructure directories to directly align with graph regions per TVM BYOC:
//! - `infrastructure/`  CPU/GPU regions
//! - `entities/`  Memory regions
//! - `actions/`  Operator regions
//! - `techniques/`  Composite regions
//! - `primitives/`  Atomic regions
//!
//! This will create a direct mapping between filesystem structure and
//! compilation graph topology, enabling better optimization and caching.

use thiserror::Error;

/// Metaschema validation for directory-specific schema rules
#[cfg(feature = "metaschema-validation")]
use jsonschema::{Draft, JSONSchema};
#[cfg(feature = "metaschema-validation")]
use miette::{Diagnostic, NamedSource, SourceSpan};

/// Platform-wide compiler configuration that controls code generation behavior.
/// These settings are NOT per-schema - they're global platform decisions.
///
/// Schemas define WHAT the data structure is.
/// CompilerConfig defines HOW it's represented in generated code.
#[derive(Debug, Clone)]
pub struct CompilerConfig {
    /// Default field name to use for internal tagging in discriminated unions
    pub discriminator_field: String,

    /// Default casing strategy for enum variants (PascalCase, camelCase, snake_case, etc.)
    pub variant_casing: Casing,

    /// Whether to use `serde(rename_all = "...")` by default
    pub default_rename_all: Option<String>,

    /// Whether to skip serializing None values by default
    pub skip_none_by_default: bool,

    /// Whether to flatten nested structures by default (discouraged)
    pub flatten_by_default: bool,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Casing {
    PascalCase,
    CamelCase,
    SnakeCase,
    ScreamingSnakeCase,
    KebabCase,
}

impl Default for CompilerConfig {
    fn default() -> Self {
        Self {
            discriminator_field: "kind".to_string(),
            variant_casing: Casing::PascalCase,
            default_rename_all: Some("snake_case".to_string()),
            skip_none_by_default: true,
            flatten_by_default: false,
        }
    }
}

#[derive(Error, Debug)]
pub enum SchemaArchitectureError {
    #[error(" Schema Architecture Violation\n UNAUTHORIZED EXTENSION: '{extension}'\n ALLOWED EXTENSIONS (9 total):\n Structural: x-familiar-kind, x-familiar-service, x-familiar-queue, x-familiar-resources\n Objects: x-familiar-persistence, x-familiar-serde, x-familiar-api, x-familiar-policy, x-familiar-visual\n Legacy: x-familiar-description, x-familiar-meta-schema\n FIX: Consolidate '{extension}' into appropriate object or remove if redundant.\n Location: {path}")]
    UnauthorizedExtension {
        extension: String,
        path: String,
    },

    #[error(" Schema Architecture Violation\n REDUNDANT FIELD: '{field}'\n This field is calculated automatically by the Graph Compiler.\n FIX: Remove this field - it will be computed at build time.\n Location: {path}")]
    RedundantField {
        field: String,
        path: String,
    },
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compiler_config_defaults() {
        let config = CompilerConfig::default();

        assert_eq!(config.discriminator_field, "kind");
        assert_eq!(config.variant_casing, Casing::PascalCase);
        assert_eq!(config.default_rename_all, Some("snake_case".to_string()));
        assert!(config.skip_none_by_default);
        assert!(!config.flatten_by_default);
    }
}

```

### packages/familiar-schemas/src/edge_inheritance.rs

```rust
//! Edge Inheritance Resolution for Frame Graph Architecture
//!
//! Resolves edge semantics through inheritance hierarchy:
//! directory-specific edges  global edges  compilation metadata

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;
use crate::SchemaArchitectureError;

/// Resolved edge metadata after inheritance resolution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EdgeMetadata {
    /// Edge type name (e.g., "depends_on", "orchestrates")
    pub edge_type: String,

    /// Directionality of the relationship
    pub directionality: EdgeDirectionality,

    /// Cardinality constraints
    pub cardinality: EdgeCardinality,

    /// Whether relationship supports transitivity (ABC  AC)
    pub transitivity: bool,

    /// Whether cycles are allowed
    pub cyclicity: EdgeCyclicity,

    /// Type of data flow
    pub data_flow: String,

    /// Relationship strength (weak/medium/strong)
    pub strength: String,

    /// Context-specific usage
    pub context: String,

    /// Compilation implications for code generation
    pub compilation_implications: CompilationImplications,

    /// Traversal rules for graph algorithms
    pub traversal_rules: TraversalRules,

    /// Additional metadata from directory specialization
    pub metadata: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EdgeDirectionality {
    Directed,
    Bidirectional,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EdgeCardinality {
    OneToOne,
    OneToMany,
    ManyToOne,
    ManyToMany,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EdgeCyclicity {
    Acyclic,
    CyclicAllowed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompilationImplications {
    /// Whether to generate dependency injection code
    pub generate_dependency_injection: bool,

    /// Whether to generate initialization ordering
    pub generate_initialization_order: bool,

    /// Whether to generate lifecycle management
    pub generate_lifecycle_management: bool,

    /// Additional context-specific implications
    pub additional: HashMap<String, bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraversalRules {
    /// Whether this edge can be traversed
    pub can_traverse: bool,

    /// Whether cycles are allowed (for cycle detection)
    pub allows_cycles: bool,

    /// Whether topological sorting is required
    pub topological_sort_required: bool,

    /// Additional traversal metadata
    pub additional: HashMap<String, serde_json::Value>,
}

/// Edge inheritance resolver
#[derive(Clone)]
pub struct EdgeInheritanceResolver {
    global_edges: HashMap<String, EdgeMetadata>,
    directory_edges: HashMap<String, HashMap<String, EdgeMetadata>>,
}

impl EdgeInheritanceResolver {
    pub fn new() -> Self {
        Self {
            global_edges: HashMap::new(),
            directory_edges: HashMap::new(),
        }
    }

    /// Load global edge definitions from extensions/edge-type.ncl
    pub fn load_global_edges(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let global_path = Path::new("versions/latest/nickel/extensions/edge-type.ncl");

        // Execute nickel directly to get the resolved configuration
        let output = std::process::Command::new("nickel")
            .args(&["export", "--format", "json"])
            .arg(global_path)
            .output()?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(format!("Nickel execution failed: {}", stderr).into());
        }

        let json_str = String::from_utf8(output.stdout)?;
        let nickel_config: serde_json::Value = serde_json::from_str(&json_str)?;

        // Parse edge types from Nickel config
        if let Some(edge_types) = nickel_config.get("edge_types") {
            if let serde_json::Value::Object(edge_map) = edge_types {
                for (edge_name, edge_config) in edge_map {
                    let metadata = self.parse_edge_metadata(&edge_name, &edge_config)?;
                    self.global_edges.insert(edge_name.to_string(), metadata);
                }
            }
        }

        Ok(())
    }

    /// Load directory-specific edge specializations
    pub fn load_directory_edges(&mut self, directory_path: &str) -> Result<(), Box<dyn std::error::Error>> {
        let nickel_path_str = format!("versions/latest/nickel/{}/edge-semantics.ncl", directory_path);
        let nickel_path = Path::new(&nickel_path_str);

        // Execute nickel directly
        let output = std::process::Command::new("nickel")
            .args(&["export", "--format", "json"])
            .arg(nickel_path)
            .output()?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(format!("Nickel execution failed: {}", stderr).into());
        }

        let json_str = String::from_utf8(output.stdout)?;
        let nickel_config: serde_json::Value = serde_json::from_str(&json_str)?;

        let mut dir_edges = HashMap::new();

        // Parse specialized edge types
        if let Some(edge_types) = nickel_config.get("edge_types") {
            if let serde_json::Value::Object(edge_map) = edge_types {
                for (edge_name, edge_config) in edge_map {
                    let metadata = self.parse_edge_metadata(&edge_name, &edge_config)?;
                    dir_edges.insert(edge_name.to_string(), metadata);
                }
            }
        }

        self.directory_edges.insert(directory_path.to_string(), dir_edges);
        Ok(())
    }

    /// Resolve edge semantics for a schema path with inheritance
    pub fn resolve_edge_semantics(&self, schema_path: &Path, edge_type: &str) -> Result<EdgeMetadata, SchemaArchitectureError> {
        // Determine directory from schema path
        let directory = self.infer_directory_from_path(schema_path)?;

        // Try directory-specific edge first
        if let Some(dir_edges) = self.directory_edges.get(&directory) {
            if let Some(dir_edge) = dir_edges.get(edge_type) {
                return Ok(dir_edge.clone());
            }
        }

        // Fall back to global edge
        self.global_edges.get(edge_type)
            .cloned()
            .ok_or_else(|| SchemaArchitectureError::UnauthorizedExtension {
                extension: format!("edge_type:{}", edge_type),
                path: schema_path.to_string_lossy().to_string(),
            })
    }

    /// Infer directory type from schema path
    fn infer_directory_from_path(&self, schema_path: &Path) -> Result<String, SchemaArchitectureError> {
        let path_str = schema_path.to_string_lossy();

        if path_str.contains("json-schema/architecture/") {
            Ok("architecture".to_string())
        } else if path_str.contains("json-schema/infrastructure/") {
            Ok("infrastructure".to_string())
        } else if path_str.contains("json-schema/codegen/") {
            Ok("codegen".to_string())
        } else if path_str.contains("json-schema/domain/") {
            Ok("domain".to_string())
        } else {
            Err(SchemaArchitectureError::UnauthorizedExtension {
                extension: "unknown_directory_structure".to_string(),
                path: path_str.to_string(),
            })
        }
    }

    /// Parse edge metadata from Nickel JSON output
    fn parse_edge_metadata(&self, edge_name: &str, config: &serde_json::Value) -> Result<EdgeMetadata, Box<dyn std::error::Error>> {
        let config_obj = config.as_object()
            .ok_or("Edge config must be an object")?;

        let directionality = match config_obj.get("directionality").and_then(|v| v.as_str()) {
            Some("directed") => EdgeDirectionality::Directed,
            Some("bidirectional") => EdgeDirectionality::Bidirectional,
            _ => EdgeDirectionality::Directed,
        };

        let cardinality = match config_obj.get("cardinality").and_then(|v| v.as_str()) {
            Some("one_to_one") => EdgeCardinality::OneToOne,
            Some("one_to_many") => EdgeCardinality::OneToMany,
            Some("many_to_one") => EdgeCardinality::ManyToOne,
            Some("many_to_many") => EdgeCardinality::ManyToMany,
            _ => EdgeCardinality::ManyToOne,
        };

        let transitivity = config_obj.get("transitivity").and_then(|v| v.as_bool()).unwrap_or(false);

        let cyclicity = match config_obj.get("cyclicity").and_then(|v| v.as_str()) {
            Some("acyclic") => EdgeCyclicity::Acyclic,
            Some("cyclic_allowed") => EdgeCyclicity::CyclicAllowed,
            _ => EdgeCyclicity::Acyclic,
        };

        let data_flow = config_obj.get("data_flow").and_then(|v| v.as_str()).unwrap_or("none").to_string();
        let strength = config_obj.get("strength").and_then(|v| v.as_str()).unwrap_or("medium").to_string();
        let context = config_obj.get("context").and_then(|v| v.as_str()).unwrap_or("general").to_string();

        // Parse compilation implications
        let compilation_implications = if let Some(compilation) = config_obj.get("compilation_implications") {
            self.parse_compilation_implications(compilation)?
        } else {
            CompilationImplications {
                generate_dependency_injection: false,
                generate_initialization_order: false,
                generate_lifecycle_management: false,
                additional: HashMap::new(),
            }
        };

        // Parse traversal rules
        let traversal_rules = if let Some(traversal) = config_obj.get("traversal_rules") {
            self.parse_traversal_rules(traversal)?
        } else {
            TraversalRules {
                can_traverse: true,
                allows_cycles: matches!(cyclicity, EdgeCyclicity::CyclicAllowed),
                topological_sort_required: matches!(cyclicity, EdgeCyclicity::Acyclic),
                additional: HashMap::new(),
            }
        };

        let mut metadata = HashMap::new();
        if let Some(meta) = config_obj.get("metadata") {
            if let serde_json::Value::Object(meta_obj) = meta {
                for (k, v) in meta_obj {
                    metadata.insert(k.clone(), v.clone());
                }
            }
        }

        Ok(EdgeMetadata {
            edge_type: edge_name.to_string(),
            directionality,
            cardinality,
            transitivity,
            cyclicity,
            data_flow,
            strength,
            context,
            compilation_implications,
            traversal_rules,
            metadata,
        })
    }

    fn parse_compilation_implications(&self, config: &serde_json::Value) -> Result<CompilationImplications, Box<dyn std::error::Error>> {
        let obj = config.as_object().ok_or("Compilation implications must be an object")?;

        let mut additional = HashMap::new();
        for (key, value) in obj {
            if !matches!(key.as_str(), "generate_dependency_injection" | "generate_initialization_order" | "generate_lifecycle_management") {
                if let serde_json::Value::Bool(bool_val) = value {
                    additional.insert(key.clone(), *bool_val);
                }
            }
        }

        Ok(CompilationImplications {
            generate_dependency_injection: obj.get("generate_dependency_injection").and_then(|v| v.as_bool()).unwrap_or(false),
            generate_initialization_order: obj.get("generate_initialization_order").and_then(|v| v.as_bool()).unwrap_or(false),
            generate_lifecycle_management: obj.get("generate_lifecycle_management").and_then(|v| v.as_bool()).unwrap_or(false),
            additional,
        })
    }

    fn parse_traversal_rules(&self, config: &serde_json::Value) -> Result<TraversalRules, Box<dyn std::error::Error>> {
        let obj = config.as_object().ok_or("Traversal rules must be an object")?;

        let mut additional = HashMap::new();
        for (key, value) in obj {
            if !matches!(key.as_str(), "can_traverse" | "allows_cycles" | "topological_sort_required") {
                additional.insert(key.clone(), value.clone());
            }
        }

        Ok(TraversalRules {
            can_traverse: obj.get("can_traverse").and_then(|v| v.as_bool()).unwrap_or(true),
            allows_cycles: obj.get("allows_cycles").and_then(|v| v.as_bool()).unwrap_or(false),
            topological_sort_required: obj.get("topological_sort_required").and_then(|v| v.as_bool()).unwrap_or(false),
            additional,
        })
    }

    /// Validate that all required directories are loaded
    pub fn validate_completeness(&self) -> Result<(), SchemaArchitectureError> {
        let required_directories = ["architecture", "infrastructure", "codegen"];

        for dir in &required_directories {
            if !self.directory_edges.contains_key(*dir) {
                return Err(SchemaArchitectureError::UnauthorizedExtension {
                    extension: format!("missing_directory:{}", dir),
                    path: "edge_inheritance_resolver".to_string(),
                });
            }
        }

        Ok(())
    }
}

/// Typed edge for Frame Graph construction
#[derive(Debug, Clone)]
pub struct TypedEdge {
    pub source: String,
    pub target: String,
    pub edge_type: String,
    pub metadata: EdgeMetadata,
}

impl TypedEdge {
    pub fn new(source: String, target: String, edge_type: String, metadata: EdgeMetadata) -> Self {
        Self {
            source,
            target,
            edge_type,
            metadata,
        }
    }

    /// Check if this edge requires topological sorting
    pub fn requires_topological_sort(&self) -> bool {
        self.metadata.traversal_rules.topological_sort_required
    }

    /// Check if cycles are allowed for this edge
    pub fn allows_cycles(&self) -> bool {
        self.metadata.traversal_rules.allows_cycles
    }
}
```

### packages/familiar-schemas/src/error.rs

```rust
//! Error types for the schema library

use thiserror::Error;

/// Result type for schema operations
pub type Result<T> = std::result::Result<T, SchemaError>;

/// Schema library errors
#[derive(Error, Debug)]
pub enum SchemaError {
    #[error("Schema not found: {name} version {version}")]
    NotFound { name: String, version: String },

    #[error("Schema already exists: {name} version {version}")]
    AlreadyExists { name: String, version: String },

    #[error("Checksum mismatch: expected {expected}, got {actual}")]
    ChecksumMismatch { expected: String, actual: String },

    #[error("Invalid version: {0}")]
    InvalidVersion(String),

    #[error("Invalid schema format: {0}")]
    InvalidFormat(String),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("JSON error: {0}")]
    Json(#[from] serde_json::Error),

    #[error("Semver error: {0}")]
    Semver(#[from] semver::Error),
}









```

### packages/familiar-schemas/src/frame_graph.rs

```rust
//! Frame Graph Builder for HECS-based Schema Compilation
//!
//! Builds transient dependency graphs from schema relationships and performs
//! topological sorting for compilation ordering.

use petgraph::graph::{DiGraph, NodeIndex};
use petgraph::algo::toposort;
use std::collections::HashMap;
use std::hash::Hash;
use std::fmt;
use crate::edge_inheritance::{EdgeInheritanceResolver, EdgeMetadata};
use crate::SchemaArchitectureError;

/// Entity identifier in the Frame Graph
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EntityId {
    pub schema_ref: String,
    pub entity_type: String,
}

impl EntityId {
    pub fn new(schema_ref: String, entity_type: String) -> Self {
        Self {
            schema_ref,
            entity_type,
        }
    }
}

/// Frame Graph for compilation ordering
pub struct FrameGraph {
    graph: DiGraph<EntityId, EdgeMetadata>,
    node_map: HashMap<EntityId, NodeIndex>,
    inheritance_resolver: EdgeInheritanceResolver,
}

impl FrameGraph {
    pub fn new(inheritance_resolver: EdgeInheritanceResolver) -> Self {
        Self {
            graph: DiGraph::new(),
            node_map: HashMap::new(),
            inheritance_resolver,
        }
    }

    /// Add an entity to the graph
    pub fn add_entity(&mut self, entity_id: EntityId) -> NodeIndex {
        if let Some(&node_idx) = self.node_map.get(&entity_id) {
            return node_idx;
        }

        let node_idx = self.graph.add_node(entity_id.clone());
        self.node_map.insert(entity_id, node_idx);
        node_idx
    }

    /// Add a typed edge between entities
    pub fn add_edge(&mut self, source: EntityId, target: EntityId, edge_type: &str) -> Result<(), SchemaArchitectureError> {
        // Resolve edge semantics through inheritance
        let dummy_path = std::path::Path::new(&source.schema_ref);
        let metadata = self.inheritance_resolver.resolve_edge_semantics(dummy_path, edge_type)?;

        // Add nodes if they don't exist
        let source_idx = self.add_entity(source);
        let target_idx = self.add_entity(target);

        // Add edge with metadata
        self.graph.add_edge(source_idx, target_idx, metadata);

        Ok(())
    }

    /// Build compilation order using topological sorting
    pub fn build_compilation_order(&self) -> Result<Vec<EntityId>, FrameGraphError> {
        // Perform topological sort
        let sorted_indices = toposort(&self.graph, None)
            .map_err(|cycle: petgraph::algo::Cycle<NodeIndex>| FrameGraphError::CyclicalDependency(cycle.node_id()))?;

        // Convert back to EntityIds
        let mut compilation_order: Vec<EntityId> = Vec::new();
        for node_idx in sorted_indices {
            if let Some(entity_id) = self.graph.node_weight(node_idx) {
                compilation_order.push(entity_id.clone());
            }
        }

        Ok(compilation_order)
    }

    /// Validate graph constraints based on edge metadata
    pub fn validate_constraints(&self) -> Result<(), FrameGraphError> {
        // Check for cycles in acyclic edges
        for edge_idx in self.graph.edge_indices() {
            let (source_idx, target_idx) = self.graph.edge_endpoints(edge_idx)
                .ok_or(FrameGraphError::InvalidEdge(edge_idx))?;

            let metadata = self.graph.edge_weight(edge_idx)
                .ok_or(FrameGraphError::InvalidEdge(edge_idx))?;

            // If edge doesn't allow cycles, check for cycles involving this edge
            if !metadata.traversal_rules.allows_cycles {
                if self.detect_cycle_involving_edge(source_idx, target_idx) {
                    return Err(FrameGraphError::AcyclicEdgeViolation {
                        edge_type: metadata.edge_type.clone(),
                        source: self.graph.node_weight(source_idx).unwrap().schema_ref.clone(),
                        target: self.graph.node_weight(target_idx).unwrap().schema_ref.clone(),
                    });
                }
            }
        }

        Ok(())
    }

    /// Detect if there's a cycle involving a specific edge
    fn detect_cycle_involving_edge(&self, source_idx: NodeIndex, target_idx: NodeIndex) -> bool {
        // Simple cycle detection - check if target can reach source
        // In practice, would use more sophisticated cycle detection
        use petgraph::algo::has_path_connecting;

        has_path_connecting(&self.graph, target_idx, source_idx, None)
    }

    /// Get edges that require topological sorting
    pub fn get_topological_edges(&self) -> Vec<&EdgeMetadata> {
        self.graph.edge_weights()
            .filter(|metadata| metadata.traversal_rules.topological_sort_required)
            .collect()
    }

    /// Analyze graph for optimization opportunities
    pub fn analyze_optimization_opportunities(&self) -> GraphAnalysis {
        let mut analysis = GraphAnalysis::default();

        // Count edges by type
        for metadata in self.graph.edge_weights() {
            *analysis.edge_type_counts.entry(metadata.edge_type.clone()).or_insert(0) += 1;
        }

        // Find parallel edges (same source/target with different edge types)
        let mut parallel_edges = HashMap::new();
        for edge_idx in self.graph.edge_indices() {
            if let Some((source_idx, target_idx)) = self.graph.edge_endpoints(edge_idx) {
                let key = (source_idx, target_idx);
                parallel_edges.entry(key).or_insert_with(Vec::new).push(edge_idx);
            }
        }

        analysis.parallel_relationships = parallel_edges.into_iter()
            .filter(|(_key, edges)| edges.len() > 1)
            .map(|((source_idx, target_idx), edge_indices)| {
                let source = self.graph.node_weight(source_idx).unwrap().schema_ref.clone();
                let target = self.graph.node_weight(target_idx).unwrap().schema_ref.clone();
                let edge_types: Vec<String> = edge_indices.into_iter()
                    .filter_map(|idx| self.graph.edge_weight(idx))
                    .map(|m| m.edge_type.clone())
                    .collect();

                ParallelRelationship { source, target, edge_types }
            })
            .collect();

        // Calculate graph density
        let node_count = self.graph.node_count() as f64;
        let edge_count = self.graph.edge_count() as f64;
        analysis.density = if node_count > 1.0 {
            (2.0 * edge_count) / (node_count * (node_count - 1.0))
        } else {
            0.0
        };

        analysis
    }

    /// Get strongly connected components (for cycle analysis)
    pub fn find_strongly_connected_components(&self) -> Vec<Vec<EntityId>> {
        use petgraph::algo::kosaraju_scc;

        kosaraju_scc(&self.graph).into_iter()
            .filter(|component: &Vec<NodeIndex>| component.len() > 1) // Only non-trivial components
            .map(|component_indices: Vec<NodeIndex>| {
                component_indices.into_iter()
                    .filter_map(|idx| self.graph.node_weight(idx))
                    .cloned()
                    .collect()
            })
            .collect()
    }
}

/// Frame Graph Builder - constructs FrameGraphs from schema collections
pub struct FrameGraphBuilder {
    inheritance_resolver: EdgeInheritanceResolver,
}

impl FrameGraphBuilder {
    pub fn new(inheritance_resolver: EdgeInheritanceResolver) -> Self {
        Self {
            inheritance_resolver,
        }
    }

    /// Build Frame Graph from schema collection
    pub fn build_from_schemas(&self, schemas: &[serde_json::Value]) -> Result<FrameGraph, FrameGraphError> {
        let mut frame_graph = FrameGraph::new(self.inheritance_resolver.clone());

        // Extract edges from all schemas
        for schema in schemas {
            self.extract_edges_from_schema(schema, &mut frame_graph)?;
        }

        // Validate constraints
        frame_graph.validate_constraints()?;

        Ok(frame_graph)
    }

    /// Extract edges from a single schema
    fn extract_edges_from_schema(&self, schema: &serde_json::Value, frame_graph: &mut FrameGraph) -> Result<(), FrameGraphError> {
        let schema_ref = schema.get("$id")
            .and_then(|id| id.as_str())
            .unwrap_or("unknown_schema")
            .to_string();

        let entity_type = schema.get("x-familiar-kind")
            .and_then(|kind| kind.as_str())
            .unwrap_or("unknown")
            .to_string();

        let source_entity = EntityId::new(schema_ref.clone(), entity_type);

        // Extract edges from relationship fields
        let relationship_fields = [
            "x-familiar-depends", "x-familiar-reads", "x-familiar-writes",
            "x-familiar-components", "x-familiar-systems", "x-familiar-resources",
            "x-familiar-service", "x-familiar-queue"
        ];

        for field_name in &relationship_fields {
            if let Some(field_value) = schema.get(field_name) {
                if let Some(relationships) = field_value.as_array() {
                    for relationship in relationships {
                        self.process_relationship(&source_entity, relationship, frame_graph)?;
                    }
                }
            }
        }

        Ok(())
    }

    /// Process a single relationship object
    fn process_relationship(&self, source_entity: &EntityId, relationship: &serde_json::Value, frame_graph: &mut FrameGraph) -> Result<(), FrameGraphError> {
        // Check if it's the new typed format
        if let (Some(edge_type), Some(target_obj)) = (
            relationship.get("edge_type").and_then(|et| et.as_str()),
            relationship.get("target")
        ) {
            if let Some(target_ref) = target_obj.get("$ref").and_then(|tr| tr.as_str()) {
                let target_entity = EntityId::new(target_ref.to_string(), "unknown".to_string());
                frame_graph.add_edge(source_entity.clone(), target_entity, edge_type)?;
            }
        }

        Ok(())
    }

    /// Build compilation plan from Frame Graph
    pub fn build_compilation_plan(&self, frame_graph: &FrameGraph) -> Result<CompilationPlan, FrameGraphError> {
        let compilation_order = frame_graph.build_compilation_order()?;
        let analysis = frame_graph.analyze_optimization_opportunities();

        Ok(CompilationPlan {
            entity_order: compilation_order,
            analysis: analysis.clone(),
            optimization_suggestions: self.generate_optimization_suggestions(&analysis),
        })
    }

    /// Generate optimization suggestions based on analysis
    fn generate_optimization_suggestions(&self, analysis: &GraphAnalysis) -> Vec<OptimizationSuggestion> {
        let mut suggestions = Vec::new();

        // Suggest batching for high graph density
        if analysis.density > 0.7 {
            suggestions.push(OptimizationSuggestion {
                suggestion_type: "high_density".to_string(),
                description: "Graph has high density - consider batching operations".to_string(),
                impact: OptimizationImpact::High,
            });
        }

        // Suggest consolidating parallel relationships
        if !analysis.parallel_relationships.is_empty() {
            suggestions.push(OptimizationSuggestion {
                suggestion_type: "parallel_relationships".to_string(),
                description: format!("Found {} parallel relationships that could be consolidated", analysis.parallel_relationships.len()),
                impact: OptimizationImpact::Medium,
            });
        }

        // Suggest optimizations based on edge type distribution
        for (edge_type, count) in &analysis.edge_type_counts {
            if *count > 10 {
                suggestions.push(OptimizationSuggestion {
                    suggestion_type: "frequent_edge_type".to_string(),
                    description: format!("Edge type '{}' used {} times - consider specialized handling", edge_type, count),
                    impact: OptimizationImpact::Low,
                });
            }
        }

        suggestions
    }
}

/// Compilation plan derived from Frame Graph analysis
#[derive(Debug, Clone)]
pub struct CompilationPlan {
    pub entity_order: Vec<EntityId>,
    pub analysis: GraphAnalysis,
    pub optimization_suggestions: Vec<OptimizationSuggestion>,
}

/// Graph analysis results
#[derive(Debug, Clone, Default)]
pub struct GraphAnalysis {
    pub edge_type_counts: HashMap<String, usize>,
    pub parallel_relationships: Vec<ParallelRelationship>,
    pub density: f64,
}

/// Parallel relationship between entities
#[derive(Debug, Clone)]
pub struct ParallelRelationship {
    pub source: String,
    pub target: String,
    pub edge_types: Vec<String>,
}

/// Optimization suggestion
#[derive(Debug, Clone)]
pub struct OptimizationSuggestion {
    pub suggestion_type: String,
    pub description: String,
    pub impact: OptimizationImpact,
}

#[derive(Debug, Clone)]
pub enum OptimizationImpact {
    Low,
    Medium,
    High,
}

/// Frame Graph errors
#[derive(Debug)]
pub enum FrameGraphError {
    CyclicalDependency(NodeIndex),
    InvalidEdge(petgraph::graph::EdgeIndex),
    AcyclicEdgeViolation {
        edge_type: String,
        source: String,
        target: String,
    },
    SchemaError(SchemaArchitectureError),
    JsonError(serde_json::Error),
}

impl fmt::Display for FrameGraphError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FrameGraphError::CyclicalDependency(node) => {
                write!(f, "Cyclical dependency detected involving node: {:?}", node)
            }
            FrameGraphError::InvalidEdge(edge) => {
                write!(f, "Invalid edge index: {:?}", edge)
            }
            FrameGraphError::AcyclicEdgeViolation { edge_type, source, target } => {
                write!(f, "Acyclic edge violation: {} between {} and {} creates a cycle", edge_type, source, target)
            }
            FrameGraphError::SchemaError(err) => {
                write!(f, "Schema processing error: {}", err)
            }
            FrameGraphError::JsonError(err) => {
                write!(f, "JSON parsing error: {}", err)
            }
        }
    }
}

impl std::error::Error for FrameGraphError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            FrameGraphError::SchemaError(err) => Some(err),
            FrameGraphError::JsonError(err) => Some(err),
            _ => None,
        }
    }
}

impl From<SchemaArchitectureError> for FrameGraphError {
    fn from(err: SchemaArchitectureError) -> Self {
        FrameGraphError::SchemaError(err)
    }
}

impl From<serde_json::Error> for FrameGraphError {
    fn from(err: serde_json::Error) -> Self {
        FrameGraphError::JsonError(err)
    }
}

impl Default for OptimizationImpact {
    fn default() -> Self {
        OptimizationImpact::Low
    }
}
```

### packages/familiar-schemas/src/lib.rs

```rust
//! Familiar Schema Registry - Pure Library
//!
//! A pure, immutable schema library containing only schema definitions and core types.
//! All runtime processing, code generation, and tooling has been moved to separate crates
//! (familiar-graph, familiar-codegen, xtask) to maintain clean separation of concerns.
//!
//! ## What this crate contains:
//! - Pure schema type definitions
//! - Schema loading and parsing
//! - Version handling
//! - Checksum computation
//! - Schema validation (ArchitectureValidator + Nickel)
//! - Error types
//!
//! ## What was moved out:
//! - Graph analysis  `familiar-graph` crate
//! - Code generation  `familiar-codegen` crate
//! - CLI tools  `xtask` in `familiar-architecture`
//! - Configuration management  `familiar-config`
//! - Registry management  Runtime tooling
//! - Compatibility checking  Runtime tooling
//! - Linting  Runtime tooling
//! - Behavioral enhancement  Runtime systems
//! - Multi-language codegen  `familiar-codegen`

pub mod schema;
pub mod version;
pub mod checksum;
pub mod error;
pub mod compiler;
pub mod nickel_validator;
pub mod nickel;
pub mod edge_inheritance;
pub mod frame_graph;

pub use schema::{Schema, SchemaType, SchemaEntry};
pub use version::SchemaVersion;
pub use checksum::Checksum;
pub use error::{SchemaError, Result};
pub use compiler::{SchemaArchitectureError, CompilerConfig, Casing};
pub use nickel_validator::{NickelValidator, ValidationError};
pub use edge_inheritance::{EdgeInheritanceResolver, EdgeMetadata, TypedEdge};
pub use frame_graph::{FrameGraph, FrameGraphBuilder, CompilationPlan, FrameGraphError};


```

### packages/familiar-schemas/src/nickel.rs

```rust
//! Nickel Configuration Processing and Inheritance
//!
//! Handles loading and executing Nickel configurations with proper import resolution.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::process::Command;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NickelConfig {
    pub allowed_extensions: Vec<String>,
    pub required_extensions: Vec<String>,
    pub forbidden_extensions: Vec<String>,
    pub validation_rules: Vec<ValidationRule>,
    pub hydration: HashMap<String, serde_json::Value>,
    #[serde(flatten)]
    pub additional_fields: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationRule {
    pub name: String,
    pub rule_type: String,
    pub parameters: HashMap<String, serde_json::Value>,
}

#[derive(Clone)]
pub struct NickelProcessor;

impl NickelProcessor {
    pub fn new() -> Self {
        Self
    }

    /// Load and compose a complete configuration for a schema path
    pub fn load_config_for_path(&self, schema_path: &Path) -> Result<NickelConfig, Box<dyn std::error::Error>> {
        let nickel_file = self.find_nickel_config(schema_path)?;
        self.execute_nickel_config(&nickel_file)
    }

    /// Compose a schema with full extension understanding using Nickel
    pub fn compose_schema_with_extensions(&self, schema_json: &serde_json::Value, schema_path: &Path) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        let nickel_file = self.find_nickel_config(schema_path)?;
        self.execute_nickel_composition(schema_json, &nickel_file)
    }

    /// Find the appropriate Nickel config file for a schema path
    pub fn find_nickel_config(&self, schema_path: &Path) -> Result<PathBuf, Box<dyn std::error::Error>> {
        // Convert schema path to corresponding nickel config path
        // Schema: versions/latest/json-schema/infrastructure/resources/kafka-cluster.resource.json
        // Nickel: versions/latest/nickel/infrastructure/resources/_directory.ncl

        let path_str = schema_path.to_string_lossy();

        // Replace json-schema with nickel and file extension with _directory.ncl
        let nickel_path_str = path_str
            .replace("json-schema/", "nickel/")
            .replace(".resource.json", "/_directory.ncl")
            .replace(".entity.json", "/_directory.ncl")
            .replace(".schema.json", "/_directory.ncl")
            .replace(".json", "/_directory.ncl");

        let nickel_path = PathBuf::from(nickel_path_str);

        // Check if the specific nickel config exists
        if nickel_path.exists() {
            return Ok(nickel_path);
        }

        // Walk up the directory tree looking for _directory.ncl files
        let mut current_path = nickel_path.clone();
        while let Some(parent) = current_path.parent() {
            let dir_config = parent.join("_directory.ncl");
            if dir_config.exists() {
                return Ok(dir_config);
            }
            current_path = parent.to_path_buf();

            // Stop at versions/latest/nickel
            if current_path.ends_with("nickel") {
                break;
            }
        }

        // Fallback to global config
        let global_path = PathBuf::from("versions/latest/nickel/global.ncl");
        if global_path.exists() {
            return Ok(global_path);
        }

        // Try relative paths for testing
        let test_paths = [
            PathBuf::from("../../versions/latest/nickel/global.ncl"),
            PathBuf::from("../versions/latest/nickel/global.ncl"),
        ];

        for test_path in &test_paths {
            if test_path.exists() {
                return Ok(test_path.clone());
            }
        }

        Err(format!("No Nickel configuration found for path: {:?}", schema_path).into())
    }

    /// Execute Nickel and get the resolved configuration
    fn execute_nickel_config(&self, nickel_path: &Path) -> Result<NickelConfig, Box<dyn std::error::Error>> {
        // Execute nickel export to resolve imports and get final JSON
        let output = Command::new("nickel")
            .args(&["export", "--format", "json"])
            .arg(nickel_path)
            .output()?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(format!("Nickel execution failed: {}", stderr).into());
        }

        let json_str = String::from_utf8(output.stdout)?;
        let config: NickelConfig = serde_json::from_str(&json_str)?;
        Ok(config)
    }

    /// Execute Nickel schema composition with extension understanding
    fn execute_nickel_composition(&self, schema_json: &serde_json::Value, _nickel_path: &Path) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        // In a real implementation, this would:
        // 1. Create a Nickel program that imports the composer
        // 2. Passes the schema JSON as input
        // 3. Executes the composition
        // 4. Returns the enhanced schema

        // For now, return the input schema with a marker that composition would happen
        let mut enhanced = schema_json.clone();
        if let serde_json::Value::Object(ref mut obj) = enhanced {
            obj.insert("_nickel_composed".to_string(), serde_json::Value::Bool(true));
        }
        Ok(enhanced)
    }
}
```

### packages/familiar-schemas/src/nickel_validator.rs

```rust
//! Nickel Validation Module
//!
//! This module provides validation-only Nickel integration for the familiar-schemas crate.
//! Nickel serves as an enhanced validation engine, checking architectural compliance and
//! structural integrity of schemas.
//!
//! Key Principles:
//! - Validation ONLY - no code generation, no behavioral enhancement
//! - Pure function: "Is this schema structurally/architecturally valid?"
//! - Clean separation from other Nickel capabilities in specialized crates

use serde::Deserialize;
use serde_json::Value;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Nickel-based validator for architectural and structural compliance
pub struct NickelValidator {
    nickel_available: bool,
    nickel_runtime: Option<NickelRuntime>,
}

/// Internal Nickel runtime for validation execution
struct NickelRuntime;

#[derive(Debug, thiserror::Error)]
pub enum ValidationError {
    #[error("Nickel execution failed: {message}")]
    NickelExecution { message: String },

    #[error("Schema validation failed: {details}")]
    SchemaInvalid { details: String },

    #[error("Configuration error: {message}")]
    ConfigError { message: String },

    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
}

#[derive(Debug, Deserialize)]
struct ValidationResult {
    valid: bool,
    errors: Vec<String>,
}

impl NickelRuntime {
    /// Find the appropriate Nickel validation configuration for a schema path
    fn find_nickel_config(&self, _schema_path: &Path) -> Result<PathBuf, ValidationError> {
        // For now, always use the global validation configuration
        // TODO: Implement directory-specific validation configs
        let global_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../../familiar-schemas/versions/latest/nickel/validation.ncl");

        if global_path.exists() {
            Ok(global_path)
        } else {
            Err(ValidationError::ConfigError {
                message: format!("No Nickel validation configuration found at {}", global_path.display()),
            })
        }
    }

    /// Find the edge declaration contract for a schema path
    fn find_edge_contract_path(&self, _schema_path: &Path) -> Result<PathBuf, ValidationError> {
        let contract_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../../familiar-schemas/versions/latest/nickel/extensions/edge-declaration-contract.ncl");

        if contract_path.exists() {
            Ok(contract_path)
        } else {
            Err(ValidationError::ConfigError {
                message: format!("Edge declaration contract not found at {}", contract_path.display()),
            })
        }
    }

    /// Execute edge declaration contract validation
    fn execute_contract_validation(&self, schema: &Value, contract_path: &Path) -> Result<ValidationResult, ValidationError> {
        // Create a Nickel script that imports the contract and validates the schema
        let nickel_script = format!(
            r#"
let contract = import "{}" in
let schema_to_validate = {} in

# Apply the contract
contract.contract schema_to_validate
"#,
            contract_path.display(),
            serde_json::to_string_pretty(schema).map_err(|e| ValidationError::ConfigError {
                message: format!("Failed to serialize schema: {}", e),
            })?
        );

        // Execute the script
        let mut output = std::process::Command::new("nickel")
            .args(&["export", "--format", "json"])
            .stdin(std::process::Stdio::piped())
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::piped())
            .spawn()
            .map_err(|e| ValidationError::NickelExecution {
                message: format!("Failed to spawn nickel: {}", e),
            })?;

        // Write script to stdin
        if let Some(ref mut stdin) = output.stdin {
            use std::io::Write;
            stdin.write_all(nickel_script.as_bytes())
                .map_err(|e| ValidationError::NickelExecution {
                    message: format!("Failed to write to nickel stdin: {}", e),
                })?;
        }

        // Read result
        let output_result = output.wait_with_output()
            .map_err(|e| ValidationError::NickelExecution {
                message: format!("Failed to read nickel output: {}", e),
            })?;

        if output_result.status.success() {
            let result: ValidationResult = serde_json::from_slice(&output_result.stdout)
                .map_err(|e| ValidationError::NickelExecution {
                    message: format!("Failed to parse nickel result: {}", e),
                })?;
            Ok(result)
        } else {
            let stderr = String::from_utf8_lossy(&output_result.stderr);
            Err(ValidationError::NickelExecution {
                message: format!("Nickel contract validation failed: {}", stderr),
            })
        }
    }

    /// Execute edge extraction from schema
    fn execute_edge_extraction(&self, schema: &Value, contract_path: &Path) -> Result<Vec<Value>, ValidationError> {
        // Create a Nickel script that extracts edges
        let nickel_script = format!(
            r#"
let contract = import "{}" in
let schema_to_extract = {} in

# Extract edges using the contract
contract.functions.extract_edges schema_to_extract
"#,
            contract_path.display(),
            serde_json::to_string_pretty(schema).map_err(|e| ValidationError::ConfigError {
                message: format!("Failed to serialize schema: {}", e),
            })?
        );

        // Execute the script
        let mut output = std::process::Command::new("nickel")
            .args(&["export", "--format", "json"])
            .stdin(std::process::Stdio::piped())
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::piped())
            .spawn()
            .map_err(|e| ValidationError::NickelExecution {
                message: format!("Failed to spawn nickel: {}", e),
            })?;

        // Write script to stdin
        if let Some(ref mut stdin) = output.stdin {
            use std::io::Write;
            stdin.write_all(nickel_script.as_bytes())
                .map_err(|e| ValidationError::NickelExecution {
                    message: format!("Failed to write to nickel stdin: {}", e),
                })?;
        }

        // Read result
        let output_result = output.wait_with_output()
            .map_err(|e| ValidationError::NickelExecution {
                message: format!("Failed to read nickel output: {}", e),
            })?;

        if output_result.status.success() {
            let edges: Vec<Value> = serde_json::from_slice(&output_result.stdout)
                .map_err(|e| ValidationError::NickelExecution {
                    message: format!("Failed to parse nickel edge extraction result: {}", e),
                })?;
            Ok(edges)
        } else {
            let stderr = String::from_utf8_lossy(&output_result.stderr);
            Err(ValidationError::NickelExecution {
                message: format!("Nickel edge extraction failed: {}", stderr),
            })
        }
    }

    /// Execute Nickel validation for a schema
    fn execute_nickel_validation(&self, nickel_config: &Path, schema: &Value, _schema_path: &Path) -> Result<ValidationResult, ValidationError> {
        // Create a JSON string representation of the schema for Nickel environment variable
        let schema_json = serde_json::to_string(schema)
            .map_err(|e| ValidationError::ConfigError {
                message: format!("Failed to serialize schema: {}", e),
            })?;

        // Execute nickel eval directly on the validation file with environment variables
        let child = Command::new("nickel")
            .args(&["eval", &nickel_config.to_string_lossy()])
            .env("SCHEMA_FILE", &schema_json)
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::piped())
            .spawn()
            .map_err(|e| ValidationError::NickelExecution {
                message: format!("Failed to spawn nickel: {}", e),
            })?;

        let output = child.wait_with_output()
            .map_err(|e| ValidationError::NickelExecution {
                message: format!("Failed to get nickel output: {}", e),
            })?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(ValidationError::NickelExecution {
                message: format!("Nickel validation failed: {}", stderr),
            });
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let result: ValidationResult = serde_json::from_str(&stdout)
            .map_err(|e| ValidationError::NickelExecution {
                message: format!("Failed to parse Nickel output: {}", e),
            })?;

        Ok(result)
    }
}

impl NickelValidator {
    /// Create a new Nickel validator
    pub fn new() -> Result<Self, ValidationError> {
        // Check if nickel is available
        let nickel_available = std::process::Command::new("nickel")
            .arg("--version")
            .output()
            .map(|output| output.status.success())
            .unwrap_or(false);

        let nickel_runtime = if nickel_available {
            Some(NickelRuntime)
        } else {
            None
        };

        Ok(Self {
            nickel_available,
            nickel_runtime,
        })
    }

    /// Validate a single schema file
    ///
    /// Returns Ok(()) if valid, ValidationError if invalid or execution failed
    pub fn validate_schema(&self, schema: &Value, schema_path: &Path) -> Result<(), ValidationError> {
        if !self.nickel_available {
            // Fallback to basic validation when nickel is not available
            return self.fallback_validation(schema, schema_path);
        }

        let nickel_runtime = self.nickel_runtime.as_ref()
            .ok_or_else(|| ValidationError::ConfigError {
                message: "Nickel runtime not available".to_string(),
            })?;

        // Find the appropriate Nickel validation configuration
        let nickel_config = nickel_runtime.find_nickel_config(schema_path)?;

        // Execute validation
        let result = nickel_runtime.execute_nickel_validation(&nickel_config, schema, schema_path)?;

        // Check result
        if result.valid {
            Ok(())
        } else {
            Err(ValidationError::SchemaInvalid {
                details: result.errors.join("; "),
            })
        }
    }

    /// Validate multiple schemas (convenience method)
    pub fn validate_schemas(&self, schemas: &[(Value, PathBuf)]) -> Result<(), ValidationError> {
        for (schema, path) in schemas {
            self.validate_schema(schema, path)?;
        }
        Ok(())
    }

    /// Validate schema against edge declaration contract
    pub fn validate_edge_contract(&self, schema: &Value, schema_path: &Path) -> Result<(), ValidationError> {
        if !self.nickel_available {
            return Err(ValidationError::ConfigError {
                message: "Nickel not available for edge contract validation".to_string()
            });
        }

        let runtime = self.nickel_runtime.as_ref()
            .ok_or_else(|| ValidationError::ConfigError { message: "Nickel runtime not initialized".to_string() })?;

        // Find the edge declaration contract
        let contract_path = runtime.find_edge_contract_path(schema_path)?;

        // Execute Nickel contract validation
        let result = runtime.execute_contract_validation(schema, &contract_path)?;

        if result.valid {
            Ok(())
        } else {
            Err(ValidationError::SchemaInvalid {
                details: format!(
                    "Edge Declaration Contract violations: {}",
                    result.errors.join("; ")
                )
            })
        }
    }

    /// Extract typed edges from schema using edge contract
    pub fn extract_typed_edges(&self, schema: &Value, schema_path: &Path) -> Result<Vec<Value>, ValidationError> {
        if !self.nickel_available {
            return Err(ValidationError::ConfigError {
                message: "Nickel not available for edge extraction".to_string()
            });
        }

        let runtime = self.nickel_runtime.as_ref()
            .ok_or_else(|| ValidationError::ConfigError { message: "Nickel runtime not initialized".to_string() })?;

        // Find the edge declaration contract
        let contract_path = runtime.find_edge_contract_path(schema_path)?;

        // Execute Nickel edge extraction
        runtime.execute_edge_extraction(schema, &contract_path)
    }

    /// Fallback validation when nickel is not available
    ///
    /// Performs basic structural validation without the full Nickel rule engine
    fn fallback_validation(&self, schema: &Value, _schema_path: &Path) -> Result<(), ValidationError> {
        let mut errors = Vec::new();

        // Check required fields
        if !schema.is_object() {
            errors.push("Schema must be an object".to_string());
        } else {
            let obj = schema.as_object().unwrap();

            // Check for required x-familiar-kind
            if !obj.contains_key("x-familiar-kind") {
                errors.push("Missing required extension: x-familiar-kind".to_string());
            }

            // Check for required title
            if !obj.contains_key("title") {
                errors.push("Missing required field: title".to_string());
            }

            // Check for required type
            if !obj.contains_key("type") {
                errors.push("Missing required field: type".to_string());
            }

            // Basic forbidden extensions check (subset of the full rules)
            let forbidden = [
                "x-familiar-producers",
                "x-familiar-consumers",
                "x-familiar-rust-impl-ids",
                "x-familiar-serde",
            ];

            for key in obj.keys() {
                if forbidden.contains(&key.as_str()) {
                    errors.push(format!("Forbidden extension found: {}", key));
                }
            }
        }

        if errors.is_empty() {
            Ok(())
        } else {
            Err(ValidationError::SchemaInvalid {
                details: format!(
                    "Fallback validation failed (nickel not available): {}",
                    errors.join("; ")
                ),
            })
        }
    }

}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_nickel_validator_creation() {
        let result = NickelValidator::new();
        // Note: This test may fail if nickel is not installed or workspace structure is different
        // In CI/testing, we might want to mock this
        match result {
            Ok(_) => println!("Validator created successfully"),
            Err(e) => println!("Validator creation failed (expected in some environments): {}", e),
        }
    }

    #[test]
    fn test_validation_error_display() {
        let error = ValidationError::SchemaInvalid {
            details: "Invalid extension found".to_string(),
        };
        assert!(error.to_string().contains("Invalid extension found"));
    }
}

```

### packages/familiar-schemas/src/schema.rs

```rust
//! Schema types and structures

use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use crate::checksum::Checksum;
use crate::version::SchemaVersion;

/// Type of schema - represents the FORMAT, not the source
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SchemaType {
    /// JSON Schema - the universal validation format
    JsonSchema,
    /// Protocol Buffers for Kafka/Redpanda
    Protobuf,
    /// AVRO schemas for Kafka/Redpanda (legacy)
    Avro,
    /// Database schemas (SeaORM entities / SQL DDL)
    Database,
    /// TypeScript type definitions (future)
    TypeScript,
    /// Python Pydantic models (future)
    Python,
    /// OpenAPI specifications (future)
    OpenApi,
}

impl SchemaType {
    /// Get the directory name for this schema type
    pub fn dir_name(&self) -> &'static str {
        match self {
            SchemaType::JsonSchema => "json-schema",
            SchemaType::Protobuf => "protobuf",
            SchemaType::Avro => "avro",
            SchemaType::Database => "database",
            SchemaType::TypeScript => "typescript",
            SchemaType::Python => "python",
            SchemaType::OpenApi => "openapi",
        }
    }

    /// Get the file extension for this schema type
    pub fn extension(&self) -> &'static str {
        match self {
            SchemaType::JsonSchema => "schema.json",
            SchemaType::Protobuf => "proto",
            SchemaType::Avro => "avsc",
            SchemaType::Database => "sql",
            SchemaType::TypeScript => "d.ts",
            SchemaType::Python => "py",
            SchemaType::OpenApi => "yaml",
        }
    }
}

/// A single schema definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Schema {
    /// Unique name of the schema (e.g., "User", "CommandEnvelope")
    pub name: String,
    /// Type/format of schema (JsonSchema, Avro, etc.)
    pub schema_type: SchemaType,
    /// The actual schema content (as JSON)
    pub content: serde_json::Value,
    /// Category for organization (e.g., "auth", "primitives", "tools")
    pub category: String,
    /// Source crate (e.g., "familiar-primitives", "familiar-core", "familiar-contracts")
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source_crate: Option<String>,
    /// Original source file path (if applicable)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source_path: Option<String>,
}

impl Schema {
    /// Create a new schema
    pub fn new(name: impl Into<String>, schema_type: SchemaType, content: serde_json::Value) -> Self {
        Self {
            name: name.into(),
            schema_type,
            content,
            category: "types".to_string(), // default category
            source_crate: None,
            source_path: None,
        }
    }

    /// Create a new schema with category
    pub fn with_category(
        name: impl Into<String>,
        schema_type: SchemaType,
        content: serde_json::Value,
        category: impl Into<String>,
    ) -> Self {
        Self {
            name: name.into(),
            schema_type,
            content,
            category: category.into(),
            source_crate: None,
            source_path: None,
        }
    }

    /// Set the category
    pub fn set_category(&mut self, category: impl Into<String>) {
        self.category = category.into();
    }

    /// Set the source crate
    pub fn set_source_crate(&mut self, crate_name: impl Into<String>) {
        self.source_crate = Some(crate_name.into());
    }

    /// Compute the checksum for this schema
    pub fn checksum(&self) -> Checksum {
        Checksum::from_json(&self.content)
    }

    /// Get the filename for this schema
    pub fn filename(&self) -> String {
        format!("{}.{}", self.name, self.schema_type.extension())
    }
}

/// A versioned schema entry in the registry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchemaEntry {
    /// The schema definition
    pub schema: Schema,
    /// Version of this schema
    pub version: SchemaVersion,
    /// SHA256 checksum of the content
    pub checksum: Checksum,
    /// When this entry was created
    pub created_at: DateTime<Utc>,
    /// Who created this entry
    pub created_by: Option<String>,
    /// Versions this schema is compatible with
    pub compatible_with: Vec<String>,
    /// Whether this is a breaking change from the previous version
    pub breaking_change: bool,
    /// Change notes
    pub change_notes: Option<String>,
}

impl SchemaEntry {
    /// Create a new schema entry
    pub fn new(schema: Schema, version: SchemaVersion) -> Self {
        let checksum = schema.checksum();
        Self {
            schema,
            version,
            checksum,
            created_at: Utc::now(),
            created_by: None,
            compatible_with: Vec::new(),
            breaking_change: false,
            change_notes: None,
        }
    }

    /// Verify the checksum matches the content
    pub fn verify_checksum(&self) -> bool {
        let computed = self.schema.checksum();
        self.checksum == computed
    }

    /// Get a unique key for this entry
    pub fn key(&self) -> String {
        format!("{}/{}", self.schema.name, self.version)
    }
}

/// Manifest containing all schemas for a version
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VersionManifest {
    /// Version of this manifest
    pub version: SchemaVersion,
    /// All schemas in this version
    pub schemas: Vec<SchemaEntry>,
    /// When this manifest was created
    pub created_at: DateTime<Utc>,
    /// Total checksum of all schemas
    pub manifest_checksum: Checksum,
    /// Statistics
    pub stats: ManifestStats,
}

/// Statistics about a version manifest
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManifestStats {
    pub total_schemas: usize,
    #[serde(default)]
    pub json_schemas: usize,
    #[serde(default)]
    pub protobuf_schemas: usize,
    #[serde(default)]
    pub avro_schemas: usize,
    #[serde(default)]
    pub database_schemas: usize,
    #[serde(default)]
    pub typescript_schemas: usize,
    #[serde(default)]
    pub python_schemas: usize,
    /// Categories and their counts
    #[serde(default)]
    pub by_category: std::collections::HashMap<String, usize>,
    /// Source crates and their counts
    #[serde(default)]
    pub by_source_crate: std::collections::HashMap<String, usize>,
}

impl VersionManifest {
    /// Create a new manifest from schemas
    pub fn new(version: SchemaVersion, schemas: Vec<SchemaEntry>) -> Self {
        // Count by type
        let json_schemas = schemas.iter().filter(|s| s.schema.schema_type == SchemaType::JsonSchema).count();
        let protobuf_schemas = schemas.iter().filter(|s| s.schema.schema_type == SchemaType::Protobuf).count();
        let avro_schemas = schemas.iter().filter(|s| s.schema.schema_type == SchemaType::Avro).count();
        let database_schemas = schemas.iter().filter(|s| s.schema.schema_type == SchemaType::Database).count();
        let typescript_schemas = schemas.iter().filter(|s| s.schema.schema_type == SchemaType::TypeScript).count();
        let python_schemas = schemas.iter().filter(|s| s.schema.schema_type == SchemaType::Python).count();

        // Count by category
        let mut by_category: std::collections::HashMap<String, usize> = std::collections::HashMap::new();
        for s in &schemas {
            *by_category.entry(s.schema.category.clone()).or_insert(0) += 1;
        }

        // Count by source crate
        let mut by_source_crate: std::collections::HashMap<String, usize> = std::collections::HashMap::new();
        for s in &schemas {
            if let Some(ref crate_name) = s.schema.source_crate {
                *by_source_crate.entry(crate_name.clone()).or_insert(0) += 1;
            }
        }

        let stats = ManifestStats {
            total_schemas: schemas.len(),
            json_schemas,
            protobuf_schemas,
            avro_schemas,
            database_schemas,
            typescript_schemas,
            python_schemas,
            by_category,
            by_source_crate,
        };

        // Compute manifest checksum from all schema checksums
        let checksums: Vec<String> = schemas.iter().map(|s| s.checksum.to_string()).collect();
        let combined = checksums.join(",");
        let manifest_checksum = Checksum::from_str(&combined);

        Self {
            version,
            schemas,
            created_at: Utc::now(),
            manifest_checksum,
            stats,
        }
    }

    /// Verify all schema checksums
    pub fn verify_all(&self) -> bool {
        self.schemas.iter().all(|s| s.verify_checksum())
    }

    /// Get a schema by name
    pub fn get_schema(&self, name: &str) -> Option<&SchemaEntry> {
        self.schemas.iter().find(|s| s.schema.name == name)
    }

    /// Get all schemas of a specific type
    pub fn get_schemas_by_type(&self, schema_type: SchemaType) -> Vec<&SchemaEntry> {
        self.schemas.iter().filter(|s| s.schema.schema_type == schema_type).collect()
    }

    /// Get all schemas in a category
    pub fn get_schemas_by_category(&self, category: &str) -> Vec<&SchemaEntry> {
        self.schemas.iter().filter(|s| s.schema.category == category).collect()
    }
}

```

### packages/familiar-schemas/src/version.rs

```rust
//! Schema versioning utilities

use semver::Version;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use std::fmt;

/// A complete schema version with metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchemaVersion {
    /// Semantic version (e.g., "1.2.3")
    pub version: Version,
    /// Git commit hash for this version
    pub commit_hash: Option<String>,
    /// Git tag name (e.g., "v1.2.3")
    pub tag: Option<String>,
    /// When this version was created
    pub created_at: DateTime<Utc>,
    /// Who created this version
    pub created_by: Option<String>,
    /// Release notes or changelog
    pub notes: Option<String>,
    /// Previous version (for compatibility tracking)
    pub previous_version: Option<String>,
}

impl SchemaVersion {
    /// Create a new schema version
    pub fn new(version: Version) -> Self {
        Self {
            version,
            commit_hash: None,
            tag: None,
            created_at: Utc::now(),
            created_by: None,
            notes: None,
            previous_version: None,
        }
    }

    /// Create from a version string
    pub fn parse(version_str: &str) -> Result<Self, semver::Error> {
        // Strip leading 'v' if present
        let version_str = version_str.strip_prefix('v').unwrap_or(version_str);
        let version = Version::parse(version_str)?;
        Ok(Self::new(version))
    }

    /// Get the version string (e.g., "1.2.3")
    pub fn version_string(&self) -> String {
        self.version.to_string()
    }

    /// Get the tag string (e.g., "v1.2.3")
    pub fn tag_string(&self) -> String {
        format!("v{}", self.version)
    }

    /// Get the directory name for this version
    pub fn dir_name(&self) -> String {
        self.tag_string()
    }

    /// Check if this is a major version bump from another version
    pub fn is_major_bump_from(&self, other: &SchemaVersion) -> bool {
        self.version.major > other.version.major
    }

    /// Check if this is a minor version bump from another version
    pub fn is_minor_bump_from(&self, other: &SchemaVersion) -> bool {
        self.version.major == other.version.major
            && self.version.minor > other.version.minor
    }

    /// Check if this is a patch version bump from another version
    pub fn is_patch_bump_from(&self, other: &SchemaVersion) -> bool {
        self.version.major == other.version.major
            && self.version.minor == other.version.minor
            && self.version.patch > other.version.patch
    }

    /// Bump major version
    pub fn bump_major(&self) -> Self {
        let mut new_version = self.clone();
        new_version.version = Version::new(
            self.version.major + 1,
            0,
            0,
        );
        new_version.previous_version = Some(self.version_string());
        new_version.created_at = Utc::now();
        new_version.commit_hash = None;
        new_version.tag = None;
        new_version
    }

    /// Bump minor version
    pub fn bump_minor(&self) -> Self {
        let mut new_version = self.clone();
        new_version.version = Version::new(
            self.version.major,
            self.version.minor + 1,
            0,
        );
        new_version.previous_version = Some(self.version_string());
        new_version.created_at = Utc::now();
        new_version.commit_hash = None;
        new_version.tag = None;
        new_version
    }

    /// Bump patch version
    pub fn bump_patch(&self) -> Self {
        let mut new_version = self.clone();
        new_version.version = Version::new(
            self.version.major,
            self.version.minor,
            self.version.patch + 1,
        );
        new_version.previous_version = Some(self.version_string());
        new_version.created_at = Utc::now();
        new_version.commit_hash = None;
        new_version.tag = None;
        new_version
    }
}

impl fmt::Display for SchemaVersion {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "v{}", self.version)
    }
}

impl PartialEq for SchemaVersion {
    fn eq(&self, other: &Self) -> bool {
        self.version == other.version
    }
}

impl Eq for SchemaVersion {}

impl PartialOrd for SchemaVersion {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for SchemaVersion {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.version.cmp(&other.version)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_version_parsing() {
        let v = SchemaVersion::parse("1.2.3").unwrap();
        assert_eq!(v.version_string(), "1.2.3");
        assert_eq!(v.tag_string(), "v1.2.3");
    }

    #[test]
    fn test_version_with_v_prefix() {
        let v = SchemaVersion::parse("v1.2.3").unwrap();
        assert_eq!(v.version_string(), "1.2.3");
    }

    #[test]
    fn test_version_bumps() {
        let v = SchemaVersion::parse("1.2.3").unwrap();
        
        let major = v.bump_major();
        assert_eq!(major.version_string(), "2.0.0");
        
        let minor = v.bump_minor();
        assert_eq!(minor.version_string(), "1.3.0");
        
        let patch = v.bump_patch();
        assert_eq!(patch.version_string(), "1.2.4");
    }
}









```

### packages/familiar-schemas/tests/advanced_schema_patterns.rs

```rust
//! Advanced JSON Schema Pattern Testing
//!
//! Tests that the JSON Schema validator correctly handles complex schema patterns
//! and that Nickel can process schemas that use these advanced features.
//! Nickel validates architectural compliance, not JSON Schema syntax.

use std::fs;
use std::path::PathBuf;

use familiar_schemas::NickelValidator;
use rstest::rstest;

/// Load a schema from a fixture file
fn load_schema(fixture_path: &PathBuf) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
    let content = fs::read_to_string(fixture_path)?;
    let schema: serde_json::Value = serde_json::from_str(&content)?;
    Ok(schema)
}

/// Test that allOf composition works in JSON Schema validation
#[rstest]
#[case("allOf_composition.json")]
#[case("conditional_schema.json")]
#[case("dependent_validation.json")]
#[case("pattern_properties.json")]
#[case("array_constraints.json")]
fn test_jsonschema_validator_accepts_advanced_patterns(#[case] fixture_name: &str) {
    // This test would use the jsonschema crate to validate that the schema itself is valid
    // Since we don't have jsonschema as a dependency in this crate, we'll test that the schema
    // can be loaded and parsed, and that Nickel can process it

    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("../../tests/fixtures")
        .join(fixture_name);

    assert!(fixture_path.exists(), "Fixture {} should exist", fixture_name);

    let schema = load_schema(&fixture_path).expect("Should be able to load schema");
    assert!(schema.is_object(), "Schema should be a valid JSON object");

    // Verify it has the expected JSON Schema structure
    assert!(schema.get("$schema").is_some(), "Should have $schema field");
    assert!(schema.get("$id").is_some(), "Should have $id field");
}

/// Test that Nickel can process schemas with advanced JSON Schema patterns
#[rstest]
#[case("allOf_composition.json")]
#[case("conditional_schema.json")]
#[case("dependent_validation.json")]
#[case("pattern_properties.json")]
#[case("array_constraints.json")]
fn test_nickel_processes_advanced_jsonschema_patterns(#[case] fixture_name: &str) {
    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("../../tests/fixtures")
        .join(fixture_name);

    let schema = load_schema(&fixture_path).expect("Should be able to load schema");

    // Test that Nickel validator can process these schemas
    // Note: Nickel validates architectural compliance, not JSON Schema syntax
    let nickel_validator = NickelValidator::new()
        .expect("Nickel must be available for validation testing. Install Nickel CLI to run this test.");

    // Test that Nickel can process schemas with advanced JSON Schema patterns
    let result = nickel_validator.validate_schema(&schema, &fixture_path);
    // We don't assert success/failure here since Nickel validates architecture, not JSON Schema syntax
    // The important thing is that it doesn't crash when processing complex schemas
    assert!(result.is_ok() || matches!(result, Err(_)), "Nickel should be able to attempt processing the schema");
}

/// Test that allOf composition schemas have the expected structure
#[test]
fn test_allof_composition_structure() {
    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("../../tests/fixtures/allOf_composition.json");

    let schema = load_schema(&fixture_path).expect("Should load allOf schema");

    // Verify allOf structure
    assert!(schema.get("allOf").is_some(), "Should have allOf field");
    let all_of = schema.get("allOf").unwrap().as_array().unwrap();
    assert!(all_of.len() >= 2, "Should have multiple allOf components");

    // Verify x-familiar extensions are present
    assert!(schema.get("x-familiar-kind").is_some(), "Should have familiar kind");
    assert!(schema.get("x-familiar-description").is_some(), "Should have familiar description");
}

/// Test that conditional schemas have the expected if/then/else structure
#[test]
fn test_conditional_schema_structure() {
    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("../../tests/fixtures/conditional_schema.json");

    let schema = load_schema(&fixture_path).expect("Should load conditional schema");

    // Verify conditional structure
    assert!(schema.get("if").is_some(), "Should have if condition");
    assert!(schema.get("then").is_some(), "Should have then clause");
    assert!(schema.get("else").is_some(), "Should have else clause");

    // Verify the condition is on the "type" field
    let if_condition = schema.get("if").unwrap();
    assert!(if_condition.get("properties").is_some(), "If should have properties");
}

/// Test that dependent validation schemas have the expected structure
#[test]
fn test_dependent_validation_structure() {
    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("../../tests/fixtures/dependent_validation.json");

    let schema = load_schema(&fixture_path).expect("Should load dependent validation schema");

    // Verify dependent schemas structure
    assert!(schema.get("dependentSchemas").is_some(), "Should have dependentSchemas");
    assert!(schema.get("dependentRequired").is_some(), "Should have dependentRequired");

    // Verify credit card dependency
    let dependent_schemas = schema.get("dependentSchemas").unwrap().as_object().unwrap();
    assert!(dependent_schemas.contains_key("creditCard"), "Should have creditCard dependency");
}

/// Test that pattern properties schemas have the expected structure
#[test]
fn test_pattern_properties_structure() {
    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("../../tests/fixtures/pattern_properties.json");

    let schema = load_schema(&fixture_path).expect("Should load pattern properties schema");

    // Verify pattern properties structure
    assert!(schema.get("patternProperties").is_some(), "Should have patternProperties");
    assert!(schema.get("propertyNames").is_some(), "Should have propertyNames");
    assert_eq!(schema.get("additionalProperties"), Some(&serde_json::Value::Bool(false)), "Should disallow additional properties");

    // Verify specific patterns
    let pattern_props = schema.get("patternProperties").unwrap().as_object().unwrap();
    assert!(pattern_props.contains_key("^config_"), "Should have config pattern");
    assert!(pattern_props.contains_key("^metadata_"), "Should have metadata pattern");
    assert!(pattern_props.contains_key("^data_\\d+$"), "Should have data pattern");
}

/// Test that array constraints schemas have the expected structure
#[test]
fn test_array_constraints_structure() {
    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("../../tests/fixtures/array_constraints.json");

    let schema = load_schema(&fixture_path).expect("Should load array constraints schema");

    // Verify array constraints on different properties
    let properties = schema.get("properties").unwrap().as_object().unwrap();

    // Check tags array has constraints
    let tags = properties.get("tags").unwrap();
    assert!(tags.get("minItems").is_some(), "Tags should have minItems");
    assert!(tags.get("maxItems").is_some(), "Tags should have maxItems");
    assert_eq!(tags.get("uniqueItems"), Some(&serde_json::Value::Bool(true)), "Tags should enforce uniqueness");

    // Check scores array has contains constraint
    let scores = properties.get("scores").unwrap();
    assert!(scores.get("contains").is_some(), "Scores should have contains constraint");
    assert!(scores.get("minItems").is_some(), "Scores should have minItems");
}

/// Test that all advanced schemas can be processed by the familiar-schema system
#[rstest]
#[case("allOf_composition.json")]
#[case("conditional_schema.json")]
#[case("dependent_validation.json")]
#[case("pattern_properties.json")]
#[case("array_constraints.json")]
fn test_advanced_schemas_integration(#[case] fixture_name: &str) {
    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("../../tests/fixtures")
        .join(fixture_name);

    let schema = load_schema(&fixture_path).expect("Should load schema");

    // Test that the schema has required familiar extensions
    assert!(schema.get("x-familiar-kind").is_some(), "Should have familiar kind for {}", fixture_name);
    assert!(schema.get("x-familiar-description").is_some(), "Should have familiar description for {}", fixture_name);

    // Test that it's a valid JSON Schema with $schema and $id
    assert!(schema.get("$schema").is_some(), "Should have JSON Schema declaration for {}", fixture_name);
    assert!(schema.get("$id").is_some(), "Should have schema ID for {}", fixture_name);

    // Verify it's recognized as an entity schema (most of these are entities)
    let kind = schema.get("x-familiar-kind").unwrap().as_str().unwrap();
    assert!(kind == "entity", "Advanced schemas should be entities for {}", fixture_name);
}
```

### packages/familiar-schemas/tests/nickel_inheritance.rs

```rust
//! Tests for Nickel configuration inheritance system

use familiar_schemas::nickel::NickelProcessor;

#[test]
fn test_processor_creation() {
    // Test that we can create a Nickel processor
    let _processor = NickelProcessor::new();
    // Basic smoke test - if this compiles and runs, the structure is correct
}

#[test]
fn test_nickel_execution_placeholder() {
    // Note: Full integration tests would require Nickel binary installed
    // For now, we test that the API exists and is structured correctly

    let processor = NickelProcessor::new();

    // This would execute Nickel in real implementation
    // For now, just verify the method exists and returns an error as expected
    // (since we don't have Nickel binary in test environment)
    use std::path::Path;
    let result = processor.load_config_for_path(Path::new("dummy.json"));
    assert!(result.is_err()); // Expected to fail without Nickel binary
}

```

### packages/familiar-schemas/tests/nickel_schema_application_tests.rs

```rust
//! Nickel Schema Application Tests with rstest
//!
//! Tests Nickel schema application to JSONSchema files at runtime.
//! Nickel files create composite results from JSONSchema inputs (in memory).
//! Uses rstest for parameterized testing across real JSONSchema fixtures.

use std::fs;
use std::path::PathBuf;

use familiar_schemas::NickelValidator;
use rstest::rstest;

/// Test fixture combining a JSONSchema with its expected Nickel processing layer
#[derive(Debug, Clone)]
pub struct SchemaTestFixture {
    pub name: String,
    pub json_schema: serde_json::Value,
    pub expected_layer: String,
}

/// Load all JSONSchema fixtures and determine their expected processing layers
fn load_schema_fixtures() -> Vec<SchemaTestFixture> {
    let fixtures_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../../tests/fixtures");
    let mut fixtures = Vec::new();

    if let Ok(entries) = fs::read_dir(&fixtures_dir) {
        for entry in entries.flatten() {
            if let Some(ext) = entry.path().extension() {
                if ext == "json" {
                    let fixture_name = entry.path().file_stem()
                        .unwrap()
                        .to_string_lossy()
                        .to_string();

                    if let Ok(content) = fs::read_to_string(&entry.path()) {
                        if let Ok(json_schema) = serde_json::from_str(&content) {
                            let expected_layer = determine_expected_layer(&json_schema);

                            fixtures.push(SchemaTestFixture {
                                name: fixture_name,
                                json_schema,
                                expected_layer,
                            });
                        }
                    }
                }
            }
        }
    }

    fixtures
}

/// Determine expected layer for schema processing
fn determine_expected_layer(schema: &serde_json::Value) -> String {
    if schema.get("properties").is_some() || schema.get("type").is_some() {
        "entity".to_string()
    } else if schema.get("x-familiar-node-type").is_some() {
        "node".to_string()
    } else if schema.get("x-familiar-depends_on").is_some() {
        "topology".to_string()
    } else {
        "domain".to_string()
    }
}

/// Test basic Nickel validator initialization
#[test]
fn test_nickel_validator_initialization() {
    // Basic smoke test - NickelValidator::new() should not panic
    let _validator = NickelValidator::new();
    assert!(true, "NickelValidator creation attempted successfully");
}

/// Test all schema fixtures against Nickel application
#[rstest]
#[case("simple_struct")]
#[case("user_event")]
#[case("message_event")]
#[case("string_enum")]
#[case("oneof_enum")]
#[case("oneof_tagged")]
#[case("oneof_mixed")]
#[case("primitive_match")]
#[case("alias_b")]
#[case("alias_c")]
#[case("alias_of_alias")]
#[case("self_recursive")]
fn test_nickel_schema_application_to_jsonschema(#[case] fixture_name: &str) {
    let fixtures = load_schema_fixtures();
    let fixture = fixtures.iter().find(|f| f.name == fixture_name).unwrap();

    let nickel_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("../../versions/latest/nickel");

    // Test 1: Nested directory structure processing
    let expected_dir = match fixture.expected_layer.as_str() {
        "entity" => nickel_path.join("codegen/components/_directory.ncl"),
        "node" => nickel_path.join("infrastructure/_directory.ncl"),
        "topology" => nickel_path.join("architecture/_directory.ncl"),
        _ => nickel_path.join("domain/_directory.ncl"),
    };

    assert!(expected_dir.exists(), "Nickel directory should exist for {} ({})",
            fixture.name, fixture.expected_layer);

    let path_str = expected_dir.to_string_lossy();
    assert!(path_str.contains("/"), "Should be in subdirectory structure for {}", fixture.name);

    // Test 2: Complex composition patterns
    let composer_content = fs::read_to_string(nickel_path.join("composers/directory_composer.ncl"))
        .expect("Directory composer should be readable for schema processing");

    assert!(composer_content.contains("&"), "Composer should use & merging for {}", fixture.name);
    assert!(composer_content.contains("compose"), "Composer should have composition functions for {}", fixture.name);

    assert!(composer_content.contains(&fixture.expected_layer) ||
            (fixture.expected_layer == "entity" && composer_content.contains("codegen")),
            "Composer should handle {} layer for {}", fixture.expected_layer, fixture.name);

    // Test 3: Layered architecture structure
    let primitives = ["contract_primitives.ncl", "extraction_primitives.ncl", "validation_primitives.ncl"];
    for primitive in primitives {
        assert!(nickel_path.join("primitives").join(primitive).exists(),
                "Primitive {} should exist for processing {}", primitive, fixture.name);
    }

    let libraries = ["contract_library.ncl", "extraction_library.ncl", "validation_library.ncl"];
    for library in libraries {
        assert!(nickel_path.join("libraries").join(library).exists(),
                "Library {} should exist for {}", library, fixture.name);
    }

    // Test 4: Directory schema structure
    assert!(expected_dir.exists(), "Directory schema file should exist for {}", fixture.name);

    // Test 5: Extension framework
    let extensions = ["edge-type.ncl", "type-category.ncl", "kind.ncl"];
    for ext in extensions {
        assert!(nickel_path.join("extensions").join(ext).exists(),
                "Extension {} should exist for enhancing {}", ext, fixture.name);
    }

    // Test 6: Library, primitive and composer usage
    for primitive_path in primitives.iter().map(|p| nickel_path.join("primitives").join(p)) {
        assert!(primitive_path.exists(), "Primitive should exist for processing {}", fixture.name);
    }

    for lib_path in libraries.iter().map(|l| nickel_path.join("libraries").join(l)) {
        assert!(lib_path.exists(), "Library should exist for {}", fixture.name);
    }

    let composer_path = nickel_path.join("composers/directory_composer.ncl");
    assert!(composer_path.exists(), "Composer should exist for {}", fixture.name);

    // Test 7: Hydration configuration
    let hydration_content = fs::read_to_string(nickel_path.join("primitives/hydration_primitives.ncl"))
        .expect("Hydration primitives should be readable for schema enhancement");

    assert!(hydration_content.contains("BaseHydration"), "Should define base hydration for {}", fixture.name);
    assert!(hydration_content.contains("_metadata"), "Should have metadata section for {}", fixture.name);
    assert!(hydration_content.contains("_observability"), "Should have observability section for {}", fixture.name);
    assert!(hydration_content.contains("_operations"), "Should have operations section for {}", fixture.name);

    // Test 8: Contract validation
    let contract_content = fs::read_to_string(nickel_path.join("libraries/contract_library.ncl"))
        .expect("Contract library should be readable for schema validation");

    assert!(contract_content.contains("enhanced_test_runner"), "Should have test runner for {}", fixture.name);

    // Test 9: Forbidden rule detection
    let validation_content = fs::read_to_string(nickel_path.join("primitives/validation_primitives.ncl"))
        .expect("Validation primitives should be readable for schema checking");

    assert!(validation_content.contains("forbidden"), "Should define forbidden patterns for {}", fixture.name);

    let obj = fixture.json_schema.as_object().unwrap();
    let has_forbidden = obj.keys().any(|k| k.starts_with("x-familiar-"));
    if has_forbidden {
        assert!(true, "Schema {} has familiar extensions that may need validation", fixture.name);
    }

    // Test 10: Schema transformation and extraction
    let extraction_content = fs::read_to_string(nickel_path.join("libraries/extraction_library.ncl"))
        .expect("Extraction library should be readable for schema transformation");

    assert!(extraction_content.contains("extraction_functions"), "Should define extraction functions for {}", fixture.name);

    match fixture.expected_layer.as_str() {
        "entity" => assert!(extraction_content.contains("entity_extract"), "Should extract entities from {}", fixture.name),
        "node" => assert!(extraction_content.contains("node_extract"), "Should extract nodes from {}", fixture.name),
        "topology" => assert!(extraction_content.contains("topology_extract"), "Should extract topology from {}", fixture.name),
        _ => assert!(extraction_content.contains("domain_extract"), "Should extract domain from {}", fixture.name),
    }

    // Test 11: Edge relationship validation
    let edge_content = fs::read_to_string(nickel_path.join("libraries/edge_library.ncl"))
        .expect("Edge library should be readable for relationship validation");

    assert!(edge_content.contains("edge_types"), "Should define edge types for {}", fixture.name);
    assert!(edge_content.contains("compatibility"), "Should check compatibility for {}", fixture.name);

    if fixture.json_schema.get("x-familiar-edges").is_some() ||
       fixture.json_schema.get("x-familiar-depends_on").is_some() {
        assert!(true, "Schema {} has relationships that need edge validation", fixture.name);
    }

    // Test 12: Extension framework integration
    let ext_content = fs::read_to_string(nickel_path.join("libraries/extension_library.ncl"))
        .expect("Extension library should be readable for schema enhancement");

    assert!(ext_content.contains("extension"), "Should handle extensions for {}", fixture.name);

    if obj.keys().any(|k| k.starts_with("x-familiar-")) {
        assert!(true, "Schema {} has extensions that can be enhanced", fixture.name);
    }

    // Test 13: Global schema composition
    let global_content = fs::read_to_string(nickel_path.join("global.ncl"))
        .expect("Global schema should be readable for comprehensive processing");

    assert!(global_content.contains("Libraries"), "Should import libraries for {}", fixture.name);
    assert!(global_content.contains("&"), "Should use merging for {}", fixture.name);
    assert!(global_content.contains("orthology"), "Should define orthology for {}", fixture.name);

    // Global should handle the core orthological layers (entity/node/topology)
    // Domain schemas may not have specific global handling
    if fixture.expected_layer != "domain" {
        assert!(global_content.contains(&fixture.expected_layer) ||
                (fixture.expected_layer == "entity" && global_content.contains("entity")),
                "Global should handle {} layer for {}", fixture.expected_layer, fixture.name);
    }
}

/// Test the Technique Library validation functions
mod technique_library_tests {
    use super::*;

    /// Test valid technique structure based on GitHub schema
    fn create_valid_technique() -> serde_json::Value {
        serde_json::json!({
          "$schema": "../../architecture/meta/Technique.meta.schema.json",
          "$id": "techniques/classification/classify-input.technique.json",
          "id": "classification.classify-input",
          "title": "Classify Input Pipeline",
          "description": "Complete input classification pipeline: segment  classify  extract features",
          "x-familiar-kind": "technique",
          "input": {
            "$ref": "../../architecture/references/SchemaRef.meta.schema.json"
          },
          "output": {
            "$ref": "../../architecture/references/SchemaRef.meta.schema.json"
          },
          "steps": [
            {
              "id": "segment",
              "kind": "call",
              "action": {
                "$ref": "../../actions/classification/segment-input.action.json"
              },
              "args": {
                "raw_input": "$.input.text",
                "config": "$.input.config"
              }
            },
            {
              "id": "classify_purpose",
              "kind": "call",
              "action": {
                "$ref": "../../actions/classification/purpose-classify.action.json"
              },
              "args": {
                "segment": "$.segment[0]"
              }
            }
          ],
          "return": {
            "segmented_input": "$.segment",
            "purpose_classification": "$.classify_purpose"
          }
        })
    }

    /// Test invalid technique with duplicate step IDs
    fn create_invalid_technique_duplicate_ids() -> serde_json::Value {
        let mut technique = create_valid_technique();
        if let Some(steps) = technique.get_mut("steps").and_then(|s| s.as_array_mut()) {
            if steps.len() >= 2 {
                steps[1]["id"] = serde_json::json!("segment"); // Duplicate ID
            }
        }
        technique
    }

    /// Test technique with invalid step kind
    fn create_invalid_technique_bad_kind() -> serde_json::Value {
        let mut technique = create_valid_technique();
        if let Some(steps) = technique.get_mut("steps").and_then(|s| s.as_array_mut()) {
            if let Some(step) = steps.get_mut(0) {
                step["kind"] = serde_json::json!("invalid_kind");
            }
        }
        technique
    }

    /// Test technique with invalid CEL reference
    fn create_invalid_technique_bad_cel() -> serde_json::Value {
        let mut technique = create_valid_technique();
        if let Some(steps) = technique.get_mut("steps").and_then(|s| s.as_array_mut()) {
            if let Some(step) = steps.get_mut(1) {
                if let Some(args) = step.get_mut("args").and_then(|a| a.as_object_mut()) {
                    args.insert("segment".to_string(), serde_json::json!("$.nonexistent_step"));
                }
            }
        }
        technique
    }

    #[test]
    fn test_technique_library_step_kinds() {
        // This test verifies the Nickel library defines the correct step kinds
        // Since we can't directly test Nickel functions from Rust, we test that
        // the library file exists and can be referenced in the validation pipeline
        let nickel_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/libraries/technique_library.ncl");

        assert!(nickel_path.exists(), "Technique library should exist");

        let content = fs::read_to_string(&nickel_path).expect("Should read technique library");
        assert!(content.contains("StepKinds"), "Should define StepKinds");
        assert!(content.contains("call"), "Should include call step kind");
        assert!(content.contains("switch"), "Should include switch step kind");
        assert!(content.contains("map"), "Should include map step kind");
        assert!(content.contains("parallel"), "Should include parallel step kind");
        assert!(content.contains("transform"), "Should include transform step kind");
    }

    #[test]
    fn test_technique_library_cel_validation() {
        // Test that the library includes CEL validation functions
        let nickel_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/libraries/technique_library.ncl");

        let content = fs::read_to_string(&nickel_path).expect("Should read technique library");
        assert!(content.contains("CELValidation"), "Should include CEL validation");
        assert!(content.contains("validate_cel_reference"), "Should validate CEL references");
        assert!(content.contains("validate_cel_expressions_in_object"), "Should validate object CEL expressions");
    }

    #[test]
    fn test_technique_library_isa_validation() {
        // Test that the library includes ISA compliance validation
        let nickel_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/libraries/technique_library.ncl");

        let content = fs::read_to_string(&nickel_path).expect("Should read technique library");
        assert!(content.contains("ISAValidation"), "Should include ISA validation");
        assert!(content.contains("validate_input_contract"), "Should validate input contracts");
        assert!(content.contains("validate_steps_structure"), "Should validate steps structure");
        assert!(content.contains("validate_data_flow"), "Should validate data flow");
    }

    #[test]
    fn test_technique_library_contract_validation() {
        // Test that the library includes complete technique contract validation
        let nickel_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/libraries/technique_library.ncl");

        let content = fs::read_to_string(&nickel_path).expect("Should read technique library");
        assert!(content.contains("TechniqueContract"), "Should include technique contract");
        assert!(content.contains("validate"), "Should have validate function");
    }

    #[test]
    fn test_architecture_techniques_directory_inheritance() {
        // Test that architecture/techniques/_directory.ncl exists and inherits properly
        let arch_techniques_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/architecture/techniques/_directory.ncl");

        assert!(arch_techniques_dir.exists(), "Architecture techniques directory should exist");

        let content = fs::read_to_string(&arch_techniques_dir).expect("Should read architecture techniques directory");
        assert!(content.contains("Libraries"), "Should import libraries");
        assert!(content.contains("technique_validation"), "Should include technique validation");
        assert!(content.contains("validate_architecture_technique"), "Should validate architecture techniques");
    }

    #[test]
    fn test_infrastructure_techniques_inheritance() {
        // Test that infrastructure/techniques inherits from architecture
        let infra_techniques_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/infrastructure/techniques/_directory.ncl");

        assert!(infra_techniques_dir.exists(), "Infrastructure techniques directory should exist");

        let content = fs::read_to_string(&infra_techniques_dir).expect("Should read infrastructure techniques directory");
        assert!(content.contains("ArchitectureTechniques"), "Should inherit from architecture techniques");
        assert!(content.contains("validate_infrastructure_technique"), "Should validate infrastructure techniques");
    }

    #[test]
    fn test_nlp_techniques_subdirectory_inheritance() {
        // Test that nlp subdirectory inherits from techniques
        let nlp_techniques_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/infrastructure/techniques/nlp/_directory.ncl");

        assert!(nlp_techniques_dir.exists(), "NLP techniques directory should exist");

        let content = fs::read_to_string(&nlp_techniques_dir).expect("Should read NLP techniques directory");
        assert!(content.contains("ParentTechniques"), "Should inherit from parent techniques");
        assert!(content.contains("validate_nlp_technique"), "Should validate NLP techniques");
    }

    #[test]
    fn test_all_libraries_includes_technique_library() {
        // Test that all_libraries.ncl includes the technique library
        let all_libraries_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/libraries/all_libraries.ncl");

        let content = fs::read_to_string(&all_libraries_path).expect("Should read all libraries");
        assert!(content.contains("TechniqueLibrary"), "Should import technique library");
        assert!(content.contains("technique"), "Should include technique in merged libraries list");
    }

    #[test]
    fn test_technique_schema_structure_matches_github() {
        // Test that our understanding of technique schema structure matches the GitHub example
        let valid_technique = create_valid_technique();

        // Verify structure matches GitHub schema
        assert!(valid_technique.get("$schema").is_some(), "Should have $schema");
        assert!(valid_technique.get("$id").is_some(), "Should have $id");
        assert!(valid_technique.get("id").is_some(), "Should have id");
        assert!(valid_technique.get("x-familiar-kind").is_some(), "Should have x-familiar-kind");
        assert!(valid_technique.get("input").is_some(), "Should have input");
        assert!(valid_technique.get("output").is_some(), "Should have output");
        assert!(valid_technique.get("steps").is_some(), "Should have steps");
        assert!(valid_technique.get("return").is_some(), "Should have return");

        // Verify steps structure
        let steps = valid_technique.get("steps").unwrap().as_array().unwrap();
        assert!(!steps.is_empty(), "Should have steps");

        for step in steps {
            assert!(step.get("id").is_some(), "Step should have id");
            assert!(step.get("kind").is_some(), "Step should have kind");
            assert!(step.get("action").is_some(), "Step should have action");
        }

        // Verify CEL expressions in args and return
        let return_obj = valid_technique.get("return").unwrap().as_object().unwrap();
        for (_key, value) in return_obj {
            if let Some(str_val) = value.as_str() {
                assert!(str_val.starts_with("$."), "Return values should be CEL expressions: {}", str_val);
            }
        }
    }
}

/// Test the Action Library validation functions
mod action_library_tests {
    use super::*;

    /// Test valid action structure based on improved schema
    fn create_valid_action() -> serde_json::Value {
        serde_json::json!({
          "$schema": "../../../architecture/meta/Action.meta.schema.json",
          "$id": "infrastructure/actions/classification/extract-features.action.json",
          "id": "classification.extract-features",
          "title": "Extract Segment Features",
          "description": "Extract semantic and temporal features from text segments",
          "x-familiar-kind": "action",
          "x-familiar-compute-category": "ai",
          "x-familiar-execution-model": "async",
          "x-familiar-side-effects": ["ml-inference"],
          "x-familiar-reliability": "idempotent",
          "signature": {
            "inputs": {
              "segment": {
                "schema": { "$ref": "../../../primitives/Segment.schema.json" },
                "semantics": "borrow"
              }
            },
            "output": {
              "schema": { "$ref": "../../../primitives/SegmentFeatures.schema.json" },
              "nature": "atomic"
            },
            "capabilities": {
              "category": "feature-extraction",
              "provides": ["semantic-features", "temporal-features"],
              "description": "Feature extraction models for semantic understanding"
            }
          }
        })
    }

    /// Test action without capabilities (should still be valid)
    fn create_action_without_capabilities() -> serde_json::Value {
        let mut action = create_valid_action();
        if let Some(signature) = action.get_mut("signature").and_then(|s| s.as_object_mut()) {
            signature.remove("capabilities");
        }
        action
    }

    /// Test invalid action with missing signature
    fn create_invalid_action_missing_signature() -> serde_json::Value {
        let mut action = create_valid_action();
        action.as_object_mut().unwrap().remove("signature");
        action
    }

    #[test]
    fn test_action_library_existence() {
        // Test that the action library exists and can be loaded
        let action_lib_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/libraries/action_library.ncl");

        assert!(action_lib_path.exists(), "Action library should exist");

        let content = fs::read_to_string(&action_lib_path).expect("Should read action library");
        assert!(content.contains("ActionValidation"), "Should include action validation");
        assert!(content.contains("CapabilityQueries"), "Should include capability queries");
    }

    #[test]
    fn test_action_library_signature_validation() {
        // Test that the library includes signature validation functions
        let action_lib_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/libraries/action_library.ncl");

        let content = fs::read_to_string(&action_lib_path).expect("Should read action library");
        assert!(content.contains("validate_signature"), "Should validate signatures");
        assert!(content.contains("validate_capabilities"), "Should validate capabilities");
        assert!(content.contains("validate_action"), "Should validate complete actions");
    }

    #[test]
    fn test_action_library_capability_queries() {
        // Test that the library includes capability querying functions
        let action_lib_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/libraries/action_library.ncl");

        let content = fs::read_to_string(&action_lib_path).expect("Should read action library");
        assert!(content.contains("has_capability"), "Should check capabilities");
        assert!(content.contains("by_category"), "Should query by category");
        assert!(content.contains("find_compatible_actions"), "Should find compatible actions");
    }

    #[test]
    fn test_infrastructure_actions_directory_inheritance() {
        // Test that infrastructure/actions/_directory.ncl exists and includes action validation
        let infra_actions_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/infrastructure/actions/_directory.ncl");

        assert!(infra_actions_dir.exists(), "Infrastructure actions directory should exist");

        let content = fs::read_to_string(&infra_actions_dir).expect("Should read infrastructure actions directory");
        assert!(content.contains("Libraries"), "Should import libraries");
        assert!(content.contains("action_validation"), "Should include action validation");
        assert!(content.contains("validate_infrastructure_action"), "Should validate infrastructure actions");
    }

    #[test]
    fn test_all_libraries_includes_action_library() {
        // Test that all_libraries.ncl includes the action library
        let all_libraries_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/libraries/all_libraries.ncl");

        let content = fs::read_to_string(&all_libraries_path).expect("Should read all libraries");
        assert!(content.contains("ActionLibrary"), "Should import action library");
        assert!(content.contains("action"), "Should include action in merged libraries list");
    }

    #[test]
    fn test_action_schema_structure_with_capabilities() {
        // Test that our action schema structure includes capabilities in signature
        let valid_action = create_valid_action();

        // Verify structure
        assert!(valid_action.get("$schema").is_some(), "Should have $schema");
        assert!(valid_action.get("$id").is_some(), "Should have $id");
        assert!(valid_action.get("id").is_some(), "Should have id");
        assert!(valid_action.get("x-familiar-kind").is_some(), "Should have x-familiar-kind");
        assert_eq!(valid_action.get("x-familiar-kind").unwrap(), "action", "Should be action kind");

        // Verify signature structure
        assert!(valid_action.get("signature").is_some(), "Should have signature");
        let signature = valid_action.get("signature").unwrap().as_object().unwrap();

        assert!(signature.contains_key("inputs"), "Should have inputs");
        assert!(signature.contains_key("output"), "Should have output");
        assert!(signature.contains_key("capabilities"), "Should have capabilities");

        // Verify capabilities structure
        let capabilities = signature.get("capabilities").unwrap().as_object().unwrap();
        assert!(capabilities.contains_key("category"), "Should have category");
        assert!(capabilities.contains_key("provides"), "Should have provides");
        assert!(capabilities.contains_key("description"), "Should have description");

        assert_eq!(capabilities.get("category").unwrap(), "feature-extraction", "Should have correct category");
        assert!(capabilities.get("provides").unwrap().as_array().is_some(), "Provides should be array");
    }

    #[test]
    fn test_action_schema_without_capabilities() {
        // Test that actions without capabilities are still valid
        let action_without_caps = create_action_without_capabilities();

        // Should still have signature with inputs and output
        assert!(action_without_caps.get("signature").is_some(), "Should have signature");
        let signature = action_without_caps.get("signature").unwrap().as_object().unwrap();

        assert!(signature.contains_key("inputs"), "Should have inputs");
        assert!(signature.contains_key("output"), "Should have output");
        assert!(!signature.contains_key("capabilities"), "Should not have capabilities");

        // Should still be a valid action
        assert_eq!(action_without_caps.get("x-familiar-kind").unwrap(), "action", "Should be action kind");
    }

    #[test]
    fn test_example_action_file_exists() {
        // Test that our example action file exists
        let action_file = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/json-schema/infrastructure/actions/classification/extract-features.action.json");

        assert!(action_file.exists(), "Example action file should exist");

        let content = fs::read_to_string(&action_file).expect("Should read action file");
        assert!(content.contains("capabilities"), "Should include capabilities in signature");
        assert!(!content.contains("x-familiar-tooling"), "Should not use x-familiar-tooling extension");
    }
}

/// Test the Reference Library validation for orthological $ref and $schema patterns
mod reference_library_tests {
    use super::*;

    /// Test valid directory-level schema (should not use $refs)
    fn create_valid_directory_schema() -> serde_json::Value {
        serde_json::json!({
          "Libraries": {},
          "bundle_metadata": {
            "merged_libraries": ["contract", "validation"],
            "composition_strategy": "extreme_merging"
          }
        })
    }

    /// Test invalid directory schema with forbidden $ref
    fn create_invalid_directory_with_refs() -> serde_json::Value {
        serde_json::json!({
          "x-familiar-depends": [{
            "$ref": "../components/SomeComponent.component.json"
          }],
          "Libraries": {}
        })
    }

    /// Test valid leaf-level schema (may use $refs)
    fn create_valid_leaf_schema() -> serde_json::Value {
        serde_json::json!({
          "$schema": "http://json-schema.org/draft-07/schema#",
          "properties": {
            "field": { "$ref": "../primitives/String.schema.json" }
          }
        })
    }

    /// Test invalid leaf schema with forbidden $ref pattern
    fn create_invalid_leaf_schema() -> serde_json::Value {
        serde_json::json!({
          "$schema": "http://json-schema.org/draft-07/schema#",
          "properties": {
            "field": { "$ref": "../invalid/Type.schema.json" }
          }
        })
    }

    /// Test valid meta schema (may use $refs)
    fn create_valid_meta_schema() -> serde_json::Value {
        serde_json::json!({
          "$schema": "http://json-schema.org/draft-07/schema#",
          "$id": "meta.schema.json",
          "properties": {
            "input": {
              "properties": {
                "$ref": { "type": "string" }
              }
            }
          }
        })
    }

    #[test]
    fn test_reference_library_existence() {
        // Test that the reference library exists and defines orthological patterns
        let ref_lib_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/libraries/reference_library.ncl");

        assert!(ref_lib_path.exists(), "Reference library should exist");

        let content = fs::read_to_string(&ref_lib_path).expect("Should read reference library");
        assert!(content.contains("ReferencePatterns"), "Should define reference patterns");
        assert!(content.contains("ReferenceValidation"), "Should include reference validation");
        assert!(content.contains("InheritanceValidation"), "Should include inheritance validation");
        assert!(content.contains("ReferenceContract"), "Should include reference contract");
    }

    #[test]
    fn test_reference_patterns_definitions() {
        // Test that the library defines orthological reference patterns
        let ref_lib_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/libraries/reference_library.ncl");

        let content = fs::read_to_string(&ref_lib_path).expect("Should read reference library");
        assert!(content.contains("allowed_schema_patterns"), "Should define allowed schema patterns");
        assert!(content.contains("directory"), "Should define directory level patterns");
        assert!(content.contains("leaf"), "Should define leaf level patterns");
        assert!(content.contains("meta"), "Should define meta level patterns");
        assert!(content.contains("forbidden_refs"), "Should define forbidden ref patterns");
    }

    #[test]
    fn test_architecture_directory_includes_reference_validation() {
        // Test that architecture directory includes reference validation
        let arch_dir_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/architecture/_directory.ncl");

        let content = fs::read_to_string(&arch_dir_path).expect("Should read architecture directory");
        assert!(content.contains("ReferenceValidation"), "Should include reference validation");
        assert!(content.contains("validate_architecture_directory"), "Should validate directory schemas");
        assert!(content.contains("validate_architecture_meta"), "Should validate meta schemas");
    }

    #[test]
    fn test_all_libraries_includes_reference_library() {
        // Test that all_libraries.ncl includes the reference library
        let all_libraries_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel/libraries/all_libraries.ncl");

        let content = fs::read_to_string(&all_libraries_path).expect("Should read all libraries");
        assert!(content.contains("ReferenceLibrary"), "Should import reference library");
        assert!(content.contains("reference"), "Should include reference in merged libraries list");
    }

    #[test]
    fn test_valid_directory_schema_structure() {
        // Test that our valid directory schema follows orthological patterns
        let valid_directory = create_valid_directory_schema();

        // Should not have $refs (inheritance-based)
        assert!(!has_refs(&valid_directory), "Directory schemas should not have $refs");

        // Should have inheritance indicators
        assert!(valid_directory.get("Libraries").is_some() ||
                valid_directory.get("bundle_metadata").is_some(),
                "Directory schemas should have inheritance indicators");
    }

    #[test]
    fn test_invalid_directory_schema_with_refs() {
        // Test that directory schemas with $refs are flagged as invalid
        let invalid_directory = create_invalid_directory_with_refs();

        // Should have forbidden $refs
        assert!(has_refs(&invalid_directory), "This test schema should have $refs (which are forbidden at directory level)");
    }

    #[test]
    fn test_valid_leaf_schema_with_refs() {
        // Test that leaf schemas can have appropriate $refs
        let valid_leaf = create_valid_leaf_schema();

        // Should have valid $schema
        assert_eq!(valid_leaf.get("$schema").unwrap(), "http://json-schema.org/draft-07/schema#",
                   "Should have valid JSON Schema declaration");

        // Should have allowed $ref pattern
        assert!(has_refs(&valid_leaf), "Leaf schemas should be able to have $refs");
        assert!(has_primitive_refs(&valid_leaf), "Should reference primitives (allowed)");
    }

    #[test]
    fn test_valid_meta_schema_structure() {
        // Test that meta schemas follow orthological patterns
        let valid_meta = create_valid_meta_schema();

        // Should have $schema and $id
        assert!(valid_meta.get("$schema").is_some(), "Meta schemas should have $schema");
        assert!(valid_meta.get("$id").is_some(), "Meta schemas should have $id");

        // May have $refs for schema composition
        // (This particular meta schema doesn't, but others might)
    }

    #[test]
    fn test_orthological_separation_validation() {
        // Test that different levels enforce different patterns

        // Directory level: No $refs, inheritance required
        let directory_schema = create_valid_directory_schema();
        assert!(!has_refs(&directory_schema), "Directory: No $refs allowed");
        assert!(has_inheritance_indicators(&directory_schema), "Directory: Inheritance required");

        // Leaf level: $refs allowed, inheritance not required
        let leaf_schema = create_valid_leaf_schema();
        assert!(has_refs(&leaf_schema), "Leaf: $refs allowed");
        // Leaf schemas typically don't show inheritance indicators

        // Meta level: Both patterns possible
        let meta_schema = create_valid_meta_schema();
        // Meta schemas can have either pattern depending on use case
    }
}

// Helper functions for reference validation tests
fn has_refs(schema: &serde_json::Value) -> bool {
    fn check_value(value: &serde_json::Value) -> bool {
        match value {
            serde_json::Value::Object(obj) => {
                if obj.contains_key("$ref") {
                    return true;
                }
                obj.values().any(check_value)
            }
            serde_json::Value::Array(arr) => arr.iter().any(check_value),
            _ => false,
        }
    }
    check_value(schema)
}

fn has_primitive_refs(schema: &serde_json::Value) -> bool {
    fn check_value(value: &serde_json::Value) -> bool {
        match value {
            serde_json::Value::Object(obj) => {
                if let Some(ref_val) = obj.get("$ref") {
                    if let Some(ref_str) = ref_val.as_str() {
                        return ref_str.contains("primitive");
                    }
                }
                obj.values().any(check_value)
            }
            serde_json::Value::Array(arr) => arr.iter().any(check_value),
            _ => false,
        }
    }
    check_value(schema)
}

fn has_inheritance_indicators(schema: &serde_json::Value) -> bool {
    schema.get("Libraries").is_some() ||
    schema.get("bundle_metadata").is_some() ||
    schema.get("Composer").is_some()
}

    #[test]
    fn test_nickel_validation_against_aligned_json_schemas() {
        // COMPREHENSIVE FAIL-FRIENDLY VALIDATION TEST
        // This test collects ALL validation results, provides verbose reporting,
        // and never exits early or has hardcoded success paths.
        // Failures indicate real development issues, not test problems.

        let aligned_directories = vec![
            // Only test directories that actually have both Nickel contracts and JSON schemas
            ("infrastructure/actions", "infrastructure/actions/classification"),
        ];

        // Check Nickel availability first (fail-friendly - clear error if not available)
        let validator = match NickelValidator::new() {
            Ok(v) => v,
            Err(e) => {
                panic!(" Nickel CLI not available for validation testing. Install Nickel CLI to run this test.\nError: {}", e);
            }
        };

        // Track comprehensive results across ALL directories and schemas
        let mut total_schemas_tested = 0;
        let mut total_validation_passed = 0;
        let mut total_validation_failed = 0;
        let mut total_parse_failed = 0;
        let mut total_read_failed = 0;
        let mut all_validation_errors = Vec::new();
        let mut all_parse_errors = Vec::new();
        let mut all_read_errors = Vec::new();
        let mut all_warnings = Vec::new();
        let mut directory_results = Vec::new();

        println!(" COMPREHENSIVE NICKEL VALIDATION TEST");
        println!("==============================================");
        println!("Testing Nickel validation contracts against JSON schemas");
        println!("This test collects ALL results and provides detailed feedback");
        println!("Failures indicate development work needed, not test issues");
        println!("==============================================");

        // Test each aligned directory
        for (nickel_path, json_path) in aligned_directories {
            println!("\n DIRECTORY: {}  {}", nickel_path, json_path);

            let mut dir_result = DirectoryTestResult {
                name: nickel_path.to_string(),
                nickel_contract_exists: false,
                json_directory_exists: false,
                schemas_found: 0,
                validation_passed: 0,
                validation_failed: 0,
                parse_failed: 0,
                read_failed: 0,
                errors: Vec::new(),
            };

            // Check structural alignment (record but don't fail immediately)
            let nickel_dir_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                .join("../../versions/latest/nickel")
                .join(nickel_path)
                .join("_directory.ncl");

            let json_dir_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                .join("../../versions/latest/json-schema")
                .join(json_path);

            dir_result.nickel_contract_exists = nickel_dir_path.exists();
            dir_result.json_directory_exists = json_dir_path.exists();

            if !dir_result.nickel_contract_exists {
                let msg = format!(" Nickel contract missing: {}", nickel_path);
                println!("{}", msg);
                dir_result.errors.push(msg.clone());
                all_validation_errors.push(msg);
            }

            if !dir_result.json_directory_exists {
                let msg = format!(" JSON directory missing: {}", json_path);
                println!("{}", msg);
                dir_result.errors.push(msg.clone());
                all_validation_errors.push(msg);
            }

            // Skip validation if structural issues exist
            if !dir_result.nickel_contract_exists || !dir_result.json_directory_exists {
                directory_results.push(dir_result);
                continue;
            }

            // Find ALL JSON schema files (not just a subset)
            let json_files = find_json_schema_files(&json_dir_path);
            dir_result.schemas_found = json_files.len();

            println!(" Found {} JSON schema files to validate", json_files.len());

            if json_files.is_empty() {
                let msg = format!("  No schemas to validate in: {}", json_path);
                println!("{}", msg);
                all_warnings.push(msg);
                directory_results.push(dir_result);
                continue;
            }

            // Test EVERY schema file comprehensively
            for json_file in json_files {
                let file_name = json_file.file_name().unwrap().to_string_lossy().to_string();
                total_schemas_tested += 1;
                dir_result.schemas_found += 1;

                print!(" Testing: {} ... ", file_name);

                match fs::read_to_string(&json_file) {
                    Ok(content) => {
                        match serde_json::from_str::<serde_json::Value>(&content) {
                            Ok(schema) => {
                                // Actually run Nickel validation
                                match validator.validate_schema(&schema, &json_file) {
                                    Ok(()) => {
                                        total_validation_passed += 1;
                                        dir_result.validation_passed += 1;
                                        println!(" PASSED");
                                    }
                                    Err(e) => {
                                        total_validation_failed += 1;
                                        dir_result.validation_failed += 1;
                                        let error_msg = format!(" VALIDATION FAILED: {} - {}", file_name, e);
                                        println!("FAILED");
                                        println!("   Error: {}", e);
                                        dir_result.errors.push(error_msg.clone());
                                        all_validation_errors.push(format!("{} in {}", error_msg, nickel_path));
                                    }
                                }
                            }
                            Err(e) => {
                                total_parse_failed += 1;
                                dir_result.parse_failed += 1;
                                let error_msg = format!(" PARSE FAILED: {} - {}", file_name, e);
                                println!("PARSE ERROR");
                                println!("   Error: {}", e);
                                dir_result.errors.push(error_msg.clone());
                                all_parse_errors.push(format!("{} in {}", error_msg, nickel_path));
                            }
                        }
                    }
                    Err(e) => {
                        total_read_failed += 1;
                        dir_result.read_failed += 1;
                        let error_msg = format!(" READ FAILED: {} - {}", file_name, e);
                        println!("READ ERROR");
                        println!("   Error: {}", e);
                        dir_result.errors.push(error_msg.clone());
                        all_read_errors.push(format!("{} in {}", error_msg, nickel_path));
                    }
                }
            }

            // Directory summary
            println!("\n Directory Summary for {}:", nickel_path);
            println!("    Total schemas: {}", dir_result.schemas_found);
            println!("    Validation passed: {}", dir_result.validation_passed);
            println!("    Validation failed: {}", dir_result.validation_failed);
            println!("    Parse failed: {}", dir_result.parse_failed);
            println!("    Read failed: {}", dir_result.read_failed);

            directory_results.push(dir_result);
        }

        // COMPREHENSIVE FINAL REPORT
        println!("\n==============================================");
        println!(" COMPREHENSIVE VALIDATION REPORT");
        println!("==============================================");
        println!(" OVERALL STATISTICS:");
        println!("    Total schemas tested: {}", total_schemas_tested);
        println!("    Validation passed: {}", total_validation_passed);
        println!("    Validation failed: {}", total_validation_failed);
        println!("    Schema parse failed: {}", total_parse_failed);
        println!("    File read failed: {}", total_read_failed);
        println!("     Warnings: {}", all_warnings.len());

        // Directory-by-directory breakdown
        println!("\n DIRECTORY BREAKDOWN:");
        for dir_result in &directory_results {
            println!("   {}: {} tested, {} passed, {} failed",
                    dir_result.name,
                    dir_result.schemas_found,
                    dir_result.validation_passed,
                    dir_result.validation_failed);
        }

        // Detailed error reporting (all errors, not just first few)
        if !all_validation_errors.is_empty() {
            println!("\n VALIDATION ERRORS ({} total):", all_validation_errors.len());
            for (i, error) in all_validation_errors.iter().enumerate() {
                println!("   {}. {}", i + 1, error);
            }
        }

        if !all_parse_errors.is_empty() {
            println!("\n SCHEMA PARSE ERRORS ({} total):", all_parse_errors.len());
            for (i, error) in all_parse_errors.iter().enumerate() {
                println!("   {}. {}", i + 1, error);
            }
        }

        if !all_read_errors.is_empty() {
            println!("\n FILE READ ERRORS ({} total):", all_read_errors.len());
            for (i, error) in all_read_errors.iter().enumerate() {
                println!("   {}. {}", i + 1, error);
            }
        }

        if !all_warnings.is_empty() {
            println!("\n  WARNINGS ({} total):", all_warnings.len());
            for (i, warning) in all_warnings.iter().enumerate() {
                println!("   {}. {}", i + 1, warning);
            }
        }

        // ASSESSMENT - Tests MUST fail when validation errors are found
        println!("\n ASSESSMENT:");
        if total_schemas_tested == 0 {
            println!(" NO SCHEMAS TESTED - Check directory alignment and file availability");
            panic!("Test failed: No schemas were testable");
        }

        let total_failures = total_validation_failed + total_parse_failed + total_read_failed;
        if total_failures == 0 && total_validation_passed == total_schemas_tested {
            println!(" ALL TESTS PASSED - Nickel validation working perfectly");
        } else {
            let fail_rate = total_failures as f64 / total_schemas_tested as f64 * 100.0;
            println!(" VALIDATION ERRORS DETECTED - {:.1}% of tests failed ({}/{})",
                    fail_rate, total_failures, total_schemas_tested);
            println!(" This indicates BROKEN validation logic that MUST be fixed");

            // Provide specific guidance
            if total_validation_failed > 0 {
                println!(" FIX: Nickel contracts have syntax/logic errors");
            }
            if total_parse_failed > 0 {
                println!(" FIX: JSON schemas have syntax errors");
            }
            if total_read_failed > 0 {
                println!(" FIX: File access issues");
            }

            panic!("Validation errors detected - fix before proceeding with development");
        }

        println!("\n TEST COMPLETED SUCCESSFULLY - All validations passed");
    }

    // Helper struct for directory results
    #[derive(Debug)]
    struct DirectoryTestResult {
        name: String,
        nickel_contract_exists: bool,
        json_directory_exists: bool,
        schemas_found: usize,
        validation_passed: usize,
        validation_failed: usize,
        parse_failed: usize,
        read_failed: usize,
        errors: Vec<String>,
    }

#[test]
fn test_directory_level_inheritance_patterns() {
    // Test that directory-level schemas (Nickel _directory.ncl files) follow inheritance patterns
    // NOT that JSON schemas don't use $refs - that was the misunderstanding

    let nickel_directories = vec![
        "architecture/_directory.ncl",
        "infrastructure/_directory.ncl",
        "infrastructure/actions/_directory.ncl",
        "infrastructure/techniques/_directory.ncl",
    ];

    for dir_file in nickel_directories {
        let file_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../../versions/latest/nickel")
            .join(dir_file);

        assert!(file_path.exists(), "Nickel directory file should exist: {}", dir_file);

        let content = fs::read_to_string(&file_path).expect("Should read Nickel directory file");

        // Directory-level Nickel schemas should show inheritance patterns
        let has_inheritance = content.contains("Libraries") ||
                            content.contains("Composer") ||
                            content.contains("bundle_metadata") ||
                            content.contains("&");

        assert!(has_inheritance, "Directory-level Nickel schema should use inheritance: {}", dir_file);
    }
}

    #[test]
    fn test_current_schema_ref_usage_patterns() {
        // Test current $ref usage patterns to understand what we're validating against
        // This helps clarify that JSON schemas DO use $refs (leaf level is correct)
        // while Nickel schemas use inheritance (directory level is correct)

        let test_directories = vec![
            ("entities", "entity"),
            ("components", "component"),
            ("infrastructure/actions/classification", "action"),
            ("primitives", "primitive"),
        ];

        let mut total_refs_found = 0;
        let mut schemas_with_refs = 0;

        for (json_dir, expected_ref_type) in test_directories {
            let json_dir_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                .join("../../versions/latest/json-schema")
                .join(json_dir);

            if json_dir_path.exists() {
                let json_files = find_json_schema_files(&json_dir_path);

                for json_file in json_files.iter().take(3) { // Test first 3 files per directory
                    if let Ok(content) = fs::read_to_string(json_file) {
                        if let Ok(schema) = serde_json::from_str::<serde_json::Value>(&content) {
                            let ref_count = count_refs(&schema);
                            if ref_count > 0 {
                                total_refs_found += ref_count;
                                schemas_with_refs += 1;
                                println!(" {} schema {} uses {} $refs (expected for leaf level)",
                                        expected_ref_type, json_file.file_name().unwrap().to_string_lossy(), ref_count);
                            }
                        }
                    }
                }
            }
        }

        // Verify we found the expected $ref usage patterns
        assert!(schemas_with_refs > 0, "Should find schemas using $refs at leaf level");
        assert!(total_refs_found > 5, "Should find substantial $ref usage in leaf schemas");

        println!(" Summary: Found {} schemas with $refs, {} total $ref usages (leaf level usage is correct)",
                schemas_with_refs, total_refs_found);
    }

    #[test]
    fn test_nickel_directory_validation_applicability() {
        // Demonstrate that Nickel _directory.ncl files are validation contracts
        // meant to be applied against JSON schemas in their directories

        // This clarifies the "Directory Level: No $refs currently used" statement
        // It means Nickel directory schemas don't contain $refs (they use inheritance)
        // But they ARE applied against JSON schemas that DO contain $refs

        let nickel_dirs = vec![
            "infrastructure/actions/_directory.ncl",
        ];

        let json_dirs = vec![
            "infrastructure/actions/classification",
        ];

        for (nickel_file, json_dir) in nickel_dirs.iter().zip(json_dirs.iter()) {
            // Nickel directory contract exists
            let nickel_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                .join("../../versions/latest/nickel")
                .join(nickel_file);
            assert!(nickel_path.exists(), "Nickel validation contract should exist: {}", nickel_file);

            // JSON schemas to validate exist
            let json_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                .join("../../versions/latest/json-schema")
                .join(json_dir);
            assert!(json_path.exists(), "JSON schemas to validate should exist: {}", json_dir);

            let json_files = find_json_schema_files(&json_path);
            assert!(!json_files.is_empty(), "Should have JSON schemas for Nickel to validate: {}", json_dir);

            // Read Nickel contract to verify it contains validation logic
            let nickel_content = fs::read_to_string(&nickel_path).expect("Should read Nickel contract");
            assert!(nickel_content.contains("validation") || nickel_content.contains("Validation"),
                   "Nickel contract should contain validation logic: {}", nickel_file);
        }

        println!(" Nickel Validation Pattern Confirmed:");
        println!("   - Nickel _directory.ncl files = Validation contracts");
        println!("   - Applied against JSON schemas in corresponding directories");
        println!("   - Nickel contracts use inheritance (& merging)");
        println!("   - JSON schemas use $refs (leaf level composition)");
    }

// Helper functions for Nickel validation tests
fn find_json_schema_files(dir_path: &PathBuf) -> Vec<PathBuf> {
    let mut json_files = Vec::new();
    if let Ok(entries) = fs::read_dir(dir_path) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.extension().map_or(false, |ext| ext == "json") {
                json_files.push(path);
            }
        }
    }
    json_files
}

fn count_refs(schema: &serde_json::Value) -> usize {
    let mut count = 0;
    fn count_in_value(value: &serde_json::Value, count: &mut usize) {
        match value {
            serde_json::Value::Object(obj) => {
                if obj.contains_key("$ref") {
                    *count += 1;
                }
                for val in obj.values() {
                    count_in_value(val, count);
                }
            }
            serde_json::Value::Array(arr) => {
                for val in arr {
                    count_in_value(val, count);
                }
            }
            _ => {}
        }
    }
    count_in_value(schema, &mut count);
    count
}
```

### packages/familiar-schemas/tests/nickel_schema_tests.rs

```rust
//! Nickel Schema Application Tests with rstest
//!
//! Tests Nickel schema application to JSONSchema files at runtime.
//! Nickel files create composite results from JSONSchema inputs (in memory).
//! Uses rstest for parameterized testing across real JSONSchema fixtures.

use std::fs;
use std::path::{Path, PathBuf};

use familiar_schemas::NickelValidator;
use rstest::fixture;

/// Test fixture combining a JSONSchema with its expected Nickel processing layer
#[derive(Debug, Clone)]
pub struct SchemaTestFixture {
    pub name: String,
    pub json_schema: serde_json::Value,
    pub expected_layer: String,
    pub nickel_dir_path: PathBuf,
}

/// Load all JSONSchema fixtures and determine their expected processing layers
#[fixture]
pub fn schema_fixtures() -> Vec<SchemaTestFixture> {
    let fixtures_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../tests/fixtures");
    let nickel_base = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../versions/latest/nickel");
    let mut fixtures = Vec::new();

    if let Ok(entries) = fs::read_dir(&fixtures_dir) {
        for entry in entries.flatten() {
            if let Some(ext) = entry.path().extension() {
                if ext == "json" {
                    let fixture_name = entry.path().file_stem()
                        .unwrap()
                        .to_string_lossy()
                        .to_string();

                    if let Ok(content) = fs::read_to_string(&entry.path()) {
                        if let Ok(json_schema) = serde_json::from_str(&content) {
                            let expected_layer = determine_expected_layer(&json_schema);
                            let nickel_dir_path = determine_nickel_directory(&nickel_base, &json_schema);

                            fixtures.push(SchemaTestFixture {
                                name: fixture_name,
                                json_schema,
                                expected_layer,
                                nickel_dir_path,
                            });
                        }
                    }
                }
            }
        }
    }

    fixtures
}

/// Determine which Nickel directory should process this JSONSchema
fn determine_nickel_directory(nickel_base: &Path, schema: &serde_json::Value) -> PathBuf {
    if schema.get("x-familiar-kind").and_then(|v| v.as_str()) == Some("component") ||
       schema.get("properties").is_some() {
        nickel_base.join("codegen/components/_directory.ncl")
    } else if schema.get("x-familiar-service").is_some() ||
              schema.get("x-familiar-depends_on").is_some() {
        nickel_base.join("architecture/_directory.ncl")
    } else if schema.get("x-familiar-node-type").is_some() ||
              schema.get("x-familiar-resources").is_some() {
        nickel_base.join("infrastructure/_directory.ncl")
    } else {
        nickel_base.join("domain/_directory.ncl")
    }
}

/// Determine expected layer for schema processing
fn determine_expected_layer(schema: &serde_json::Value) -> String {
    if schema.get("properties").is_some() || schema.get("type").is_some() {
        "entity".to_string()
    } else if schema.get("x-familiar-node-type").is_some() {
        "node".to_string()
    } else if schema.get("x-familiar-depends_on").is_some() {
        "topology".to_string()
    } else {
        "domain".to_string()
    }
}

// =============================================================================
// NICKEL SCHEMA APPLICATION TESTS
// =============================================================================

/// Test basic Nickel validator initialization
#[test]
fn test_nickel_validator_initialization() {
    // Basic smoke test - NickelValidator::new() should not panic
    let _validator = NickelValidator::new();
    assert!(true, "NickelValidator creation attempted successfully");
}

/// Test nested directory structure processing with JSONSchemas
#[rstest]
fn test_nested_directory_structure(#[from(schema_fixtures)] fixture: SchemaTestFixture) {
    // Test that nested directory paths work for schema processing
    assert!(fixture.nickel_dir_path.exists(), "Nickel directory should exist for {}", fixture.name);

    // Test path structure (should be in subdirectories)
    let path_str = fixture.nickel_dir_path.to_string_lossy();
    assert!(path_str.contains("/"), "Should be in subdirectory structure for {}", fixture.name);

    // Verify the directory corresponds to the expected layer
    match fixture.expected_layer.as_str() {
        "entity" => assert!(path_str.contains("codegen") || path_str.contains("entity"), "Entity schemas should use codegen directories"),
        "node" => assert!(path_str.contains("infrastructure"), "Node schemas should use infrastructure directories"),
        "topology" => assert!(path_str.contains("architecture"), "Topology schemas should use architecture directories"),
        _ => assert!(path_str.contains("domain"), "Domain schemas should use domain directories"),
    }
}

/// Test complex composition patterns applied to JSONSchemas
#[rstest]
fn test_complex_composition_with_jsonschema(#[from(schema_fixtures)] fixture: SchemaTestFixture) {
    let nickel_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../versions/latest/nickel");

    // Test that directory composer uses & merging patterns for schema processing
    let composer_content = fs::read_to_string(nickel_path.join("composers/directory_composer.ncl"))
        .expect("Directory composer should be readable for schema processing");

    // Should contain merging patterns for schema composition
    assert!(composer_content.contains("&"), "Composer should use & merging for {}", fixture.name);
    assert!(composer_content.contains("compose"), "Composer should have composition functions for {}", fixture.name);

    // Test that the composition can handle this JSONSchema's layer
    assert!(composer_content.contains(&fixture.expected_layer) ||
            (fixture.expected_layer == "entity" && composer_content.contains("codegen")),
            "Composer should handle {} layer for {}", fixture.expected_layer, fixture.name);
}

/// Test layered architecture structure for JSONSchema application
#[rstest]
fn test_layered_architecture_for_jsonschema(#[from(schema_fixtures)] fixture: SchemaTestFixture) {
    let nickel_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../versions/latest/nickel");

    // Test primitives layer exists for processing this schema
    let primitives = ["contract_primitives.ncl", "extraction_primitives.ncl", "validation_primitives.ncl"];
    for primitive in primitives {
        assert!(nickel_path.join("primitives").join(primitive).exists(),
                "Primitive {} should exist for processing {}", primitive, fixture.name);
    }

    // Test libraries layer for this schema type
    let libraries = ["contract_library.ncl", "extraction_library.ncl", "validation_library.ncl"];
    for library in libraries {
        assert!(nickel_path.join("libraries").join(library).exists(),
                "Library {} should exist for {}", library, fixture.name);
    }

    // Test that the specific Nickel directory for this schema exists
    assert!(fixture.nickel_dir_path.exists(),
            "Nickel directory should exist for processing {}", fixture.name);
}

/// Test directory schema structure for JSONSchema processing
#[rstest]
fn test_directory_schema_for_jsonschema(#[from(schema_fixtures)] fixture: SchemaTestFixture) {
    let validator = match NickelValidator::new() {
        Ok(v) => v,
        Err(_) => NickelValidator {
            nickel_available: false,
            nickel_runtime: None,
        }
    };

    // Test that the assigned directory schema is structurally sound
    if validator.nickel_available {
        // If Nickel is available, test that directory can be evaluated
        // For now, just test file existence since validate_file may not exist
        assert!(fixture.nickel_dir_path.exists(), "Directory schema file should exist for {}", fixture.name);
    } else {
        // If Nickel is not available, still test file existence
        assert!(fixture.nickel_dir_path.exists(), "Directory schema file should exist for {} (Nickel not available)", fixture.name);
    }
}

/// Test extension framework for JSONSchema enhancement
#[rstest]
fn test_extension_framework_for_jsonschema(#[from(schema_fixtures)] fixture: SchemaTestFixture) {
    let nickel_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../versions/latest/nickel");

    // Test key extensions exist for schema enhancement
    let extensions = ["edge-type.ncl", "type-category.ncl", "kind.ncl"];
    for ext in extensions {
        assert!(nickel_path.join("extensions").join(ext).exists(),
                "Extension {} should exist for enhancing {}", ext, fixture.name);
    }

    // Test that extensions can be loaded for this schema
    let validator = match NickelValidator::new() {
        Ok(v) => v,
        Err(_) => NickelValidator {
            nickel_available: false,
            nickel_runtime: None,
        }
    };

    if validator.nickel_available {
        for ext in extensions {
            let ext_path = nickel_path.join("extensions").join(ext);
            assert!(ext_path.exists(), "Extension {} should be loadable for {}", ext, fixture.name);
        }
    }
}

/// Test library, primitive and composer use with JSONSchemas
#[rstest]
fn test_library_primitive_composer_with_jsonschema(#[from(schema_fixtures)] fixture: SchemaTestFixture) {
    let validator = match NickelValidator::new() {
        Ok(v) => v,
        Err(_) => NickelValidator {
            nickel_available: false,
            nickel_runtime: None,
        }
    };

    let nickel_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../versions/latest/nickel");

    // Test that primitives can be loaded for this schema processing
    let primitives = [
        nickel_path.join("primitives/contract_primitives.ncl"),
        nickel_path.join("primitives/extraction_primitives.ncl"),
        nickel_path.join("primitives/validation_primitives.ncl"),
    ];

    for primitive_path in primitives {
        assert!(primitive_path.exists(), "Primitive should exist for processing {}", fixture.name);
    }

    // Test that libraries can be used with this schema
    let libraries = [
        nickel_path.join("libraries/contract_library.ncl"),
        nickel_path.join("libraries/extraction_library.ncl"),
        nickel_path.join("libraries/validation_library.ncl"),
    ];

    for lib_path in libraries {
        assert!(lib_path.exists(), "Library should exist for {}", fixture.name);
    }

    // Test that composer works for this schema type
    let composer_path = nickel_path.join("composers/directory_composer.ncl");
    assert!(composer_path.exists(), "Composer should exist for {}", fixture.name);
}

/// Test hydration application to JSONSchemas
#[rstest]
fn test_hydration_with_jsonschema(#[from(schema_fixtures)] fixture: SchemaTestFixture) {
    let nickel_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../versions/latest/nickel");

    let hydration_content = fs::read_to_string(nickel_path.join("primitives/hydration_primitives.ncl"))
        .expect("Hydration primitives should be readable for schema enhancement");

    // Should define hydration structure for enhancing this schema
    assert!(hydration_content.contains("BaseHydration"), "Should define base hydration for {}", fixture.name);
    assert!(hydration_content.contains("_metadata"), "Should have metadata section for {}", fixture.name);

    // Test layer-specific hydration for this schema
    assert!(hydration_content.contains(&fixture.expected_layer) ||
            fixture.expected_layer == "entity" && hydration_content.contains("codegen"),
            "Should have hydration for {} layer in {}", fixture.expected_layer, fixture.name);
}

/// Test contract validation against JSONSchemas
#[rstest]
fn test_contract_with_jsonschema(#[from(schema_fixtures)] fixture: SchemaTestFixture) {
    let nickel_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../versions/latest/nickel");

    let contract_content = fs::read_to_string(nickel_path.join("libraries/contract_library.ncl"))
        .expect("Contract library should be readable for schema validation");

    // Should provide contract functionality for validating this schema
    assert!(contract_content.contains("enhanced_test_runner"), "Should have test runner for {}", fixture.name);

    // Test that contracts can validate this JSONSchema structure
    let validator = match NickelValidator::new() {
        Ok(v) => v,
        Err(_) => NickelValidator {
            nickel_available: false,
            nickel_runtime: None,
        }
    };

    if validator.nickel_available {
        let contract_path = nickel_path.join("libraries/contract_library.ncl");
        assert!(contract_path.exists(), "Contract library should be loadable for validating {}", fixture.name);
    }
}

/// Test forbidden rule detection on JSONSchemas
#[rstest]
fn test_forbidden_rules_with_jsonschema(#[from(schema_fixtures)] fixture: SchemaTestFixture) {
    let nickel_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../versions/latest/nickel");

    let validation_content = fs::read_to_string(nickel_path.join("primitives/validation_primitives.ncl"))
        .expect("Validation primitives should be readable for schema checking");

    // Should contain forbidden field patterns for this schema type
    assert!(validation_content.contains("forbidden"), "Should define forbidden patterns for {}", fixture.name);

    // Test that validation can check this JSONSchema for forbidden fields
    let validator = match NickelValidator::new() {
        Ok(v) => v,
        Err(_) => NickelValidator {
            nickel_available: false,
            nickel_runtime: None,
        }
    };

    if validator.nickel_available {
        let validation_path = nickel_path.join("primitives/validation_primitives.ncl");
        assert!(validation_path.exists(), "Validation should be loadable for checking {}", fixture.name);
    }

    // Check if this schema has any potentially forbidden fields
    let obj = fixture.json_schema.as_object().unwrap();
    let has_forbidden = obj.keys().any(|k| k.starts_with("x-familiar-"));
    if has_forbidden {
        assert!(true, "Schema {} has familiar extensions that may need validation", fixture.name);
    }
}

/// Test schema transformation and extraction from JSON inputs
#[rstest]
fn test_schema_transformation_from_jsonschema(#[from(schema_fixtures)] fixture: SchemaTestFixture) {
    let nickel_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../versions/latest/nickel");

    let extraction_content = fs::read_to_string(nickel_path.join("libraries/extraction_library.ncl"))
        .expect("Extraction library should be readable for schema transformation");

    // Should provide extraction functions for this schema type
    assert!(extraction_content.contains("extraction_functions"), "Should define extraction functions for {}", fixture.name);

    match fixture.expected_layer.as_str() {
        "entity" => assert!(extraction_content.contains("entity_extract"), "Should extract entities from {}", fixture.name),
        "node" => assert!(extraction_content.contains("node_extract"), "Should extract nodes from {}", fixture.name),
        "topology" => assert!(extraction_content.contains("topology_extract"), "Should extract topology from {}", fixture.name),
        _ => assert!(extraction_content.contains("domain_extract"), "Should extract domain from {}", fixture.name),
    }
}

/// Test edge relationship validation on JSONSchema relationships
#[rstest]
fn test_edge_relationship_on_jsonschema(#[from(schema_fixtures)] fixture: SchemaTestFixture) {
    let nickel_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../versions/latest/nickel");

    let edge_content = fs::read_to_string(nickel_path.join("libraries/edge_library.ncl"))
        .expect("Edge library should be readable for relationship validation");

    // Should handle edge relationships for this schema
    assert!(edge_content.contains("edge_types"), "Should define edge types for {}", fixture.name);
    assert!(edge_content.contains("compatibility"), "Should check compatibility for {}", fixture.name);

    // Test that edge validation can work with this JSONSchema
    if fixture.json_schema.get("x-familiar-edges").is_some() ||
       fixture.json_schema.get("x-familiar-depends_on").is_some() {
        assert!(true, "Schema {} has relationships that need edge validation", fixture.name);
    }
}

/// Test extension framework integration with JSONSchemas
#[rstest]
fn test_extension_integration_with_jsonschema(#[from(schema_fixtures)] fixture: SchemaTestFixture) {
    let nickel_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../versions/latest/nickel");

    let ext_content = fs::read_to_string(nickel_path.join("libraries/extension_library.ncl"))
        .expect("Extension library should be readable for schema enhancement");

    // Should integrate extensions for this schema
    assert!(ext_content.contains("extension"), "Should handle extensions for {}", fixture.name);

    // Test that extensions can enhance this JSONSchema
    let has_extensions = fixture.json_schema.as_object()
        .unwrap()
        .keys()
        .any(|k| k.starts_with("x-familiar-"));

    if has_extensions {
        assert!(true, "Schema {} has extensions that can be enhanced", fixture.name);
    }
}

/// Test global schema composition application to JSONSchemas
#[rstest]
fn test_global_composition_application(#[from(schema_fixtures)] fixture: SchemaTestFixture) {
    let nickel_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../versions/latest/nickel");

    let global_content = fs::read_to_string(nickel_path.join("global.ncl"))
        .expect("Global schema should be readable for comprehensive processing");

    // Should compose global functionality for this schema
    assert!(global_content.contains("Libraries"), "Should import libraries for {}", fixture.name);
    assert!(global_content.contains("&"), "Should use merging for {}", fixture.name);

    // Test that global composition can handle this layer
    assert!(global_content.contains(&fixture.expected_layer) ||
            fixture.expected_layer == "entity" && global_content.contains("codegen"),
            "Global should handle {} layer for {}", fixture.expected_layer, fixture.name);
}
```

### src/codegen/mod.rs

```rust
//! Code Generation
//!
//! Generates code from schemas using the graph infrastructure.
//! 
//! Architecture:
//! - CodegenConfig: Global settings (naming, diagnostics) - language-agnostic
//! - NameResolver: Schema ID -> canonical name mapping with collision handling
//! - RenderProfile: Per-language rendering settings (type mappings, optionality)
//! - CodegenContext: Immutable after build() - holds all analysis results
//! - Region: Pure projection of pre-computed analysis for a single type
//! - Emitters: Language-specific code generators that consume Regions + RenderProfile
//!
//! Key principle: Classification (SchemaShape, SCC, TypeKind) is config-free.
//! Only emission/rendering uses configuration (RenderProfile).

pub mod config;
pub mod names;
pub mod rust;

use std::collections::{HashMap, HashSet};
use std::path::Path;

use crate::graph::{
    BoxedEdge, Classification, Classifier, CycleHandling, Diagnostics, EmitStrategy,
    SchemaGraph, SchemaId, SchemaShape, SccAnalysis, TypeKind, FieldType, JsonScalarKind,
    CodegenExtensions, compute_scc_analysis, detect_all_shapes, validate_boxed_edges,
};

pub use config::{CodegenConfig, RenderProfile, NamingConfig, Language};
pub use names::{NameResolver, ResolvedName, TypeOrigin, NameResolverStats};

// =============================================================================
// Region
// =============================================================================

/// A Region is a pure projection of pre-computed analysis for a single schema.
/// 
/// It contains ONLY what the emitter needs - no raw JSON access.
/// All classification decisions are made BEFORE Region extraction.
/// All type names are ALREADY RESOLVED - no $ref strings.
#[derive(Debug, Clone)]
pub struct Region {
    /// The schema being generated
    pub schema_id: SchemaId,
    
    /// Pre-computed type classification
    pub type_kind: TypeKind,
    
    /// Pre-computed emit strategy
    pub emit_strategy: EmitStrategy,
    
    /// Pre-computed cycle handling
    pub cycle_handling: CycleHandling,
    
    /// Resolved canonical type name (collision-free)
    pub canonical_name: String,
    
    /// Type origin (Primitive, Generated, External, Stdlib)
    pub origin: TypeOrigin,
    
    /// Boxed fields in this schema (keyed by field path)
    pub boxed_fields: Vec<BoxedEdge>,
    
    /// Directory this schema is in (for namespace info)
    pub directory: Option<String>,

    /// Codegen extensions from schema (variants, casing, defaults, etc.)
    pub extensions: CodegenExtensions,
}

impl Region {
    /// Check if a field needs boxing
    pub fn needs_boxing(&self, field_name: &str) -> bool {
        use crate::graph::FieldPathSegment;
        self.boxed_fields.iter().any(|e| {
            matches!(e.field_path.first(), Some(FieldPathSegment::Field(name)) if name == field_name)
        })
    }
    
    /// Should this region be generated?
    pub fn should_generate(&self) -> bool {
        // Only generate if origin is Generated and emit strategy allows it
        self.origin == TypeOrigin::Generated && matches!(
            self.emit_strategy,
            EmitStrategy::Generate | EmitStrategy::GenerateInSccGroup(_)
        )
    }
    
    /// Get SCC group ID if in a cycle
    pub fn scc_group(&self) -> Option<usize> {
        match self.emit_strategy {
            EmitStrategy::GenerateInSccGroup(id) => Some(id),
            _ => self.cycle_handling.scc_id,
        }
    }
}

// =============================================================================
// CodegenContext
// =============================================================================

/// Immutable codegen context - frozen after build().
/// 
/// Contains all analysis results. Emitters access this through Regions.
pub struct CodegenContext {
    /// The underlying schema graph
    graph: SchemaGraph,
    
    /// Global codegen configuration
    config: CodegenConfig,
    
    /// Name resolver with collision handling
    name_resolver: NameResolver,
    
    /// Detected shapes for all schemas
    #[allow(dead_code)]
    shapes: HashMap<SchemaId, SchemaShape>,
    
    /// Classifications for all schemas
    classifications: HashMap<SchemaId, Classification>,
    
    /// SCC analysis results
    scc_analysis: SccAnalysis,
    
    /// Diagnostics collected during analysis
    diagnostics: Diagnostics,
}

impl CodegenContext {
    /// Build context from a schema graph with default config.
    /// 
    /// Primitives are automatically detected from directory structure
    /// (any schema in a "primitives/" directory).
    pub fn build(graph: SchemaGraph) -> Result<Self, Diagnostics> {
        Self::build_with_config(graph, CodegenConfig::default())
    }
    
    /// Build context from a schema graph with custom config.
    pub fn build_with_config(graph: SchemaGraph, config: CodegenConfig) -> Result<Self, Diagnostics> {
        let mut diagnostics = Diagnostics::new();
        
        // Phase 1: Build name resolver (detects primitives by directory)
        let name_resolver = NameResolver::build(&graph, config.naming.clone());
        
        // Phase 2: Detect shapes
        let shapes = detect_all_shapes(&graph);
        
        // Phase 3: Compute SCCs and boxing
        let scc_analysis = compute_scc_analysis(&graph);
        
        // Validate boxed edges are within SCCs
        let validation_errors = validate_boxed_edges(&scc_analysis);
        for err in validation_errors {
            diagnostics.boxed_edge_not_in_scc(&err.edge, &err.reason);
        }
        
        // Phase 4: Classify all schemas
        // Build primitives set from name resolver
        let primitives: HashSet<SchemaId> = name_resolver
            .all_resolved()
            .filter(|(_, r)| r.origin == TypeOrigin::Primitive)
            .map(|(id, _)| id.clone())
            .collect();
        
        let classifier = Classifier::new(&graph, &shapes, &scc_analysis, primitives);
        let classifications = classifier.classify_all();
        
        // Check for errors
        if diagnostics.has_errors() {
            return Err(diagnostics);
        }
        
        Ok(Self {
            graph,
            config,
            name_resolver,
            shapes,
            classifications,
            scc_analysis,
            diagnostics,
        })
    }
    
    /// Extract a Region for a schema.
    /// 
    /// Region is a pure projection - no raw JSON access.
    /// Type names are already resolved.
    pub fn region(&self, schema_id: &str) -> Option<Region> {
        let classification = self.classifications.get(schema_id)?;
        let resolved_name = self.name_resolver.get(schema_id)?;
        let cycle_handling = self.scc_analysis.get(schema_id)
            .cloned()
            .unwrap_or_default();

        // Extract extensions from the shape
        let extensions = self.shapes.get(schema_id)
            .map(|shape| match shape {
                SchemaShape::StringEnum { extensions, .. } => extensions.clone(),
                SchemaShape::OneOfStringEnum { extensions, .. } => extensions.clone(),
                SchemaShape::Object { extensions, .. } => extensions.clone(),
                _ => CodegenExtensions::default(),
            })
            .unwrap_or_default();

        if extensions.generate_default {
            eprintln!("DEBUG: Schema {} has generate_default=true", schema_id);
        }

        Some(Region {
            schema_id: schema_id.to_string(),
            type_kind: classification.type_kind.clone(),
            emit_strategy: classification.emit_strategy.clone(),
            cycle_handling: cycle_handling.clone(),
            canonical_name: resolved_name.canonical_name.clone(),
            origin: resolved_name.origin.clone(),
            boxed_fields: cycle_handling.boxed_fields,
            directory: resolved_name.directory.clone(),
            extensions,
        })
    }
    
    /// Resolve a field type to a language-specific type string using RenderProfile
    pub fn resolve_field_type(&self, field_type: &FieldType, needs_box: bool, profile: &RenderProfile) -> String {
        match field_type {
            FieldType::SchemaRef(ref_target) => {
                let base_type = if let Some(resolved) = self.name_resolver.resolve_ref(ref_target) {
                    resolved.canonical_name.clone()
                } else {
                    // Unknown ref - extract name from path
                    ref_target
                        .rsplit('/')
                        .next()
                        .unwrap_or(ref_target)
                        .trim_end_matches(".schema.json")
                        .trim_end_matches(".json")
                        .to_string()
                };
                
                if needs_box {
                    profile.wrap_box(&base_type)
                } else {
                    base_type
                }
            }
            FieldType::Scalar(scalar) => {
                let scalar_name = match scalar {
                    JsonScalarKind::String => "string",
                    JsonScalarKind::Integer => "integer",
                    JsonScalarKind::Number => "number",
                    JsonScalarKind::Boolean => "boolean",
                    JsonScalarKind::Null => "null",
                };
                profile.scalar_type(scalar_name).to_string()
            }
            FieldType::Array(inner) => {
                let inner_type = self.resolve_field_type(inner, false, profile);
                profile.wrap_array(&inner_type)
            }
            FieldType::FixedArray { items, size } => {
                let inner_type = self.resolve_field_type(items, false, profile);
                profile.wrap_fixed_array(&inner_type, *size)
            }
            FieldType::Tuple(items) => {
                let types: Vec<String> = items
                    .iter()
                    .map(|t| self.resolve_field_type(t, false, profile))
                    .collect();
                profile.wrap_tuple(&types)
            }
            FieldType::Map(value) => {
                let value_type = self.resolve_field_type(value, false, profile);
                profile.wrap_map(&value_type)
            }
            FieldType::InlineObject | FieldType::Unknown => {
                profile.types.any.clone()
            }
        }
    }
    
    /// Get all schema IDs in topological order (dependencies first)
    pub fn topo_order(&self) -> Vec<&SchemaId> {
        let mut result = Vec::new();
        let mut visited = HashSet::new();
        
        for schema_id in self.graph.all_ids() {
            if visited.contains(schema_id) {
                continue;
            }
            
            // Check if part of SCC
            if let Some(scc) = self.scc_analysis.get_scc(schema_id) {
                for member in &scc.members {
                    if visited.insert(member.clone()) {
                        result.push(member);
                    }
                }
            } else {
                visited.insert(schema_id.clone());
                result.push(schema_id);
            }
        }
        
        result
    }
    
    /// Get all regions for schemas that should be generated
    pub fn regions_to_generate(&self) -> Vec<Region> {
        self.topo_order()
            .into_iter()
            .filter_map(|id| self.region(id))
            .filter(|r| r.should_generate())
            .collect()
    }
    
    /// Get diagnostics
    pub fn diagnostics(&self) -> &Diagnostics {
        &self.diagnostics
    }
    
    /// Get the underlying graph
    pub fn graph(&self) -> &SchemaGraph {
        &self.graph
    }
    
    /// Get the name resolver
    pub fn name_resolver(&self) -> &NameResolver {
        &self.name_resolver
    }
    
    /// Get the config
    pub fn config(&self) -> &CodegenConfig {
        &self.config
    }
    
    /// Get schema count
    pub fn schema_count(&self) -> usize {
        self.graph.schema_count()
    }
    
    /// Get SCC count
    pub fn scc_count(&self) -> usize {
        self.scc_analysis.groups.len()
    }
}

// =============================================================================
// Generated Output
// =============================================================================

/// Output from code generation
#[derive(Debug, Clone)]
pub struct GeneratedOutput {
    /// Generated code as a string
    pub code: String,
    /// Number of types generated
    pub type_count: usize,
    /// Any warnings during generation
    pub diagnostics: Diagnostics,
}

// =============================================================================
// Public API
// =============================================================================

/// Generate Rust code from a schema directory with default config.
/// 
/// Primitives are automatically detected from directory structure
/// (any schema in a "primitives/" directory is treated as a primitive).
pub fn generate_rust(schema_dir: &Path) -> Result<GeneratedOutput, Diagnostics> {
    generate_rust_with_config(schema_dir, CodegenConfig::default(), RenderProfile::rust())
}

/// Generate Rust code with custom config and profile.
pub fn generate_rust_with_config(
    schema_dir: &Path, 
    config: CodegenConfig,
    profile: RenderProfile,
) -> Result<GeneratedOutput, Diagnostics> {
    let graph = SchemaGraph::from_directory(schema_dir)
        .map_err(|e| {
            let mut d = Diagnostics::new();
            d.error("", crate::graph::DiagnosticCode::UnknownPattern, e.to_string());
            d
        })?;
    
    let ctx = CodegenContext::build_with_config(graph, config)?;
    
    // Get name resolver stats for header comment
    let stats = ctx.name_resolver().stats();
    
    let regions = ctx.regions_to_generate();
    let mut output = String::new();
    let mut type_count = 0;
    let gen_diags = Diagnostics::new();
    
    // Generate header
    output.push_str("//! Generated from JSON schemas - DO NOT EDIT\n");
    output.push_str("//!\n");
    output.push_str("//! This file is generated by `cargo xtask codegen generate`.\n");
    output.push_str("//! To regenerate, run that command from the workspace root.\n");
    output.push_str("//!\n");
    output.push_str(&format!("//! Stats: {} primitives (skipped), {} generated, {} disambiguated\n\n", 
        stats.primitives, stats.generated, stats.disambiguated));
    
    // Standard imports
    output.push_str("use serde::{Deserialize, Serialize};\n");
    output.push_str("use schemars::JsonSchema;\n\n");
    
    // Import all primitives that were detected
    let primitive_names: Vec<&str> = ctx.name_resolver().primitives().collect();
    if !primitive_names.is_empty() {
        output.push_str("// Primitives from familiar_primitives (auto-detected from primitives/ directory)\n");
        output.push_str("#[allow(unused_imports)]\n");
        output.push_str("use super::{\n");
        
        // Write primitives in sorted chunks for readability
        let mut sorted_primitives: Vec<&str> = primitive_names;
        sorted_primitives.sort();
        
        for chunk in sorted_primitives.chunks(6) {
            output.push_str("    ");
            output.push_str(&chunk.join(", "));
            output.push_str(",\n");
        }
        
        output.push_str("    // Re-exported from dependencies\n");
        output.push_str("    DateTime, Utc, Uuid,\n");
        output.push_str("};\n\n");
    }
    
    // Generate each type
    for region in regions {
        if let Some(code) = rust::emit_region(&region, &ctx, &profile) {
            output.push_str(&code);
            output.push_str("\n");
            type_count += 1;
        }
    }
    
    Ok(GeneratedOutput {
        code: output,
        type_count,
        diagnostics: gen_diags,
    })
}

/// Generate TypeScript code (future)
#[allow(dead_code)]
pub fn generate_typescript(schema_dir: &Path) -> Result<GeneratedOutput, Diagnostics> {
    let _profile = RenderProfile::typescript_strict();
    // TODO: Implement TypeScript emitter
    let _ = schema_dir;
    Err({
        let mut d = Diagnostics::new();
        d.error("", crate::graph::DiagnosticCode::UnknownPattern, "TypeScript emitter not yet implemented".to_string());
        d
    })
}

/// Generate Python code (future)
#[allow(dead_code)]
pub fn generate_python(schema_dir: &Path) -> Result<GeneratedOutput, Diagnostics> {
    let _profile = RenderProfile::python_strict();
    // TODO: Implement Python emitter
    let _ = schema_dir;
    Err({
        let mut d = Diagnostics::new();
        d.error("", crate::graph::DiagnosticCode::UnknownPattern, "Python emitter not yet implemented".to_string());
        d
    })
}

```

### src/graph/analysis.rs

```rust
//! Schema Graph Analysis
//!
//! Computes strongly connected components (SCCs), determines boxing requirements,
//! and provides cycle handling metadata for code generation.

use petgraph::algo::kosaraju_scc;
use petgraph::visit::EdgeRef;
use petgraph::Direction;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

use super::{SchemaGraph, SchemaId};

// =============================================================================
// Field Path Segment
// =============================================================================

/// A segment in a field path, precisely identifying where boxing is needed.
/// 
/// More robust than `Vec<String>` because it handles:
/// - Composition/allOf flattening
/// - Array item schemas  
/// - Renamed fields due to casing/keyword escaping
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum FieldPathSegment {
    /// A named field in an object
    Field(String),
    /// An array index (for tuple types or fixed arrays)
    Index(usize),
    /// The value type in a map (additionalProperties)
    MapValue,
    /// An allOf composition reference (index into allOf array)
    AllOf(usize),
    /// A oneOf variant reference (index into oneOf array)
    OneOf(usize),
    /// An anyOf variant reference (index into anyOf array)
    AnyOf(usize),
    /// Array items type
    ArrayItems,
}

impl std::fmt::Display for FieldPathSegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Field(name) => write!(f, ".{}", name),
            Self::Index(i) => write!(f, "[{}]", i),
            Self::MapValue => write!(f, "[*]"),
            Self::AllOf(i) => write!(f, "<allOf:{}>", i),
            Self::OneOf(i) => write!(f, "<oneOf:{}>", i),
            Self::AnyOf(i) => write!(f, "<anyOf:{}>", i),
            Self::ArrayItems => write!(f, "[]"),
        }
    }
}

/// Full path from schema root to a field that needs boxing
pub type FieldPath = Vec<FieldPathSegment>;

/// Format a field path as a string
pub fn format_field_path(path: &FieldPath) -> String {
    if path.is_empty() {
        return String::from("<root>");
    }
    path.iter().map(|s| s.to_string()).collect::<String>()
}

// =============================================================================
// Boxing Edge
// =============================================================================

/// A field edge that needs boxing to break cycles
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct BoxedEdge {
    /// The schema containing the field that needs boxing
    pub from_schema: SchemaId,
    /// Path from schema root to the field
    pub field_path: FieldPath,
    /// The target schema being referenced (which creates the cycle)
    pub to_schema: SchemaId,
    /// The SCC this edge is part of (for validation)
    pub scc_id: usize,
}

impl BoxedEdge {
    /// Create a composite key for this edge
    pub fn key(&self) -> (SchemaId, FieldPath) {
        (self.from_schema.clone(), self.field_path.clone())
    }
}

// =============================================================================
// SCC Group
// =============================================================================

/// A strongly connected component (cycle group) in the schema graph
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SccGroup {
    /// Unique identifier for this SCC
    pub id: usize,
    /// All schemas in this SCC
    pub members: Vec<SchemaId>,
    /// Edges within this SCC that need boxing to break cycles
    pub boxed_edges: Vec<BoxedEdge>,
    /// Whether this is a self-referential cycle (single schema refs itself)
    pub is_self_referential: bool,
}

// =============================================================================
// Cycle Handling
// =============================================================================

/// Cycle handling metadata for a single schema
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CycleHandling {
    /// Which SCC this schema belongs to (None = acyclic)
    pub scc_id: Option<usize>,
    /// Does this type directly reference itself?
    pub is_self_referential: bool,
    /// Specific field paths in THIS schema that need Box<T>
    pub boxed_fields: Vec<BoxedEdge>,
}

impl CycleHandling {
    /// Returns true if this schema is involved in any cycle
    pub fn is_cyclic(&self) -> bool {
        self.scc_id.is_some()
    }
    
    /// Returns true if a specific field path needs boxing
    pub fn needs_boxing(&self, path: &FieldPath) -> bool {
        self.boxed_fields.iter().any(|e| &e.field_path == path)
    }
}

// =============================================================================
// Analysis Result
// =============================================================================

/// Complete SCC analysis result for the graph
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SccAnalysis {
    /// All SCCs in the graph (only cycles with >1 member OR self-refs)
    pub groups: Vec<SccGroup>,
    /// Per-schema cycle handling metadata
    pub cycle_handling: HashMap<SchemaId, CycleHandling>,
    /// Total number of boxed edges
    pub total_boxed_edges: usize,
}

impl SccAnalysis {
    /// Get cycle handling for a schema
    pub fn get(&self, schema_id: &str) -> Option<&CycleHandling> {
        self.cycle_handling.get(schema_id)
    }
    
    /// Check if a schema is in a cycle
    pub fn is_cyclic(&self, schema_id: &str) -> bool {
        self.cycle_handling.get(schema_id)
            .map(|h| h.is_cyclic())
            .unwrap_or(false)
    }
    
    /// Get the SCC group for a schema
    pub fn get_scc(&self, schema_id: &str) -> Option<&SccGroup> {
        let scc_id = self.cycle_handling.get(schema_id)?.scc_id?;
        self.groups.get(scc_id)
    }
}

// =============================================================================
// Analysis Functions
// =============================================================================

/// Compute SCC analysis for a schema graph
pub fn compute_scc_analysis(graph: &SchemaGraph) -> SccAnalysis {
    let scc_indices = kosaraju_scc(&graph.graph);
    
    let mut groups = Vec::new();
    let mut cycle_handling: HashMap<SchemaId, CycleHandling> = HashMap::new();
    let mut total_boxed_edges = 0;
    
    // First pass: identify SCCs
    for scc in scc_indices {
        if scc.len() == 1 {
            // Check for self-referential cycle
            let node_idx = scc[0];
            if let Some(schema_id) = graph.graph.node_weight(node_idx) {
                let has_self_ref = graph.graph
                    .edges_directed(node_idx, Direction::Outgoing)
                    .any(|e| e.target() == node_idx);
                
                if has_self_ref {
                    let scc_id = groups.len();
                    
                    // Find the self-referential edges
                    let boxed_edges = find_self_ref_edges(graph, schema_id, scc_id);
                    total_boxed_edges += boxed_edges.len();
                    
                    groups.push(SccGroup {
                        id: scc_id,
                        members: vec![schema_id.clone()],
                        boxed_edges: boxed_edges.clone(),
                        is_self_referential: true,
                    });
                    
                    cycle_handling.insert(schema_id.clone(), CycleHandling {
                        scc_id: Some(scc_id),
                        is_self_referential: true,
                        boxed_fields: boxed_edges,
                    });
                } else {
                    // Acyclic schema
                    cycle_handling.insert(schema_id.clone(), CycleHandling::default());
                }
            }
        } else {
            // Multi-member SCC (mutual recursion)
            let scc_id = groups.len();
            let members: Vec<SchemaId> = scc.iter()
                .filter_map(|idx| graph.graph.node_weight(*idx).cloned())
                .collect();
            
            // Find edges within this SCC that need boxing
            let boxed_edges = find_scc_boxed_edges(graph, &members, scc_id);
            total_boxed_edges += boxed_edges.len();
            
            // Build per-schema boxed fields
            let mut schema_boxed: HashMap<SchemaId, Vec<BoxedEdge>> = HashMap::new();
            for edge in &boxed_edges {
                schema_boxed.entry(edge.from_schema.clone())
                    .or_default()
                    .push(edge.clone());
            }
            
            for member in &members {
                cycle_handling.insert(member.clone(), CycleHandling {
                    scc_id: Some(scc_id),
                    is_self_referential: false,
                    boxed_fields: schema_boxed.remove(member).unwrap_or_default(),
                });
            }
            
            groups.push(SccGroup {
                id: scc_id,
                members,
                boxed_edges,
                is_self_referential: false,
            });
        }
    }
    
    SccAnalysis {
        groups,
        cycle_handling,
        total_boxed_edges,
    }
}

/// Find self-referential edges in a schema
fn find_self_ref_edges(graph: &SchemaGraph, schema_id: &str, scc_id: usize) -> Vec<BoxedEdge> {
    let mut edges = Vec::new();
    
    let Some(raw) = graph.get_raw(schema_id) else {
        return edges;
    };
    
    // Check properties
    if let Some(props) = raw.get("properties").and_then(|v| v.as_object()) {
        for (name, prop) in props {
            if let Some(ref_target) = prop.get("$ref").and_then(|v| v.as_str()) {
                if ref_resolves_to(graph, schema_id, ref_target, schema_id) {
                    edges.push(BoxedEdge {
                        from_schema: schema_id.to_string(),
                        field_path: vec![FieldPathSegment::Field(name.clone())],
                        to_schema: schema_id.to_string(),
                        scc_id,
                    });
                }
            }
            
            // Check items in array properties
            if let Some(items) = prop.get("items") {
                if let Some(ref_target) = items.get("$ref").and_then(|v| v.as_str()) {
                    if ref_resolves_to(graph, schema_id, ref_target, schema_id) {
                        edges.push(BoxedEdge {
                            from_schema: schema_id.to_string(),
                            field_path: vec![
                                FieldPathSegment::Field(name.clone()),
                                FieldPathSegment::ArrayItems,
                            ],
                            to_schema: schema_id.to_string(),
                            scc_id,
                        });
                    }
                }
            }
        }
    }
    
    // Check oneOf/anyOf/allOf
    for (keyword, segment_fn) in [
        ("oneOf", FieldPathSegment::OneOf as fn(usize) -> FieldPathSegment),
        ("anyOf", FieldPathSegment::AnyOf as fn(usize) -> FieldPathSegment),
        ("allOf", FieldPathSegment::AllOf as fn(usize) -> FieldPathSegment),
    ] {
        if let Some(arr) = raw.get(keyword).and_then(|v| v.as_array()) {
            for (i, item) in arr.iter().enumerate() {
                if let Some(ref_target) = item.get("$ref").and_then(|v| v.as_str()) {
                    if ref_resolves_to(graph, schema_id, ref_target, schema_id) {
                        edges.push(BoxedEdge {
                            from_schema: schema_id.to_string(),
                            field_path: vec![segment_fn(i)],
                            to_schema: schema_id.to_string(),
                            scc_id,
                        });
                    }
                }
            }
        }
    }
    
    edges
}

/// Find edges within an SCC that need boxing
fn find_scc_boxed_edges(graph: &SchemaGraph, members: &[SchemaId], scc_id: usize) -> Vec<BoxedEdge> {
    let member_set: HashSet<&str> = members.iter().map(|s| s.as_str()).collect();
    let mut edges = Vec::new();
    
    for schema_id in members {
        let Some(raw) = graph.get_raw(schema_id) else {
            continue;
        };
        
        // Check properties
        if let Some(props) = raw.get("properties").and_then(|v| v.as_object()) {
            for (name, prop) in props {
                if let Some(ref_target) = prop.get("$ref").and_then(|v| v.as_str()) {
                    if let Some(resolved) = resolve_ref_target(graph, schema_id, ref_target) {
                        if member_set.contains(resolved.as_str()) && resolved != *schema_id {
                            edges.push(BoxedEdge {
                                from_schema: schema_id.clone(),
                                field_path: vec![FieldPathSegment::Field(name.clone())],
                                to_schema: resolved,
                                scc_id,
                            });
                        }
                    }
                }
                
                // Check items
                if let Some(items) = prop.get("items") {
                    if let Some(ref_target) = items.get("$ref").and_then(|v| v.as_str()) {
                        if let Some(resolved) = resolve_ref_target(graph, schema_id, ref_target) {
                            if member_set.contains(resolved.as_str()) {
                                edges.push(BoxedEdge {
                                    from_schema: schema_id.clone(),
                                    field_path: vec![
                                        FieldPathSegment::Field(name.clone()),
                                        FieldPathSegment::ArrayItems,
                                    ],
                                    to_schema: resolved,
                                    scc_id,
                                });
                            }
                        }
                    }
                }
            }
        }
        
        // Check composition
        for (keyword, segment_fn) in [
            ("oneOf", FieldPathSegment::OneOf as fn(usize) -> FieldPathSegment),
            ("anyOf", FieldPathSegment::AnyOf as fn(usize) -> FieldPathSegment),
            ("allOf", FieldPathSegment::AllOf as fn(usize) -> FieldPathSegment),
        ] {
            if let Some(arr) = raw.get(keyword).and_then(|v| v.as_array()) {
                for (i, item) in arr.iter().enumerate() {
                    if let Some(ref_target) = item.get("$ref").and_then(|v| v.as_str()) {
                        if let Some(resolved) = resolve_ref_target(graph, schema_id, ref_target) {
                            if member_set.contains(resolved.as_str()) {
                                edges.push(BoxedEdge {
                                    from_schema: schema_id.clone(),
                                    field_path: vec![segment_fn(i)],
                                    to_schema: resolved,
                                    scc_id,
                                });
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Select minimal set of edges to break cycles (simple heuristic: pick one per target)
    // This is a simplification - full cycle breaking would use min-feedback-arc-set
    let mut selected: HashMap<SchemaId, BoxedEdge> = HashMap::new();
    for edge in edges {
        selected.entry(edge.to_schema.clone()).or_insert(edge);
    }
    
    selected.into_values().collect()
}

/// Check if a ref target resolves to a specific schema
fn ref_resolves_to(graph: &SchemaGraph, from_schema: &str, ref_target: &str, expected: &str) -> bool {
    resolve_ref_target(graph, from_schema, ref_target)
        .map(|resolved| resolved == expected)
        .unwrap_or(false)
}

/// Resolve a $ref target to a schema ID
pub fn resolve_ref_target(graph: &SchemaGraph, from_schema: &str, ref_target: &str) -> Option<String> {
    // Handle local refs
    if ref_target.starts_with('#') {
        return None; // Local def, not a schema ref
    }
    
    // Try direct match
    if let Some(id) = graph.resolve(ref_target) {
        return Some(id.clone());
    }
    
    // Try resolving relative to from_schema's path
    if let Some(from_node) = graph.get(from_schema) {
        let parent = from_node.path.parent()?;
        let resolved_path = parent.join(ref_target);
        let normalized = resolved_path.to_string_lossy()
            .replace("\\", "/")
            .split('/')
            .filter(|s| *s != ".")
            .fold(Vec::new(), |mut acc, part| {
                if part == ".." {
                    acc.pop();
                } else {
                    acc.push(part.to_string());
                }
                acc
            })
            .join("/");
        
        if let Some(id) = graph.resolve(&normalized) {
            return Some(id.clone());
        }
    }
    
    None
}

// =============================================================================
// Validation
// =============================================================================

/// Validate that all boxed edges are within SCCs (diagnostic check)
pub fn validate_boxed_edges(analysis: &SccAnalysis) -> Vec<BoxedEdgeValidationError> {
    let mut errors = Vec::new();
    
    for group in &analysis.groups {
        let member_set: HashSet<&str> = group.members.iter().map(|s| s.as_str()).collect();
        
        for edge in &group.boxed_edges {
            // Check from_schema is in SCC
            if !member_set.contains(edge.from_schema.as_str()) {
                errors.push(BoxedEdgeValidationError {
                    edge: edge.clone(),
                    reason: format!(
                        "from_schema '{}' not in SCC {} members: {:?}",
                        edge.from_schema, group.id, group.members
                    ),
                });
            }
            
            // Check to_schema is in SCC (unless self-ref)
            if !group.is_self_referential && !member_set.contains(edge.to_schema.as_str()) {
                errors.push(BoxedEdgeValidationError {
                    edge: edge.clone(),
                    reason: format!(
                        "to_schema '{}' not in SCC {} members: {:?}",
                        edge.to_schema, group.id, group.members
                    ),
                });
            }
        }
    }
    
    errors
}

/// Validation error for a boxed edge
#[derive(Debug, Clone)]
pub struct BoxedEdgeValidationError {
    pub edge: BoxedEdge,
    pub reason: String,
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_field_path_segment_display() {
        assert_eq!(FieldPathSegment::Field("name".into()).to_string(), ".name");
        assert_eq!(FieldPathSegment::Index(0).to_string(), "[0]");
        assert_eq!(FieldPathSegment::MapValue.to_string(), "[*]");
        assert_eq!(FieldPathSegment::AllOf(1).to_string(), "<allOf:1>");
        assert_eq!(FieldPathSegment::ArrayItems.to_string(), "[]");
    }
    
    #[test]
    fn test_format_field_path() {
        let path = vec![
            FieldPathSegment::Field("children".into()),
            FieldPathSegment::ArrayItems,
        ];
        assert_eq!(format_field_path(&path), ".children[]");
    }
}


```

### src/graph/classify.rs

```rust
//! Type Classification
//!
//! Determines HOW to generate code for each schema, consuming:
//! - SchemaShape (from patterns.rs)
//! - CycleHandling (from analysis.rs)
//! - Primitives set (schemas that exist in familiar-primitives)
//!
//! Classification produces TypeKind + EmitStrategy which are language-agnostic.
//! Language-specific lowering happens in the emitters.

use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

use super::analysis::{resolve_ref_target, CycleHandling, SccAnalysis};
use super::patterns::{JsonScalarKind, PropertyShape, SchemaShape};
use super::{SchemaGraph, SchemaId};

// =============================================================================
// Enum Variant
// =============================================================================

/// A variant in an enum type
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnumVariant {
    /// Original value from schema
    pub value: String,
    /// Rust-safe name (PascalCase, escaped if keyword)
    pub rust_name: String,
    /// Whether to emit #[serde(rename = "...")] 
    pub needs_rename: bool,
}

impl EnumVariant {
    pub fn from_value(value: &str) -> Self {
        let rust_name = to_pascal_case(value);
        let needs_rename = rust_name != value;
        Self {
            value: value.to_string(),
            rust_name,
            needs_rename,
        }
    }
    
    /// Create variant using x-familiar-variants mapping if available
    /// 
    /// If the schema has `x-familiar-variants: { "MOMENT": "Moment" }`,
    /// we keep MOMENT as the Rust variant name (matching code expectations)
    /// and add serde rename for serialization.
    pub fn from_value_with_extensions(
        value: &str, 
        extensions: &super::patterns::CodegenExtensions,
    ) -> Self {
        // If we have a variant mapping, use the original value as Rust name
        // (this preserves SCREAMING_CASE when that's what the schema specifies)
        if let Some(ref variants) = extensions.variants {
            if variants.contains_key(value) {
                // Value is in mapping - keep original as Rust variant name
                // The mapping's value is what JSON serializes to (but we may need reverse)
                return Self {
                    value: value.to_string(),
                    rust_name: value.to_string(), // Keep SCREAMING_CASE
                    needs_rename: false, // No rename needed - serialize as-is
                };
            }
        }
        
        // If casing is SCREAMING_SNAKE_CASE, preserve original
        if let Some(ref casing) = extensions.casing {
            if casing == "SCREAMING_SNAKE_CASE" {
                return Self {
                    value: value.to_string(),
                    rust_name: value.to_string(), // Keep original
                    needs_rename: false,
                };
            }
        }
        
        // Default: convert to PascalCase
        Self::from_value(value)
    }
}

// =============================================================================
// Union Variant
// =============================================================================

/// A variant in a tagged union
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnionVariant {
    /// Variant name (for Rust enum)
    pub name: String,
    /// Schema ID this variant references (if $ref)
    pub schema_ref: Option<SchemaId>,
    /// Inline type if not a $ref
    pub inline_type: Option<InlineType>,
}

/// Inline type definition (for unions with inline variants)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineType {
    pub properties: Vec<FieldDef>,
}

// =============================================================================
// Field Definition
// =============================================================================

/// A field in a struct
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FieldDef {
    /// Original JSON name
    pub json_name: String,
    /// Rust-safe field name (snake_case, escaped if keyword)
    pub rust_name: String,
    /// Whether to emit #[serde(rename = "...")]
    pub needs_rename: bool,
    /// Is this field required?
    pub required: bool,
    /// Field type (language-agnostic)
    pub field_type: FieldType,
}

/// Language-agnostic field type
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FieldType {
    /// Reference to another schema
    SchemaRef(SchemaId),
    /// JSON scalar type
    Scalar(JsonScalarKind),
    /// Array of another type (dynamic size)
    Array(Box<FieldType>),
    /// Fixed-size array (known at compile time)
    FixedArray { items: Box<FieldType>, size: usize },
    /// Tuple type (heterogeneous fixed-size array)
    Tuple(Vec<FieldType>),
    /// Map with string keys
    Map(Box<FieldType>),
    /// Inline anonymous object
    InlineObject,
    /// Unknown/any type
    Unknown,
}

// =============================================================================
// Type Kind (Language-Agnostic)
// =============================================================================

/// What kind of type to generate (language-agnostic classification)
/// 
/// Note: This does NOT contain Rust-specific types like `RustType`.
/// Language-specific lowering happens in emitters.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TypeKind {
    /// Simple string enum: `enum Foo { A, B, C }`
    Enum {
        variants: Vec<EnumVariant>,
    },
    
    /// Tagged union: `enum Foo { A(TypeA), B(TypeB) }`
    TaggedUnion {
        discriminator: Option<String>,
        tag_field: Option<String>,
        variants: Vec<UnionVariant>,
    },
    
    /// Struct with named fields
    Struct {
        fields: Vec<FieldDef>,
        /// Whether to flatten allOf refs
        flatten_refs: Vec<SchemaId>,
    },
    
    /// Newtype wrapper around another type
    Newtype {
        /// The wrapped type (schema ref or scalar)
        inner: FieldType,
    },
    
    /// Type alias (re-export from another location)
    Alias {
        target: SchemaId,
    },
    
    /// Primitive type that lives in familiar-primitives
    /// Do not generate - just reference
    Primitive,
}

// =============================================================================
// Emit Strategy
// =============================================================================

/// What to do with this schema during code generation
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum EmitStrategy {
    /// Generate the type normally
    Generate,
    
    /// Re-export from familiar-primitives (don't generate)
    ReExportPrimitive,
    
    /// Skip entirely (primitive handled elsewhere)
    Skip,
    
    /// Generate as part of an SCC group (deterministic order)
    /// The usize is the SCC group ID for ordering
    GenerateInSccGroup(usize),
}

// =============================================================================
// Classification Result
// =============================================================================

/// Classification result for a single schema
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Classification {
    pub schema_id: SchemaId,
    pub type_kind: TypeKind,
    pub emit_strategy: EmitStrategy,
    /// Rust type name to generate
    pub rust_name: String,
}

// =============================================================================
// Classifier
// =============================================================================

/// Classifies all schemas in a graph
pub struct Classifier<'a> {
    graph: &'a SchemaGraph,
    shapes: &'a HashMap<SchemaId, SchemaShape>,
    scc_analysis: &'a SccAnalysis,
    primitives: HashSet<SchemaId>,
}

impl<'a> Classifier<'a> {
    pub fn new(
        graph: &'a SchemaGraph,
        shapes: &'a HashMap<SchemaId, SchemaShape>,
        scc_analysis: &'a SccAnalysis,
        primitives: HashSet<SchemaId>,
    ) -> Self {
        Self {
            graph,
            shapes,
            scc_analysis,
            primitives,
        }
    }
    
    /// Classify all schemas
    pub fn classify_all(&self) -> HashMap<SchemaId, Classification> {
        let mut classifications = HashMap::with_capacity(self.graph.schema_count());
        
        for schema_id in self.graph.all_ids() {
            if let Some(classification) = self.classify(schema_id) {
                classifications.insert(schema_id.clone(), classification);
            }
        }
        
        classifications
    }
    
    /// Classify a single schema
    pub fn classify(&self, schema_id: &str) -> Option<Classification> {
        let shape = self.shapes.get(schema_id)?;
        let cycle_handling = self.scc_analysis.get(schema_id);
        let rust_name = self.compute_rust_name(schema_id);
        
        // Check if this is a primitive (skip based on canonical ID, not shape)
        if self.primitives.contains(schema_id) {
            return Some(Classification {
                schema_id: schema_id.to_string(),
                type_kind: TypeKind::Primitive,
                emit_strategy: EmitStrategy::Skip,
                rust_name,
            });
        }
        
        let (type_kind, emit_strategy) = self.classify_shape(schema_id, shape, cycle_handling);
        
        Some(Classification {
            schema_id: schema_id.to_string(),
            type_kind,
            emit_strategy,
            rust_name,
        })
    }
    
    fn classify_shape(
        &self,
        schema_id: &str,
        shape: &SchemaShape,
        cycle_handling: Option<&CycleHandling>,
    ) -> (TypeKind, EmitStrategy) {
        let emit_strategy = if let Some(ch) = cycle_handling {
            if let Some(scc_id) = ch.scc_id {
                EmitStrategy::GenerateInSccGroup(scc_id)
            } else {
                EmitStrategy::Generate
            }
        } else {
            EmitStrategy::Generate
        };
        
        let type_kind = match shape {
            SchemaShape::StringEnum { values, extensions } => {
                TypeKind::Enum {
                    variants: values.iter()
                        .map(|v| EnumVariant::from_value_with_extensions(v, extensions))
                        .collect(),
                }
            }
            
            SchemaShape::OneOfStringEnum { variants, extensions } => {
                TypeKind::Enum {
                    variants: variants.iter()
                        .map(|v| EnumVariant::from_value_with_extensions(v, extensions))
                        .collect(),
                }
            }
            
            SchemaShape::OneOfObjects { variants, discriminator } => {
                let union_variants: Vec<UnionVariant> = variants
                    .iter()
                    .enumerate()
                    .map(|(i, v)| {
                        // Name should always be present after patterns.rs fix, but provide fallback
                        let name = v.name.clone().unwrap_or_else(|| format!("Variant{}", i));
                        UnionVariant {
                            name: to_pascal_case(&name),
                            schema_ref: v.ref_target.clone(),
                            inline_type: None, // TODO: handle inline objects
                        }
                    })
                    .collect();
                
                TypeKind::TaggedUnion {
                    discriminator: discriminator.clone(),
                    tag_field: discriminator.clone(), // Often the same
                    variants: union_variants,
                }
            }
            
            SchemaShape::OneOfMixed { .. } => {
                // Fall back to unknown/any type
                TypeKind::Newtype {
                    inner: FieldType::Unknown,
                }
            }
            
            SchemaShape::FormattedString { format } => {
                // Check if format suggests a specific type
                match format.as_deref() {
                    Some("date-time") | Some("date") | Some("time") => {
                        TypeKind::Newtype {
                            inner: FieldType::Scalar(JsonScalarKind::String),
                        }
                    }
                    Some("uuid") => {
                        TypeKind::Newtype {
                            inner: FieldType::Scalar(JsonScalarKind::String),
                        }
                    }
                    Some("email") | Some("uri") | Some("hostname") => {
                        TypeKind::Newtype {
                            inner: FieldType::Scalar(JsonScalarKind::String),
                        }
                    }
                    _ => {
                        TypeKind::Newtype {
                            inner: FieldType::Scalar(JsonScalarKind::String),
                        }
                    }
                }
            }
            
            SchemaShape::Numeric { json_type, .. } => {
                TypeKind::Newtype {
                    inner: FieldType::Scalar(json_type.clone()),
                }
            }
            
            SchemaShape::Boolean => {
                TypeKind::Newtype {
                    inner: FieldType::Scalar(JsonScalarKind::Boolean),
                }
            }
            
            SchemaShape::Object { properties, additional_properties: _, extensions: _, defaults: _ } => {
                let fields: Vec<FieldDef> = properties
                    .iter()
                    .map(|p| self.property_to_field(p, schema_id))
                    .collect();
                
                TypeKind::Struct {
                    fields,
                    flatten_refs: Vec::new(),
                }
            }
            
            SchemaShape::Ref { target } => {
                // Check if target is a primitive
                if self.primitives.contains(target) {
                    return (
                        TypeKind::Alias { target: target.clone() },
                        EmitStrategy::ReExportPrimitive,
                    );
                }
                
                TypeKind::Alias { target: target.clone() }
            }
            
            SchemaShape::AllOf { refs, inline_properties } => {
                let fields: Vec<FieldDef> = inline_properties
                    .iter()
                    .map(|p| self.property_to_field(p, schema_id))
                    .collect();
                
                TypeKind::Struct {
                    fields,
                    flatten_refs: refs.clone(),
                }
            }
            
            SchemaShape::Array { items } => {
                let inner_type = self.shape_to_field_type(items, schema_id);
                TypeKind::Newtype {
                    inner: FieldType::Array(Box::new(inner_type)),
                }
            }

            SchemaShape::FixedArray { items, size } => {
                let inner_type = self.shape_to_field_type(items, schema_id);
                TypeKind::Newtype {
                    inner: FieldType::FixedArray {
                        items: Box::new(inner_type),
                        size: *size,
                    },
                }
            }
            
            SchemaShape::TupleArray { items } => {
                let tuple_types: Vec<FieldType> = items
                    .iter()
                    .map(|i| self.shape_to_field_type(i, schema_id))
                    .collect();
                TypeKind::Newtype {
                    inner: FieldType::Tuple(tuple_types),
                }
            }
            
            SchemaShape::Map { value_type } => {
                let inner_type = self.property_type_to_field_type(value_type, schema_id);
                TypeKind::Newtype {
                    inner: FieldType::Map(Box::new(inner_type)),
                }
            }
            
            SchemaShape::Unknown { .. } => {
                TypeKind::Newtype {
                    inner: FieldType::Unknown,
                }
            }
        };
        
        (type_kind, emit_strategy)
    }
    
    fn property_to_field(&self, prop: &PropertyShape, current_schema_id: &str) -> FieldDef {
        // Handle special characters in field names
        // $ is not valid in Rust identifiers, so strip it
        let sanitized_name = if prop.name.starts_with('$') {
            format!("schema_{}", &prop.name[1..])
        } else {
            prop.name.clone()
        };
        
        let rust_name = to_snake_case(&sanitized_name);
        let needs_rename = rust_name != prop.name;
        
        FieldDef {
            json_name: prop.name.clone(),
            rust_name,
            needs_rename,
            required: prop.required,
            field_type: self.property_type_to_field_type(&prop.shape, current_schema_id),
        }
    }
    
    fn property_type_to_field_type(
        &self,
        prop_type: &super::patterns::PropertyTypeShape,
        current_schema_id: &str,
    ) -> FieldType {
        use super::patterns::PropertyTypeShape;
        
        match prop_type {
            PropertyTypeShape::Ref(target) => {
                let resolved_target = resolve_ref_target(self.graph, current_schema_id, target)
                    .unwrap_or_else(|| target.clone());
                FieldType::SchemaRef(resolved_target)
            }
            PropertyTypeShape::Scalar(kind) => FieldType::Scalar(kind.clone()),
            PropertyTypeShape::Array { items } => {
                FieldType::Array(Box::new(self.property_type_to_field_type(items, current_schema_id)))
            }
            PropertyTypeShape::FixedArray { items, size } => {
                FieldType::FixedArray {
                    items: Box::new(self.property_type_to_field_type(items, current_schema_id)),
                    size: *size,
                }
            }
            PropertyTypeShape::Tuple { items } => {
                FieldType::Tuple(
                    items.iter()
                        .map(|i| self.property_type_to_field_type(i, current_schema_id))
                        .collect()
                )
            }
            PropertyTypeShape::InlineObject => FieldType::InlineObject,
            PropertyTypeShape::Unknown => FieldType::Unknown,
        }
    }
    
    fn shape_to_field_type(&self, shape: &SchemaShape, current_schema_id: &str) -> FieldType {
        match shape {
            SchemaShape::Ref { target } => {
                let resolved_target = resolve_ref_target(self.graph, current_schema_id, target)
                    .unwrap_or_else(|| target.clone());
                FieldType::SchemaRef(resolved_target)
            }
            SchemaShape::FormattedString { .. } => FieldType::Scalar(JsonScalarKind::String),
            SchemaShape::Numeric { json_type, .. } => FieldType::Scalar(json_type.clone()),
            SchemaShape::Boolean => FieldType::Scalar(JsonScalarKind::Boolean),
            SchemaShape::Array { items } => {
                FieldType::Array(Box::new(self.shape_to_field_type(items, current_schema_id)))
            }
            SchemaShape::FixedArray { items, size } => {
                FieldType::FixedArray {
                    items: Box::new(self.shape_to_field_type(items, current_schema_id)),
                    size: *size,
                }
            }
            SchemaShape::TupleArray { items } => {
                FieldType::Tuple(
                    items.iter()
                        .map(|i| self.shape_to_field_type(i, current_schema_id))
                        .collect()
                )
            }
            _ => FieldType::Unknown,
        }
    }
    
    fn compute_rust_name(&self, schema_id: &str) -> String {
        // Try to get title from schema node
        if let Some(node) = self.graph.get(schema_id) {
            if let Some(title) = &node.title {
                return to_pascal_case(title);
            }
        }
        
        // Fall back to extracting from path
        let name = schema_id
            .rsplit('/')
            .next()
            .unwrap_or(schema_id)
            .trim_end_matches(".schema.json")
            .trim_end_matches(".json");
        
        to_pascal_case(name)
    }
}

// =============================================================================
// Naming Utilities
// =============================================================================

/// Convert string to PascalCase
pub fn to_pascal_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    let mut capitalize_next = true;
    
    // Check if all uppercase (like SCREAMING_SNAKE_CASE)
    let is_all_caps = s.chars().all(|c| c.is_ascii_uppercase() || c == '_' || c == '-');
    
    for c in s.chars() {
        if c == '_' || c == '-' || c == ' ' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else if is_all_caps {
            // Convert to lowercase for SCREAMING_SNAKE_CASE
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }
    
    // Handle keywords - add trailing underscore
    if is_rust_keyword(&result.to_lowercase()) {
        result.push('_');
    }
    
    result
}

/// Convert string to snake_case
pub fn to_snake_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len() + 4);
    let mut prev_lower = false;
    
    for c in s.chars() {
        if c.is_ascii_uppercase() {
            if prev_lower {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
            prev_lower = false;
        } else if c == '-' || c == ' ' {
            result.push('_');
            prev_lower = false;
        } else {
            result.push(c);
            prev_lower = c.is_ascii_lowercase();
        }
    }
    
    // Handle keywords
    if is_rust_keyword(&result) {
        result.push('_');
    }
    
    result
}

/// Check if a string is a Rust keyword
fn is_rust_keyword(s: &str) -> bool {
    matches!(
        s,
        "as" | "async" | "await" | "break" | "const" | "continue" | "crate" | "dyn" |
        "else" | "enum" | "extern" | "false" | "fn" | "for" | "if" | "impl" |
        "in" | "let" | "loop" | "match" | "mod" | "move" | "mut" | "pub" |
        "ref" | "return" | "self" | "Self" | "static" | "struct" | "super" |
        "trait" | "true" | "type" | "unsafe" | "use" | "where" | "while" |
        // Reserved for future use
        "abstract" | "become" | "box" | "do" | "final" | "macro" | "override" |
        "priv" | "try" | "typeof" | "unsized" | "virtual" | "yield"
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("hello_world"), "HelloWorld");
        assert_eq!(to_pascal_case("HelloWorld"), "HelloWorld");
        assert_eq!(to_pascal_case("hello-world"), "HelloWorld");
        assert_eq!(to_pascal_case("PENDING"), "Pending");
        assert_eq!(to_pascal_case("SCREAMING_SNAKE"), "ScreamingSnake");
        // Keywords get trailing underscore
        assert_eq!(to_pascal_case("type"), "Type_");
        assert_eq!(to_pascal_case("Type"), "Type_");
    }
    
    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("HelloWorld"), "hello_world");
        assert_eq!(to_snake_case("helloWorld"), "hello_world");
        assert_eq!(to_snake_case("hello-world"), "hello_world");
        assert_eq!(to_snake_case("type"), "type_"); // Keyword
    }
    
    #[test]
    fn test_enum_variant_from_value() {
        let v = EnumVariant::from_value("PENDING");
        assert_eq!(v.rust_name, "Pending");
        assert!(v.needs_rename); // PENDING != Pending
        
        let v = EnumVariant::from_value("Active");
        assert_eq!(v.rust_name, "Active");
        assert!(!v.needs_rename);
    }
}


```

### tests/golden_tests.rs

```rust
//! Golden Tests for Schema Shapes
//!
//! Tests that each SchemaShape variant is correctly detected and classified.

use std::collections::HashSet;
use std::path::Path;

use familiar_schemas::graph::{
    SchemaGraph, SchemaShape, TypeKind, EmitStrategy,
    detect_shape, detect_all_shapes, compute_scc_analysis,
    Classifier,
};
use familiar_schemas::codegen::CodegenContext;

fn fixtures_path() -> &'static Path {
    Path::new(env!("CARGO_MANIFEST_DIR")).join("tests/fixtures").leak()
}

// =============================================================================
// Shape Detection Tests
// =============================================================================

#[test]
fn test_string_enum_detection() {
    let schema: serde_json::Value = serde_json::from_str(include_str!("fixtures/string_enum.json")).unwrap();
    let shape = detect_shape(&schema);
    
    match shape {
        SchemaShape::StringEnum { values, .. } => {
            assert_eq!(values, vec!["admin", "member", "guest"]);
        }
        other => panic!("Expected StringEnum, got {:?}", other),
    }
}

#[test]
fn test_oneof_enum_detection() {
    let schema: serde_json::Value = serde_json::from_str(include_str!("fixtures/oneof_enum.json")).unwrap();
    let shape = detect_shape(&schema);
    
    match shape {
        SchemaShape::OneOfStringEnum { variants, .. } => {
            assert_eq!(variants, vec!["pending", "active", "completed"]);
        }
        other => panic!("Expected OneOfStringEnum, got {:?}", other),
    }
}

#[test]
fn test_oneof_tagged_detection() {
    let schema: serde_json::Value = serde_json::from_str(include_str!("fixtures/oneof_tagged.json")).unwrap();
    let shape = detect_shape(&schema);
    
    match shape {
        SchemaShape::OneOfObjects { variants, discriminator } => {
            assert_eq!(variants.len(), 2);
            assert_eq!(discriminator, Some("type".to_string()));
        }
        other => panic!("Expected OneOfObjects, got {:?}", other),
    }
}

#[test]
fn test_oneof_mixed_detection() {
    let schema: serde_json::Value = serde_json::from_str(include_str!("fixtures/oneof_mixed.json")).unwrap();
    let shape = detect_shape(&schema);
    
    match shape {
        SchemaShape::OneOfMixed { .. } => {
            // Expected - mixed oneOf should be detected
        }
        other => panic!("Expected OneOfMixed, got {:?}", other),
    }
}

#[test]
fn test_simple_struct_detection() {
    let schema: serde_json::Value = serde_json::from_str(include_str!("fixtures/simple_struct.json")).unwrap();
    let shape = detect_shape(&schema);
    
    match shape {
        SchemaShape::Object { properties, .. } => {
            assert_eq!(properties.len(), 5);
            
            // Check required fields
            let id_field = properties.iter().find(|p| p.name == "id").unwrap();
            assert!(id_field.required);
            
            let age_field = properties.iter().find(|p| p.name == "age").unwrap();
            assert!(!age_field.required);
        }
        other => panic!("Expected Object, got {:?}", other),
    }
}

#[test]
fn test_alias_detection() {
    let schema: serde_json::Value = serde_json::from_str(include_str!("fixtures/alias_of_alias.json")).unwrap();
    let shape = detect_shape(&schema);
    
    match shape {
        SchemaShape::Ref { target } => {
            assert_eq!(target, "alias_b.json");
        }
        other => panic!("Expected Ref, got {:?}", other),
    }
}

#[test]
fn test_self_recursive_detection() {
    let schema: serde_json::Value = serde_json::from_str(include_str!("fixtures/self_recursive.json")).unwrap();
    let shape = detect_shape(&schema);
    
    match shape {
        SchemaShape::Object { properties, .. } => {
            let children = properties.iter().find(|p| p.name == "children").unwrap();
            // Children should have array with $ref items
            match &children.shape {
                familiar_schemas::graph::PropertyTypeShape::Array { items } => {
                    match items.as_ref() {
                        familiar_schemas::graph::PropertyTypeShape::Ref(target) => {
                            assert!(target.contains("self_recursive"));
                        }
                        _ => panic!("Expected Ref in array items"),
                    }
                }
                _ => panic!("Expected Array shape for children"),
            }
        }
        other => panic!("Expected Object, got {:?}", other),
    }
}

// =============================================================================
// Full Pipeline Tests
// =============================================================================

#[test]
fn test_full_pipeline_with_fixtures() {
    let graph = SchemaGraph::from_directory(fixtures_path()).unwrap();
    
    assert!(graph.schema_count() >= 10, "Should load at least 10 fixture schemas");
    
    // Detect all shapes
    let shapes = detect_all_shapes(&graph);
    assert_eq!(shapes.len(), graph.schema_count());
    
    // Compute SCCs
    let scc_analysis = compute_scc_analysis(&graph);
    
    // Should have at least one SCC (mutual recursion)
    // Note: may also detect self-recursive
    
    // Classify all
    let classifier = Classifier::new(&graph, &shapes, &scc_analysis, HashSet::new());
    let classifications = classifier.classify_all();
    
    // Check string_enum classification
    if let Some(class) = classifications.get("fixtures/string_enum.json") {
        match &class.type_kind {
            TypeKind::Enum { variants } => {
                assert_eq!(variants.len(), 3);
                assert_eq!(class.emit_strategy, EmitStrategy::Generate);
            }
            other => panic!("Expected Enum, got {:?}", other),
        }
    }
    
    // Check simple_struct classification
    if let Some(class) = classifications.get("fixtures/simple_struct.json") {
        match &class.type_kind {
            TypeKind::Struct { fields, .. } => {
                assert_eq!(fields.len(), 5);
            }
            other => panic!("Expected Struct, got {:?}", other),
        }
    }
}

#[test]
fn test_codegen_context_build() {
    let graph = SchemaGraph::from_directory(fixtures_path()).unwrap();
    let ctx = CodegenContext::build(graph).unwrap();
    
    assert!(ctx.schema_count() >= 10);
    
    // Get regions for all schemas that should be generated
    let regions = ctx.regions_to_generate();
    assert!(!regions.is_empty());
    
    // Check that string_enum has a region (file is string_enum.json -> StringEnum)
    let enum_region = regions.iter().find(|r| r.canonical_name == "StringEnum");
    assert!(enum_region.is_some(), "Should have StringEnum region");
}

#[test]
fn test_mutual_recursion_scc() {
    let graph = SchemaGraph::from_directory(fixtures_path()).unwrap();
    let scc_analysis = compute_scc_analysis(&graph);
    
    // mutual_a and mutual_b should be in the same SCC
    let a_handling = scc_analysis.get("fixtures/mutual_a.json");
    let b_handling = scc_analysis.get("fixtures/mutual_b.json");
    
    if let (Some(a), Some(b)) = (a_handling, b_handling) {
        assert!(a.is_cyclic() || b.is_cyclic(), "At least one should be cyclic");
        if a.is_cyclic() && b.is_cyclic() {
            assert_eq!(a.scc_id, b.scc_id, "Should be in same SCC");
        }
    }
}

#[test]
fn test_self_recursive_boxing() {
    let graph = SchemaGraph::from_directory(fixtures_path()).unwrap();
    let scc_analysis = compute_scc_analysis(&graph);
    
    let handling = scc_analysis.get("fixtures/self_recursive.json");
    if let Some(h) = handling {
        // Self-recursive should be detected
        assert!(h.is_cyclic() || h.is_self_referential, "Should be cyclic or self-referential");
    }
}

// =============================================================================
// Import Path Stability Tests
// =============================================================================

/// Test that import resolution is consistent across MCP and codegen paths.
/// Both should use SchemaGraph::imports_for() - this ensures parity.
#[test]
fn test_import_resolver_stability() {
    let graph = SchemaGraph::from_directory(fixtures_path()).unwrap();
    
    // Get imports for oneof_tagged (depends on message_event and user_event)
    let imports_rust = graph.imports_for("fixtures/oneof_tagged.json", "rust");
    let imports_ts = graph.imports_for("fixtures/oneof_tagged.json", "typescript");
    
    // Should have at least the schema itself
    assert!(!imports_rust.is_empty(), "Should generate Rust imports");
    assert!(!imports_ts.is_empty(), "Should generate TypeScript imports");
    
    // Import paths should be deterministic
    let imports_rust_2 = graph.imports_for("fixtures/oneof_tagged.json", "rust");
    assert_eq!(imports_rust, imports_rust_2, "Import resolution should be deterministic");
}

/// Test that codegen and MCP use the same resolver internally.
/// Since both use SchemaGraph, this is guaranteed by design - but we test the API.
#[test]
fn test_mcp_codegen_resolver_parity() {
    let graph = SchemaGraph::from_directory(fixtures_path()).unwrap();
    
    // MCP path: SchemaGraph::imports_for
    let _mcp_imports = graph.imports_for("fixtures/simple_struct.json", "rust");
    
    // Codegen path: also uses SchemaGraph internally
    // NameResolver uses graph for resolution
    let ctx = CodegenContext::build(graph).unwrap();
    if let Some(region) = ctx.region("fixtures/simple_struct.json") {
        // Region should be generated
        assert!(region.should_generate(), "simple_struct should be generated");
        
        // Name resolver should be accessible from context
        let name_resolver = ctx.name_resolver();
        let resolved = name_resolver.get("fixtures/simple_struct.json");
        assert!(resolved.is_some(), "simple_struct should be resolved");
    }
}

/// Test that type name resolution is consistent.
/// SchemaGraph::get() + node.title should match classification rust_name.
#[test]
fn test_type_name_resolution_parity() {
    let graph = SchemaGraph::from_directory(fixtures_path()).unwrap();
    let shapes = detect_all_shapes(&graph);
    let scc_analysis = compute_scc_analysis(&graph);
    let classifier = Classifier::new(&graph, &shapes, &scc_analysis, HashSet::new());
    let classifications = classifier.classify_all();
    
    for schema_id in graph.all_ids() {
        if let Some(node) = graph.get(schema_id) {
            if let Some(class) = classifications.get(schema_id) {
                // If schema has a title, rust_name should be PascalCase of it
                if let Some(title) = &node.title {
                    let expected = familiar_schemas::graph::to_pascal_case(title);
                    assert_eq!(class.rust_name, expected, 
                        "Type name mismatch for {}: graph title '{}' -> '{}', but classification gave '{}'",
                        schema_id, title, expected, class.rust_name);
                }
            }
        }
    }
}


```

